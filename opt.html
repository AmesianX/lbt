<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Optimization &mdash; Tutorial: Creating an LLVM Toolchain for the Cpu0 Architecture</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/print.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '3.6.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/theme_extras.js"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="top" title="Tutorial: Creating an LLVM Toolchain for the Cpu0 Architecture" href="index.html" />
    <link rel="next" title="Library" href="lib.html" />
    <link rel="prev" title="Cpu0 ELF linker" href="lld.html" /> 
  </head>
  <body>
      <div class="header"><h1 class="heading"><a href="index.html">
          <span>Tutorial: Creating an LLVM Toolchain for the Cpu0 Architecture</span></a></h1>
        <h2 class="heading"><span>Optimization</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="lld.html">Cpu0 ELF linker</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="lib.html">Library</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="optimization">
<span id="sec-opt"></span><h1>Optimization<a class="headerlink" href="#optimization" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#llvm-ir-optimization" id="id5">LLVM IR optimization</a></li>
<li><a class="reference internal" href="#project" id="id6">Project</a><ul>
<li><a class="reference internal" href="#llvm-vpo" id="id7">LLVM-VPO</a></li>
</ul>
</li>
</ul>
</div>
<p>This chapter introduce llvm optimization.</p>
<div class="section" id="llvm-ir-optimization">
<h2><a class="toc-backref" href="#id5">LLVM IR optimization</a><a class="headerlink" href="#llvm-ir-optimization" title="Permalink to this headline">¶</a></h2>
<p>The llvm-link provide optimizaton in IR level which can apply in different
programs developed by more than one language. Of course, it can apply in
the same language which support seperate compile.</p>
<div class="figure align-center" id="llvm-link-f-flow">
<a class="reference internal image-reference" href="_images/13.png"><img alt="_images/13.png" src="_images/13.png" /></a>
<p class="caption">Figure 1: llvm-link flow</p>
</div>
<p>Clang provide optimization options to do optimation from high level language
to IR.
But since many languages like C/C++ support separate compilation, it meaning
there is no chance to do inter-procedure optimization if the functions come from
different source files.
To solve this problem, llvm provide <strong>llvm-link</strong> to link all *.bc into a single
IR file, and through <strong>opt</strong> to finish the inter-procedure optimation <a class="footnote-reference" href="#id4" id="id1">[1]</a>.
Beyond the DAG local optimization mentioned in Chapter 2, there are global
optimization based on inter-procedure analysis <a class="footnote-reference" href="#dragonbooks-9" id="id2">[2]</a>.
The following steps and examples show this optimization solution in llvm.</p>
<p class="rubric">exlbt/input/optimizen/1.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">callee</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">*</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">exlbt/input/optimize/2.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">extern</span> <span class="kt">int</span> <span class="nf">callee</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">X</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">caller</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">T</span><span class="p">;</span>

  <span class="n">T</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">callee</span><span class="p">(</span><span class="o">&amp;</span><span class="n">T</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-bash"><div class="highlight"><pre>JonathantekiiMac:input Jonathan<span class="nv">$ </span>clang -O3 -target mips-unknown-linux-gnu
-c 1.cpp -emit-llvm -o 1.bc
JonathantekiiMac:input Jonathan<span class="nv">$ </span>clang -O3 -target mips-unknown-linux-gnu
-c 2.cpp -emit-llvm -o 2.bc
JonathantekiiMac:input Jonathan<span class="nv">$ </span>llvm-link -o<span class="o">=</span>a.bc 1.bc 2.bc
JonathantekiiMac:input Jonathan<span class="nv">$ </span>opt -O3 -o<span class="o">=</span>a1.bc a.bc
JonathantekiiMac:input Jonathan<span class="nv">$ </span>llvm-dis a.bc -o -
...
; Function Attrs: nounwind <span class="nb">readonly</span>
define i32 @_Z6calleePKi<span class="o">(</span>i32* nocapture <span class="nb">readonly</span> %a<span class="o">)</span> <span class="c">#0 {</span>
  %1 <span class="o">=</span> load i32* %a, align 4, !tbaa !1
  %2 <span class="o">=</span> add nsw i32 %1, 1
  ret i32 %2
<span class="o">}</span>

define i32 @_Z6callerv<span class="o">()</span> <span class="c">#1 {</span>
  %T <span class="o">=</span> alloca i32, align 4
  store i32 4, i32* %T, align 4, !tbaa !1
  %1 <span class="o">=</span> call i32 @_Z6calleePKi<span class="o">(</span>i32* %T<span class="o">)</span>
  ret i32 %1
<span class="o">}</span>
...

JonathantekiiMac:input Jonathan<span class="nv">$ </span>llvm-dis a1.bc -o -
...
; Function Attrs: nounwind <span class="nb">readonly</span>
define i32 @_Z6calleePKi<span class="o">(</span>i32* nocapture <span class="nb">readonly</span> %a<span class="o">)</span> <span class="c">#0 {</span>
  %1 <span class="o">=</span> load i32* %a, align 4, !tbaa !1
  %2 <span class="o">=</span> add nsw i32 %1, 1
  ret i32 %2
<span class="o">}</span>

; Function Attrs: nounwind readnone
define i32 @_Z6callerv<span class="o">()</span> <span class="c">#1 {</span>
  ret i32 5
<span class="o">}</span>
...
</pre></div>
</div>
<p>From the result as above, the <strong>opt</strong> output has lesser number of IR
instructions.
Of course, the backend code will be more effective as follows,</p>
<div class="highlight-bash"><div class="highlight"><pre>JonathantekiiMac:input Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm a.bc -o -
        .section .mdebug.abi32
        .previous
        .file <span class="s2">&quot;a.bc&quot;</span>
        .text
        .globl        _Z6calleePKi
        .align        2
        .type _Z6calleePKi,@function
        .ent  _Z6calleePKi            <span class="c"># @_Z6calleePKi</span>
_Z6calleePKi:
        .frame        <span class="nv">$sp</span>,0,<span class="nv">$lr</span>
        .mask         0x00000000,0
        .set  noreorder
        .set  nomacro
<span class="c"># BB#0:</span>
        ld    <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
        ld    <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
        addiu <span class="nv">$2</span>, <span class="nv">$2</span>, 1
        ret   <span class="nv">$lr</span>
        .set  macro
        .set  reorder
        .end  _Z6calleePKi
<span class="nv">$tmp0</span>:
        .size _Z6calleePKi, <span class="o">(</span><span class="nv">$tmp0</span><span class="o">)</span>-_Z6calleePKi

        .globl        _Z6callerv
        .align        2
        .type _Z6callerv,@function
        .ent  _Z6callerv              <span class="c"># @_Z6callerv</span>
_Z6callerv:
        .cfi_startproc
        .frame        <span class="nv">$sp</span>,32,<span class="nv">$lr</span>
        .mask         0x00004000,-4
        .set  noreorder
        .cpload       <span class="nv">$t9</span>
        .set  nomacro
<span class="c"># BB#0:</span>
        addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -32
<span class="nv">$tmp3</span>:
        .cfi_def_cfa_offset 32
        st    <span class="nv">$lr</span>, 28<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Spill</span>
<span class="nv">$tmp4</span>:
        .cfi_offset 14, -4
        .cprestore    8
        addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 4
        st    <span class="nv">$2</span>, 24<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
        addiu <span class="nv">$2</span>, <span class="nv">$sp</span>, 24
        st    <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
        ld    <span class="nv">$t9</span>, %call16<span class="o">(</span>_Z6calleePKi<span class="o">)(</span><span class="nv">$gp</span><span class="o">)</span>
        jalr  <span class="nv">$t9</span>
        ld    <span class="nv">$gp</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
        ld    <span class="nv">$lr</span>, 28<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Reload</span>
        addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 32
        ret   <span class="nv">$lr</span>
        .set  macro
        .set  reorder
        .end  _Z6callerv
<span class="nv">$tmp5</span>:
        .size _Z6callerv, <span class="o">(</span><span class="nv">$tmp5</span><span class="o">)</span>-_Z6callerv
        .cfi_endproc

JonathantekiiMac:input Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm a1.bc -o -
        .section .mdebug.abi32
        .previous
        .file <span class="s2">&quot;a1.bc&quot;</span>
        .text
        .globl        _Z6calleePKi
        .align        2
        .type _Z6calleePKi,@function
        .ent  _Z6calleePKi            <span class="c"># @_Z6calleePKi</span>
_Z6calleePKi:
        .frame        <span class="nv">$sp</span>,0,<span class="nv">$lr</span>
        .mask         0x00000000,0
        .set  noreorder
        .set  nomacro
<span class="c"># BB#0:</span>
        ld    <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
        ld    <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
        addiu <span class="nv">$2</span>, <span class="nv">$2</span>, 1
        ret   <span class="nv">$lr</span>
        .set  macro
        .set  reorder
        .end  _Z6calleePKi
<span class="nv">$tmp0</span>:
        .size _Z6calleePKi, <span class="o">(</span><span class="nv">$tmp0</span><span class="o">)</span>-_Z6calleePKi

        .globl        _Z6callerv
        .align        2
        .type _Z6callerv,@function
        .ent  _Z6callerv              <span class="c"># @_Z6callerv</span>
_Z6callerv:
        .frame        <span class="nv">$sp</span>,0,<span class="nv">$lr</span>
        .mask         0x00000000,0
        .set  noreorder
        .set  nomacro
<span class="c"># BB#0:</span>
        addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 5
        ret   <span class="nv">$lr</span>
        .set  macro
        .set  reorder
        .end  _Z6callerv
<span class="nv">$tmp1</span>:
        .size _Z6callerv, <span class="o">(</span><span class="nv">$tmp1</span><span class="o">)</span>-_Z6callerv
</pre></div>
</div>
<p>Though llvm-link provide optimization in IR level to support seperate compile,
it come with the cost in compile time. As you can imagine, any one statement
change will change the output IR of llvm-link. And the obj binary code have to
re-compile. Compare to the seperate compile for each *.c file, it only need to
re-compile the corresponding *.o file only.</p>
</div>
<div class="section" id="project">
<h2><a class="toc-backref" href="#id6">Project</a><a class="headerlink" href="#project" title="Permalink to this headline">¶</a></h2>
<div class="section" id="llvm-vpo">
<h3><a class="toc-backref" href="#id7">LLVM-VPO</a><a class="headerlink" href="#llvm-vpo" title="Permalink to this headline">¶</a></h3>
<p>Friend Gang-Ryung Uh replace LLC compiler by llvm on Very Portable Optimizer
(VPO) compiler toolchain. VPO performs optimizations on a single intermediate
representation called Register Transfer Lists (RTLs). In other word, the system
generate RTLs from llvm IR and it do further optimization on RTLs.</p>
<p>The LLVM-VPO is illustrated at his home page. Click <strong>&#8220;6. LLVM-VPO Compiler
Development - 2012 Google Faculty Research Award&#8221;</strong> at this home page
<a class="footnote-reference" href="#gang-ryung" id="id3">[3]</a> will get the information.</p>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><a class="reference external" href="http://www.cs.cmu.edu/afs/cs/academic/class/15745-s12/public/lectures/L3-LLVM-Part1.pdf">http://www.cs.cmu.edu/afs/cs/academic/class/15745-s12/public/lectures/L3-LLVM-Part1.pdf</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="dragonbooks-9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>Refer chapter 9 of book Compilers: Principles,
Techniques, and Tools (2nd Edition)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="gang-ryung" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td><a class="reference external" href="http://cs.boisestate.edu/~uh/">http://cs.boisestate.edu/~uh/</a></td></tr>
</tbody>
</table>
</div>
</div>
</div>


      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="lld.html">Cpu0 ELF linker</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="lib.html">Library</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer">
        &copy; Copyright 2013, LLVM.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.
    </div>
  </body>
</html>