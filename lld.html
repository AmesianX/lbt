<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Cpu0 ELF linker &mdash; Tutorial: Creating an LLVM Toolchain for the Cpu0 Architecture</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/print.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '3.6.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/theme_extras.js"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="top" title="Tutorial: Creating an LLVM Toolchain for the Cpu0 Architecture" href="index.html" />
    <link rel="next" title="Optimization" href="opt.html" />
    <link rel="prev" title="About" href="about.html" /> 
  </head>
  <body>
      <div class="header"><h1 class="heading"><a href="index.html">
          <span>Tutorial: Creating an LLVM Toolchain for the Cpu0 Architecture</span></a></h1>
        <h2 class="heading"><span>Cpu0 ELF linker</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="about.html">About</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="opt.html">Optimization</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="cpu0-elf-linker">
<span id="sec-lld"></span><h1>Cpu0 ELF linker<a class="headerlink" href="#cpu0-elf-linker" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#elf-to-hex" id="id36">ELF to Hex</a></li>
<li><a class="reference internal" href="#create-cpu0-backend-under-lld" id="id37">Create Cpu0 backend under LLD</a><ul>
<li><a class="reference internal" href="#setup-cpu0-backend-under-lld" id="id38">Setup Cpu0 backend under lld</a></li>
<li><a class="reference internal" href="#cpu0-backend-souce-code" id="id39">Cpu0 backend souce code</a></li>
<li><a class="reference internal" href="#lld-introduction" id="id40">LLD introduction</a><ul>
<li><a class="reference internal" href="#how-lld-do-the-linker-job" id="id41">How LLD do the linker job</a></li>
<li><a class="reference internal" href="#linking-steps" id="id42">Linking Steps</a><ul>
<li><a class="reference internal" href="#command-line-processing" id="id43">Command line processing</a></li>
<li><a class="reference internal" href="#parsing-input-files" id="id44">Parsing input files</a></li>
<li><a class="reference internal" href="#resolving" id="id45">Resolving</a></li>
<li><a class="reference internal" href="#passes-optimizations" id="id46">Passes/Optimizations</a></li>
<li><a class="reference internal" href="#generate-output-file" id="id47">Generate Output File</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#static-linker" id="id48">Static linker</a><ul>
<li><a class="reference internal" href="#run" id="id49">Run</a></li>
<li><a class="reference internal" href="#cpu0-lld-structure" id="id50">Cpu0 lld structure</a></li>
</ul>
</li>
<li><a class="reference internal" href="#dynamic-linker" id="id51">Dynamic linker</a><ul>
<li><a class="reference internal" href="#id7" id="id52">Run</a></li>
<li><a class="reference internal" href="#how-to-work" id="id53">How to work</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#summary" id="id54">Summary</a><ul>
<li><a class="reference internal" href="#create-a-new-backend-base-on-llvm" id="id55">Create a new backend base on LLVM</a></li>
<li><a class="reference internal" href="#contribute-back-to-open-source-through-working-and-learning" id="id56">Contribute back to Open Source through working and learning</a></li>
</ul>
</li>
</ul>
</div>
<p>Like llvm, lld linker include a couple of target in ELF format handling.
The term Cpu0 backend used in this chapter can refer to the ELF format handling
for Cpu0 target machine under lld, llvm compiler backend, or both.
Suppose readers will easy knowing what it refer to.</p>
<div class="figure align-center" id="lld-f-workflow">
<a class="reference internal image-reference" href="_images/1.png"><img alt="_images/1.png" src="_images/1.png" /></a>
<p class="caption">Figure 1: Code generation and execution flow</p>
</div>
<p>As depicted in <a class="pageref" href="#lld-f-workflow">Figure  1</a> of chapter About. Beside llvm backend,
we implement ELF linker and elf2hex to run on Cpu0 verilog simulator.
This chapter extends lld to support Cpu0 backend as well as elf2hex to replace
Cpu0 loader.
After link with lld,
the program with global variables can be allocated in ELF file format layout.
Meaning the relocation records of global variables is resolved. In addition,
llvm-objdump driver is modified for supporting generate Hex file from ELF by
command <tt class="docutils literal"><span class="pre">llvm-objdump</span> <span class="pre">-elf2hex</span></tt>.
With these two tools supported, the global variables exists in
section .data and .rodata can be accessed and transfered to Hex file which feeds
to Verilog Cpu0 machine and run on your PC/Laptop.</p>
<p>As the previouse chapters mentioned, Cpu0 has two relocation models for static
link and dynamic link, respectively, which controlled by option
<tt class="docutils literal"><span class="pre">-relocation-model</span></tt> in <tt class="docutils literal"><span class="pre">llc</span></tt>.
This chapter supports the static link fully, and part of dynamic link for
demostration purpose. Since dynamic link needs the OS involement and the
Cpu0 is run on Verilog bare metal simulator, the dynamic linker program
is added and the Cpu0 Verilog code is extended to demostrate these Cpu0 PIC mode
instructions are work correctly in dynamice link.
However, these part of Cpu0 Verilog codes are not needed in a real machine with
OS support, and the Cpu0 lld&#8217;s and elf2hex&#8217;s dynamic linker function is not full
implemented.
They are programmed by a specific shared library name since the shared library
locating needs the OS&#8217;s help (files management is part of OS&#8217;s job).
Without OS, these things cannot be solved and dynamic link is impossible to
finish.
Anyway, for the dynamic link demostration, we can implement dynamic linker
program and adapt lld, elf2hex, and Cpu0 Verilog code to support a specific
shared library and verify the dynamic link result.
In reality, the Micro CPUs without OS or tiny OS inside only support static
link for C language.</p>
<p>About lld please refer LLD web site here <a class="footnote-reference" href="#id19" id="id1">[1]</a> and LLD install requirement on
Linux here <a class="footnote-reference" href="#id20" id="id2">[2]</a>.
Currently, lld can be built by: gcc and clang 3.5 compiler on Ubuntu, and gcc
on Fedora, as I have tried.
On iMac, lld can be built by clang with the Xcode version as the next sub
section.
If you run with Virtual Machine (VM), please keep your phisical memory size
setting over 1GB to avoid insufficient memory link error.</p>
<div class="section" id="elf-to-hex">
<h2><a class="toc-backref" href="#id36">ELF to Hex</a><a class="headerlink" href="#elf-to-hex" title="Permalink to this headline">¶</a></h2>
<p>Add elf2hex.h, elf2hex-dlink.h and update llvm-objdump driver to support ELF to
Hex for Cpu0 backend as follows,</p>
<p class="rubric">exlbt/llvm-objdump/elf2hex-dlinker.h</p>
<div class="highlight-c++"><pre>#ifdef DLINK

class Cpu0DynFunIndex {
private:
  char soStrtab[20][100];
  int soStrtabSize = 0;

  char exePltName[20][100];
  int exePltNameSize = 0;

  int findPltName(const char* pltName);
public:
  void createPltName(const ObjectFile *o);
  void createStrtab();
  uint16_t correctDynFunIndex(const char* pltName);
};

int Cpu0DynFunIndex::findPltName(const char* pltName) {
  for (int i = 0; i &lt; exePltNameSize; i++)
    if (strcmp(pltName, exePltName[i]) == 0)
      return i;
  return -1;
}

void Cpu0DynFunIndex::createPltName(const ObjectFile *Obj) {
  std::error_code ec;
  std::string Error;

  for (const SectionRef &amp;Section : Obj-&gt;sections()) {
    if (error(ec)) return;
    StringRef Name;
    StringRef Contents;
    uint64_t BaseAddr;
    bool BSS;
    if (error(Section.getName(Name))) continue;
    if (error(Section.getContents(Contents))) continue;
    BaseAddr = Section.getAddress();
    BSS = Section.isBSS();

    if (Name == ".strtab") {
      int num_dyn_entry = 0;
      FILE *fd_num_dyn_entry;
      fd_num_dyn_entry = fopen("dlconfig/num_dyn_entry", "r");
      if (fd_num_dyn_entry != NULL) {
        fscanf(fd_num_dyn_entry, "%d", &amp;num_dyn_entry);
      }
      fclose(fd_num_dyn_entry);

      for (std::size_t addr = 2+strlen(".PLT0"), end = Contents.size(); 
           addr &lt; end; ) {
        if (Contents.substr(addr, strlen("__plt_")) != "__plt_")
          break;
        strcpy(exePltName[exePltNameSize], Contents.data()+addr);
        addr = addr + strlen(exePltName[exePltNameSize]) + 1;
        exePltNameSize++;
      }
      break;
    }
  }
}

void Cpu0DynFunIndex::createStrtab() {
  FILE *fd_dynstrAscii;

  fd_dynstrAscii = fopen("dlconfig/dynstrAscii", "r");
  if (fd_dynstrAscii == NULL)
    fclose(fd_dynstrAscii);
  assert(fd_dynstrAscii != NULL &amp;&amp; "fd_dynstr == NULL");
  int i = 0;
  // function                  result on EOF or error                    
  // --------                  ----------------------
  // fgets()                   NULL
  // fscanf()                  number of succesful conversions
  //                             less than expected
  // fgetc()                   EOF
  // fread()                   number of elements read
  //                             less than expected
  int j = 0;
  for (i=0; 1; i++) {
    j=fscanf(fd_dynstrAscii, "%s", soStrtab[i]);
    if (j != 1)
      break;
  }
  soStrtabSize = i;
  fclose(fd_dynstrAscii);
}

uint16_t Cpu0DynFunIndex::correctDynFunIndex(const char* pltName) {
  int i = findPltName(pltName);
  if (i != -1) {
    int j = 0;
    for (j=0; j &lt; soStrtabSize; j++)
      if (strcmp(soStrtab[j], (const char*)exePltName[i]+strlen("__plt_")) == 0)
        break;
    if (j == soStrtabSize) {
      outs() &lt;&lt; "cannot find " &lt;&lt; exePltName[i] &lt;&lt; "\n";
      exit(1);
    }
    j++;
    return (uint16_t)(j &amp; 0xffff);
  }
  return (uint16_t)0;
}

Cpu0DynFunIndex cpu0DynFunIndex;

static void DisassembleSoInHexFormat(const ObjectFile *Obj
/*, bool InlineRelocs*/  , std::unique_ptr&lt;MCDisassembler&gt;&amp; DisAsm, 
  std::unique_ptr&lt;MCInstPrinter&gt;&amp; IP, uint64_t&amp; lastDumpAddr) {
  std::string Error;
  uint64_t soLastPrintAddr = 0;
  FILE *fd_so_func_offset;
  int num_dyn_entry = 0;
  
  fd_so_func_offset = fopen("dlconfig/so_func_offset", "w");
  if (fd_so_func_offset == NULL)
    fclose(fd_so_func_offset);
  assert(fd_so_func_offset != NULL &amp;&amp; "fd_so_func_offset == NULL");

#ifdef ELF2HEX_DEBUG
  errs() &lt;&lt; format("!lastDumpAddr %8" PRIx64 "\n", lastDumpAddr);
#endif
  std::error_code ec;
  for (const SectionRef &amp;Section : Obj-&gt;sections()) {
    if (error(ec)) break;
    StringRef Name;
    StringRef Contents;
    uint64_t BaseAddr;
    if (error(Section.getName(Name))) continue;
    if (error(Section.getContents(Contents))) continue;
    BaseAddr = Section.getAddress();
  #ifdef ELF2HEX_DEBUG
    errs() &lt;&lt; "Name " &lt;&lt; Name &lt;&lt; format("  BaseAddr %8" PRIx64 "\n", BaseAddr);
    errs() &lt;&lt; format("!!lastDumpAddr %8" PRIx64 "\n", lastDumpAddr);
  #endif
    bool text;
    text = Section.isText();
    if (!text) {
      continue;
    }
    // It's .text section
    uint64_t SectionAddr;
    SectionAddr = Section.getAddress();

    // Make a list of all the symbols in this section.
    std::vector&lt;std::pair&lt;uint64_t, StringRef&gt; &gt; Symbols;
    for (const SymbolRef &amp;Symbol : Obj-&gt;symbols()) {
      if (Section.containsSymbol(Symbol)) {
        uint64_t Address;
        if (error(Symbol.getAddress(Address))) break;
        if (Address == UnknownAddressOrSize) continue;
        Address -= SectionAddr;

        StringRef Name;
        if (error(Symbol.getName(Name))) break;
        Symbols.push_back(std::make_pair(Address, Name));
      }
    }

    // Sort the symbols by address, just in case they didn't come in that way.
    array_pod_sort(Symbols.begin(), Symbols.end());

    // Make a list of all the relocations for this section.
    std::vector&lt;RelocationRef&gt; Rels;

    // Sort relocations by address.
    std::sort(Rels.begin(), Rels.end(), RelocAddressLess);

    StringRef SegmentName = "";
    if (const MachOObjectFile *MachO =
        dyn_cast&lt;const MachOObjectFile&gt;(Obj)) {
      DataRefImpl DR = Section.getRawDataRefImpl();
      SegmentName = MachO-&gt;getSectionFinalSegmentName(DR);
    }
    StringRef name;
    if (error(Section.getName(name))) break;
    if (name == ".plt") continue;
    outs() &lt;&lt; "/*" &lt;&lt; "Disassembly of section ";
    if (!SegmentName.empty())
      outs() &lt;&lt; SegmentName &lt;&lt; ",";
    outs() &lt;&lt; name &lt;&lt; ':' &lt;&lt; "*/";

    // If the section has no symbols just insert a dummy one and disassemble
    // the whole section.
    if (Symbols.empty())
      Symbols.push_back(std::make_pair(0, name));

    SmallString&lt;40&gt; Comments;
    raw_svector_ostream CommentStream(Comments);

    StringRef BytesStr;
    if (error(Section.getContents(BytesStr))) break;
    ArrayRef&lt;uint8_t&gt; Bytes(reinterpret_cast&lt;const uint8_t *&gt;(BytesStr.data()),
                            BytesStr.size());
    uint64_t Size;
    uint64_t Index;
    uint64_t SectSize;
    SectSize = Section.getSize();

    std::vector&lt;RelocationRef&gt;::const_iterator rel_cur = Rels.begin();
    std::vector&lt;RelocationRef&gt;::const_iterator rel_end = Rels.end();
    // Disassemble symbol by symbol.
    for (unsigned si = 0, se = Symbols.size(); si != se; ++si) {
      uint64_t Start = Symbols[si].first;
      uint64_t End;
      // The end is either the size of the section or the beginning of the next
      // symbol.
      if (si == se - 1)
        End = SectSize;
      // Make sure this symbol takes up space.
      else if (Symbols[si + 1].first != Start)
        End = Symbols[si + 1].first - 1;
      else {
        // This symbol has the same address as the next symbol. Skip it.
        fprintf(fd_so_func_offset, "%02x ", 
                (uint8_t)(Symbols[si].first &gt;&gt; 24));
        fprintf(fd_so_func_offset, "%02x ", 
                (uint8_t)((Symbols[si].first &gt;&gt; 16) &amp; 0xFF));
        fprintf(fd_so_func_offset, "%02x ", 
                (uint8_t)((Symbols[si].first &gt;&gt; 8) &amp; 0xFF));
        fprintf(fd_so_func_offset, "%02x    ", 
                (uint8_t)((Symbols[si].first) &amp; 0xFF));
        std::string str = Symbols[si].second.str();
        std::size_t idx = 0;
        std::size_t strSize = 0;
        for (idx = 0, strSize = str.size(); idx &lt; strSize; idx++) {
          fprintf(fd_so_func_offset, "%c%c ", 
                  hexdigit((str[idx] &gt;&gt; 4) &amp; 0xF, true),
                  hexdigit(str[idx] &amp; 0xF, true));
        }
        for (idx = strSize; idx &lt; 48; idx++) {
          fprintf(fd_so_func_offset, "%02x ", 0);
        }
        fprintf(fd_so_func_offset, "/* %s */\n", Symbols[si].second.begin());
        num_dyn_entry++;

        outs() &lt;&lt; '\n' &lt;&lt; "/*" &lt;&lt; Symbols[si].second &lt;&lt; ":*/\n";
        continue;
      }

      soLastPrintAddr = Symbols[si].first;
      fprintf(fd_so_func_offset, "%02x ", (uint8_t)(Symbols[si].first &gt;&gt; 24));
      fprintf(fd_so_func_offset, "%02x ", 
              (uint8_t)((Symbols[si].first &gt;&gt; 16) &amp; 0xFF));
      fprintf(fd_so_func_offset, "%02x ", 
              (uint8_t)((Symbols[si].first &gt;&gt; 8) &amp; 0xFF));
      fprintf(fd_so_func_offset, "%02x    ", 
              (uint8_t)((Symbols[si].first) &amp; 0xFF));
      std::string str = Symbols[si].second.str();
      std::size_t idx = 0;
      std::size_t strSize = 0;
      for (idx = 0, strSize = str.size(); idx &lt; strSize; idx++) {
        fprintf(fd_so_func_offset, "%c%c ", 
                hexdigit((str[idx] &gt;&gt; 4) &amp; 0xF, true), 
                hexdigit(str[idx] &amp; 0xF, true));
      }
      for (idx = strSize; idx &lt; 48; idx++) {
        fprintf(fd_so_func_offset, "%02x ", 0);
      }
      fprintf(fd_so_func_offset, "/* %s */\n", Symbols[si].second.begin());
      num_dyn_entry++;

      outs() &lt;&lt; '\n' &lt;&lt; "/*" &lt;&lt; Symbols[si].second &lt;&lt; ":*/\n";
#ifndef NDEBUG
        raw_ostream &amp;DebugOut = DebugFlag ? dbgs() : nulls();
#else
        raw_ostream &amp;DebugOut = nulls();
#endif

      for (Index = Start; Index &lt; End; Index += Size) {
        MCInst Inst;
        if (DisAsm-&gt;getInstruction(Inst, Size, Bytes.slice(Index),
                                   SectionAddr + Index, DebugOut,
                                   CommentStream)) {
          outs() &lt;&lt; format("/*%8" PRIx64 ":*/", lastDumpAddr + Index);
          if (!NoShowRawInsn) {
            outs() &lt;&lt; "\t";
            DumpBytes(StringRef(
                reinterpret_cast&lt;const char *&gt;(Bytes.data()) + Index, Size));
          }
          outs() &lt;&lt; "/*";
          IP-&gt;printInst(&amp;Inst, outs(), "");
          outs() &lt;&lt; CommentStream.str();
          outs() &lt;&lt; "*/";
          Comments.clear();
          outs() &lt;&lt; "\n";
        } else {
          errs() &lt;&lt; ToolName &lt;&lt; ": warning: invalid instruction encoding\n";
          if (Size == 0)
            Size = 1; // skip illegible bytes
        }

        //  outs() &lt;&lt; "Size = " &lt;&lt; Size &lt;&lt;  "Index = " &lt;&lt; Index &lt;&lt; "lastDumpAddr = "
        //         &lt;&lt; lastDumpAddr &lt;&lt; "\n"; // debug
        // Print relocation for instruction.
        while (rel_cur != rel_end) {
          bool hidden = false;
          uint64_t addr;
          SmallString&lt;16&gt; name;
          SmallString&lt;32&gt; val;

          // If this relocation is hidden, skip it.
          if (error(rel_cur-&gt;getHidden(hidden))) goto skip_print_rel;
          if (hidden) goto skip_print_rel;

          if (error(rel_cur-&gt;getOffset(addr))) goto skip_print_rel;
          // Stop when rel_cur's address is past the current instruction.
          if (addr &gt;= Index + Size) break;
          if (error(rel_cur-&gt;getTypeName(name))) goto skip_print_rel;
          if (error(rel_cur-&gt;getValueString(val))) goto skip_print_rel;

          outs() &lt;&lt; format("\t\t\t/*%8" PRIx64 ": ", SectionAddr + addr) &lt;&lt; name
                 &lt;&lt; "\t" &lt;&lt; val &lt;&lt; "*/\n";

        skip_print_rel:
          ++rel_cur;
        }
        lastDumpAddr += Index;
      }
      soLastPrintAddr = End;
    #ifdef ELF2HEX_DEBUG
      errs() &lt;&lt; format("SectionAddr + Index = %8" PRIx64 "\n", SectionAddr + Index);
      errs() &lt;&lt; format("lastDumpAddr %8" PRIx64 "\n", lastDumpAddr);
    #endif
    }
  }
// Dump share obj or lib
// Fix the issue that __tls_get_addr appear as file offset 0.
// Old lld version the __tls_get_addr appear at the last function name.
  std::pair&lt;uint64_t, StringRef&gt; dummy(soLastPrintAddr, "dummy");
  fprintf(fd_so_func_offset, "%02x ", (uint8_t)(dummy.first &gt;&gt; 24));
  fprintf(fd_so_func_offset, "%02x ", (uint8_t)((dummy.first &gt;&gt; 16) &amp; 0xFF));
  fprintf(fd_so_func_offset, "%02x ", (uint8_t)((dummy.first &gt;&gt; 8) &amp; 0xFF));
  fprintf(fd_so_func_offset, "%02x    ", (uint8_t)((dummy.first) &amp; 0xFF));
  std::string str = dummy.second.str();
  std::size_t idx = 0;
  std::size_t strSize = 0;
  for (idx = 0, strSize = str.size(); idx &lt; strSize; idx++) {
    fprintf(fd_so_func_offset, "%c%c ", hexdigit((str[idx] &gt;&gt; 4) &amp; 0xF, true)
            , hexdigit(str[idx] &amp; 0xF, true));
  }
  for (idx = strSize; idx &lt; 48; idx++) {
    fprintf(fd_so_func_offset, "%02x ", 0);
  }
  fprintf(fd_so_func_offset, "/* %s */\n", dummy.second.begin());
  num_dyn_entry++;
  outs() &lt;&lt; '\n' &lt;&lt; "/*" &lt;&lt; dummy.second &lt;&lt; ":*/\n";
  FILE *fd_num_dyn_entry;
  fd_num_dyn_entry = fopen("dlconfig/num_dyn_entry", "w");
  if (fd_num_dyn_entry != NULL) {
    fprintf(fd_num_dyn_entry, "%d\n", num_dyn_entry);
  }
  fclose(fd_num_dyn_entry);
}

static void PrintSoDataSections(const ObjectFile *o, uint64_t&amp; lastDumpAddr, 
                                bool isLittleEndian) {
  std::error_code ec;

  for (const SectionRef &amp;Section : o-&gt;sections()) {
    if (error(ec)) return;
    StringRef Name;
    StringRef Contents;
    uint64_t BaseAddr;
    bool BSS;
    if (error(Section.getName(Name))) continue;
    if (error(Section.getContents(Contents))) continue;
    BaseAddr = Section.getAddress();
    BSS = Section.isBSS();
    if (Name == ".dynsym") {
      int num_dyn_entry = 0;
      FILE *fd_num_dyn_entry;
      fd_num_dyn_entry = fopen("dlconfig/num_dyn_entry", "r");
      if (fd_num_dyn_entry != NULL) {
        fscanf(fd_num_dyn_entry, "%d", &amp;num_dyn_entry);
      }
      fclose(fd_num_dyn_entry);
      raw_fd_ostream fd_dynsym("dlconfig/dynsym", ec, sys::fs::F_Text);
      int count = 0;
      for (std::size_t addr = 0, end = Contents.size(); addr &lt; end; addr += 16) {
        if (isLittleEndian) {
          fd_dynsym &lt;&lt; hexdigit((Contents[addr+3] &gt;&gt; 4) &amp; 0xF, true)
                     &lt;&lt; hexdigit(Contents[addr+3] &amp; 0xF, true) &lt;&lt; " ";
          fd_dynsym &lt;&lt; hexdigit((Contents[addr+2] &gt;&gt; 4) &amp; 0xF, true)
                     &lt;&lt; hexdigit(Contents[addr+2] &amp; 0xF, true) &lt;&lt; " ";
          fd_dynsym &lt;&lt; hexdigit((Contents[addr+1] &gt;&gt; 4) &amp; 0xF, true)
                     &lt;&lt; hexdigit(Contents[addr+1] &amp; 0xF, true) &lt;&lt; " ";
          fd_dynsym &lt;&lt; hexdigit((Contents[addr] &gt;&gt; 4) &amp; 0xF, true)
                     &lt;&lt; hexdigit(Contents[addr] &amp; 0xF, true) &lt;&lt; " ";
        }
        else {
          fd_dynsym &lt;&lt; hexdigit((Contents[addr] &gt;&gt; 4) &amp; 0xF, true)
                     &lt;&lt; hexdigit(Contents[addr] &amp; 0xF, true) &lt;&lt; " ";
          fd_dynsym &lt;&lt; hexdigit((Contents[addr+1] &gt;&gt; 4) &amp; 0xF, true)
                     &lt;&lt; hexdigit(Contents[addr+1] &amp; 0xF, true) &lt;&lt; " ";
          fd_dynsym &lt;&lt; hexdigit((Contents[addr+2] &gt;&gt; 4) &amp; 0xF, true)
                     &lt;&lt; hexdigit(Contents[addr+2] &amp; 0xF, true) &lt;&lt; " ";
          fd_dynsym &lt;&lt; hexdigit((Contents[addr+3] &gt;&gt; 4) &amp; 0xF, true)
                     &lt;&lt; hexdigit(Contents[addr+3] &amp; 0xF, true) &lt;&lt; " ";
        }
        count++;
      }
      for (int i = count; i &lt; num_dyn_entry; i++) {
        fd_dynsym &lt;&lt; "00 00 00 00 ";
      }
    }
    else if (Name == ".dynstr") {
      raw_fd_ostream fd_dynstr("dlconfig/dynstr", ec, sys::fs::F_Text);
      raw_fd_ostream fd_dynstrAscii("dlconfig/dynstrAscii", ec, 
                                    sys::fs::F_Text);
      for (std::size_t addr = 0, end = Contents.size(); addr &lt; end; addr++) {
        fd_dynstr &lt;&lt; hexdigit((Contents[addr] &gt;&gt; 4) &amp; 0xF, true)
                   &lt;&lt; hexdigit(Contents[addr] &amp; 0xF, true) &lt;&lt; " ";
        if (addr == 0)
          continue;
        if (Contents[addr] == '\0')
          fd_dynstrAscii &lt;&lt; "\n";
        else
          fd_dynstrAscii &lt;&lt; Contents[addr];
      }
    }
  }
}

#endif // DLINK
</pre>
</div>
<p class="rubric">exlbt/llvm-objdump/elf2hex.h</p>
<div class="highlight-c++"><pre>//===---------------------------- elf2hex.cpp -----------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This program is a utility that works with llvm-objdump.
//
//===----------------------------------------------------------------------===//

#include &lt;stdio.h&gt;
#include "llvm/Support/raw_ostream.h"
#define DLINK
//#define ELF2HEX_DEBUG

static cl::opt&lt;bool&gt;
ConvertElf2Hex("elf2hex", 
cl::desc("Display the hex content of verilog cpu0 needed sections"));

static cl::opt&lt;bool&gt;
LittleEndian("le", 
cl::desc("Little endian format"));

#ifdef DLINK
  static cl::opt&lt;bool&gt;
  DumpSo("cpu0dumpso", 
  cl::desc("Dump shared library .so"));
  
  static cl::opt&lt;bool&gt;
  LinkSo("cpu0linkso", 
  cl::desc("Link shared library .so"));
  
  #include "elf2hex-dlinker.h"
#endif

// Modified from PrintSectionHeaders()
static uint64_t GetSectionHeaderStartAddress(const ObjectFile *Obj, 
  StringRef sectionName) {
//  outs() &lt;&lt; "Sections:\n"
//            "Idx Name          Size      Address          Type\n";
  std::error_code ec;
  unsigned i = 0;
  for (const SectionRef &amp;Section : Obj-&gt;sections()) {
    if (error(ec)) return 0;
    StringRef Name;
    if (error(Section.getName(Name))) return 0;
    uint64_t Address;
    Address = Section.getAddress();
    uint64_t Size;
    Size = Section.getSize();
    bool Text;
    Text = Section.isText();
    if (Name == sectionName)
      return Address;
    else
      return 0;
    ++i;
  }
  return 0;
}

// Fill /*address*/ 00 00 00 00 [startAddr..endAddr] from startAddr to endAddr. 
// Include startAddr and endAddr.
static void Fill0s(uint64_t startAddr, uint64_t endAddr) {
  std::size_t addr;

  assert((startAddr &lt;= endAddr) &amp;&amp; "startAddr must &lt;= BaseAddr");
  // Fill /*address*/ bytes is odd for 4 by 00 
  outs() &lt;&lt; format("/*%8" PRIx64 " */", startAddr);
  // Fill /*address*/ 00 00 00 00 for 4 bytes alignment (1 Cpu0 word size)
  for (addr = startAddr; addr &lt; endAddr; addr += 4) {
    outs() &lt;&lt; format("/*%8" PRIx64 " */", addr);
    outs() &lt;&lt; format("%02" PRIx64 " ", 0) &lt;&lt; format("%02" PRIx64 " ", 0) \
    &lt;&lt; format("%02" PRIx64 " ", 0) &lt;&lt; format("%02" PRIx64 " ", 0) &lt;&lt; '\n';
  }

  return;
}

static void PrintDataSection(const ObjectFile *o, uint64_t&amp; lastDumpAddr, 
  SectionRef Section) {
  std::string Error;
  StringRef Name;
  StringRef Contents;
  uint64_t BaseAddr;
  bool BSS;
  uint64_t size;
  if (error(Section.getName(Name))) return;
  if (error(Section.getContents(Contents))) return;
  BaseAddr = Section.getAddress();
  BSS = Section.isBSS();

  size = (Contents.size()+3)/4*4;
  if (Contents.size() &lt;= 0) {
    return;
  }

  outs() &lt;&lt; "/*Contents of section " &lt;&lt; Name &lt;&lt; ":*/\n";
  // Dump out the content as hex and printable ascii characters.
  for (std::size_t addr = 0, end = Contents.size(); addr &lt; end; addr += 16) {
    outs() &lt;&lt; format("/*%8" PRIx64 " */", BaseAddr + addr);
    // Dump line of hex.
    for (std::size_t i = 0; i &lt; 16; ++i) {
      if (i != 0 &amp;&amp; i % 4 == 0)
        outs() &lt;&lt; ' ';
      if (addr + i &lt; end)
        outs() &lt;&lt; hexdigit((Contents[addr + i] &gt;&gt; 4) &amp; 0xF, true)
               &lt;&lt; hexdigit(Contents[addr + i] &amp; 0xF, true) &lt;&lt; " ";
    }
    // Print ascii.
    outs() &lt;&lt; "/*" &lt;&lt; "  ";
    for (std::size_t i = 0; i &lt; 16 &amp;&amp; addr + i &lt; end; ++i) {
      if (std::isprint(static_cast&lt;unsigned char&gt;(Contents[addr + i]) &amp; 0xFF))
        outs() &lt;&lt; Contents[addr + i];
      else
        outs() &lt;&lt; ".";
    }
    outs() &lt;&lt; "*/" &lt;&lt; "\n";
  }
  for (std::size_t i = Contents.size(); i &lt; size; i++) {
    outs() &lt;&lt; "00 ";
  }
  outs() &lt;&lt; "\n";
#ifdef ELF2HEX_DEBUG
  errs() &lt;&lt; "Name " &lt;&lt; Name &lt;&lt; "  BaseAddr ";
  errs() &lt;&lt; format("%8" PRIx64 " Contents.size() ", BaseAddr);
  errs() &lt;&lt; format("%8" PRIx64 " size ", Contents.size());
  errs() &lt;&lt; format("%8" PRIx64 " \n", size);
#endif
  // save the end address of this section to lastDumpAddr
  lastDumpAddr = BaseAddr + size;
}

// Modified from DisassembleObject()
static void DisassembleObjectInHexFormat(const ObjectFile *Obj
/*, bool InlineRelocs*/  , std::unique_ptr&lt;MCDisassembler&gt;&amp; DisAsm, 
  std::unique_ptr&lt;MCInstPrinter&gt;&amp; IP, uint64_t&amp; lastDumpAddr) {

#ifdef ELF2HEX_DEBUG
  errs() &lt;&lt; format("!lastDumpAddr %8" PRIx64 "\n", lastDumpAddr);
#endif
  std::error_code ec;
  for (const SectionRef &amp;Section : Obj-&gt;sections()) {
    if (error(ec)) break;
    StringRef Name;
    StringRef Contents;
    uint64_t BaseAddr;
    if (error(Section.getName(Name))) continue;
    if (error(Section.getContents(Contents))) continue;
    BaseAddr = Section.getAddress();
    if (BaseAddr &lt; 0x100)
      continue;
  #ifdef ELF2HEX_DEBUG
    errs() &lt;&lt; "Name " &lt;&lt; Name &lt;&lt; format("  BaseAddr %8" PRIx64 "\n", BaseAddr);
    errs() &lt;&lt; format("!!lastDumpAddr %8" PRIx64 "\n", lastDumpAddr);
  #endif
    bool text;
    text = Section.isText();
    if (!text) {
    #ifdef ELF2HEX_DEBUG
      errs() &lt;&lt; "!text\n";
    #endif
      if (lastDumpAddr &lt; BaseAddr) {
        Fill0s(lastDumpAddr, BaseAddr - 1);
        lastDumpAddr = BaseAddr;
      }
      if (Name == ".got.plt") {
        uint64_t BaseAddr;
        BaseAddr = Section.getAddress();
      #ifdef DLINK
        if (LinkSo) {
          raw_fd_ostream fd_global_offset("dlconfig/global_offset", ec, 
                                          sys::fs::F_Text);
          fd_global_offset &lt;&lt; format("%02" PRIx64 " ", BaseAddr &gt;&gt; 24);
          fd_global_offset &lt;&lt; format("%02" PRIx64 " ", (BaseAddr &gt;&gt; 16) &amp; 0xFF);
          fd_global_offset &lt;&lt; format("%02" PRIx64 " ", (BaseAddr &gt;&gt; 8) &amp; 0xFF);
          fd_global_offset &lt;&lt; format("%02" PRIx64 "    ", BaseAddr &amp; 0xFF);
        }
      #endif
        PrintDataSection(Obj, lastDumpAddr, Section);
      }
      else if ((Name == ".bss" || Name == ".sbss") &amp;&amp; Contents.size() &gt; 0) {
        uint64_t size = (Contents.size() + 3)/4*4;
        Fill0s(BaseAddr, BaseAddr + size - 1);
        lastDumpAddr = BaseAddr + size;
        continue;
      }
      else {
        PrintDataSection(Obj, lastDumpAddr, Section);
      }
      continue;
    }
    else {
      if (lastDumpAddr &lt; BaseAddr) {
        Fill0s(lastDumpAddr, BaseAddr - 1);
        lastDumpAddr = BaseAddr;
      }
    }
    // It's .text section
    uint64_t SectionAddr;
    SectionAddr = Section.getAddress();
    uint64_t SectSize = Section.getSize();
    if (!SectSize)
      continue;

    // Make a list of all the symbols in this section.
    std::vector&lt;std::pair&lt;uint64_t, StringRef&gt; &gt; Symbols;
    for (const SymbolRef &amp;Symbol : Obj-&gt;symbols()) {
      if (Section.containsSymbol(Symbol)) {
        uint64_t Address;
        if (error(Symbol.getAddress(Address)))
          break;
        if (Address == UnknownAddressOrSize)
          continue;
        Address -= SectionAddr;
        if (Address &gt;= SectSize)
          continue;

        StringRef Name;
        if (error(Symbol.getName(Name))) break;
        Symbols.push_back(std::make_pair(Address, Name));
      }
    }

    // Sort the symbols by address, just in case they didn't come in that way.
    array_pod_sort(Symbols.begin(), Symbols.end());
  #ifdef ELF2HEX_DEBUG
    for (unsigned si = 0, se = Symbols.size(); si != se; ++si) {
        errs() &lt;&lt; '\n' &lt;&lt; "/*" &lt;&lt; Symbols[si].first &lt;&lt; "  " &lt;&lt; Symbols[si].second &lt;&lt; ":*/\n";
    }
  #endif

    // Make a list of all the relocations for this section.
    std::vector&lt;RelocationRef&gt; Rels;

    // Sort relocations by address.
    std::sort(Rels.begin(), Rels.end(), RelocAddressLess);

    StringRef SegmentName = "";
    if (const MachOObjectFile *MachO =
        dyn_cast&lt;const MachOObjectFile&gt;(Obj)) {
      DataRefImpl DR = Section.getRawDataRefImpl();
      SegmentName = MachO-&gt;getSectionFinalSegmentName(DR);
    }
    StringRef name;
    if (error(Section.getName(name))) break;
    outs() &lt;&lt; "/*" &lt;&lt; "Disassembly of section ";
    if (!SegmentName.empty())
      outs() &lt;&lt; SegmentName &lt;&lt; ",";
    outs() &lt;&lt; name &lt;&lt; ':' &lt;&lt; "*/";

    // If the section has no symbols just insert a dummy one and disassemble
    // the whole section.
    if (Symbols.empty())
      Symbols.push_back(std::make_pair(0, name));

    SmallString&lt;40&gt; Comments;
    raw_svector_ostream CommentStream(Comments);

    StringRef BytesStr;
    if (error(Section.getContents(BytesStr))) break;
    ArrayRef&lt;uint8_t&gt; Bytes(reinterpret_cast&lt;const uint8_t *&gt;(BytesStr.data()),
                            BytesStr.size());
    uint64_t Size;
    uint64_t Index;
    SectSize = Section.getSize();

    std::vector&lt;RelocationRef&gt;::const_iterator rel_cur = Rels.begin();
    std::vector&lt;RelocationRef&gt;::const_iterator rel_end = Rels.end();
    // Disassemble symbol by symbol.
    for (unsigned si = 0, se = Symbols.size(); si != se; ++si) {
      uint64_t Start = Symbols[si].first;
      uint64_t End;
      // The end is either the size of the section or the beginning of the next
      // symbol.
      if (si == se - 1)
        End = SectSize;
      // Make sure this symbol takes up space.
      else if (Symbols[si + 1].first != Start)
        End = Symbols[si + 1].first - 1;
      else {
        outs() &lt;&lt; '\n' &lt;&lt; "/*" &lt;&lt; Symbols[si].second &lt;&lt; ":*/\n";
        continue;
      }

      outs() &lt;&lt; '\n' &lt;&lt; "/*" &lt;&lt; Symbols[si].second &lt;&lt; ":*/\n";
    #ifdef DLINK
      uint16_t funIndex = 0;
      if (LinkSo) {
      // correctDynFunIndex
        funIndex = cpu0DynFunIndex.correctDynFunIndex(Symbols[si].second.data());
      }
    #endif

#ifndef NDEBUG
        raw_ostream &amp;DebugOut = DebugFlag ? dbgs() : nulls();
#else
        raw_ostream &amp;DebugOut = nulls();
#endif

      for (Index = Start; Index &lt; End; Index += Size) {
        MCInst Inst;

    #ifdef DLINK
  #ifdef ELF2HEX_DEBUG
    errs() &lt;&lt; "funIndex: " &lt;&lt; funIndex &lt;&lt; "Index: " &lt;&lt; Index &lt;&lt; "Size: " &lt;&lt; Size &lt;&lt; "\n";
  #endif
        if (LinkSo &amp;&amp; funIndex &amp;&amp; Index == Start) {
          outs() &lt;&lt; format("/*%8" PRIx64 ":*/\t", SectionAddr + Index);
          outs() &lt;&lt; "01 6b " &lt;&lt; format("%02" PRIx64, (funIndex*4+16) &amp; 0xff00)
                  &lt;&lt; format(" %02" PRIx64, (funIndex*4+16) &amp; 0x00ff);
          outs() &lt;&lt; "                                  /* ld\t$t9, " 
                 &lt;&lt; funIndex*4+16 &lt;&lt; "($gp)\n";
        }
        else
    #endif
       {
          if (DisAsm-&gt;getInstruction(Inst, Size, Bytes.slice(Index),
                                     SectionAddr + Index, DebugOut,
                                     CommentStream)) {
            outs() &lt;&lt; format("/*%8" PRIx64 ":*/", SectionAddr + Index);
            if (!NoShowRawInsn) {
              outs() &lt;&lt; "\t";
              DumpBytes(StringRef(
                  reinterpret_cast&lt;const char *&gt;(Bytes.data()) + Index, Size));
            }
            outs() &lt;&lt; "/*";
            IP-&gt;printInst(&amp;Inst, outs(), "");
            outs() &lt;&lt; CommentStream.str();
            outs() &lt;&lt; "*/";
            Comments.clear();
            outs() &lt;&lt; "\n";
          } else {
            errs() &lt;&lt; ToolName &lt;&lt; ": warning: invalid instruction encoding\n";
            if (Size == 0)
              Size = 1; // skip illegible bytes
          }
        }

        //  outs() &lt;&lt; "Size = " &lt;&lt; Size &lt;&lt;  "Index = " &lt;&lt; Index &lt;&lt; "lastDumpAddr = "
        //         &lt;&lt; lastDumpAddr &lt;&lt; "\n"; // debug
        // Print relocation for instruction.
        while (rel_cur != rel_end) {
          bool hidden = false;
          uint64_t addr;
          SmallString&lt;16&gt; name;
          SmallString&lt;32&gt; val;

          // If this relocation is hidden, skip it.
          if (error(rel_cur-&gt;getHidden(hidden))) goto skip_print_rel;
          if (hidden) goto skip_print_rel;

          if (error(rel_cur-&gt;getOffset(addr))) goto skip_print_rel;
          // Stop when rel_cur's address is past the current instruction.
          if (addr &gt;= Index + Size) break;
          if (error(rel_cur-&gt;getTypeName(name))) goto skip_print_rel;
          if (error(rel_cur-&gt;getValueString(val))) goto skip_print_rel;

          outs() &lt;&lt; format("\t\t\t/*%8" PRIx64 ": ", SectionAddr + addr) &lt;&lt; name
                 &lt;&lt; "\t" &lt;&lt; val &lt;&lt; "*/\n";

        skip_print_rel:
          ++rel_cur;
        }
      }
    #ifdef ELF2HEX_DEBUG
      errs() &lt;&lt; format("SectionAddr + Index = %8" PRIx64 "\n", SectionAddr + Index);
      errs() &lt;&lt; format("lastDumpAddr %8" PRIx64 "\n", lastDumpAddr);
    #endif
    }
    // In section .plt or .text, the Contents.size() maybe &lt; (SectionAddr + Index)
    if (Contents.size() &lt; (SectionAddr + Index))
      lastDumpAddr = SectionAddr + Index;
    else
      lastDumpAddr = SectionAddr + Contents.size();
  }
}

static uint64_t SectionOffset(const ObjectFile *o, StringRef secName) {
  std::error_code ec;

  for (const SectionRef &amp;Section : o-&gt;sections()) {
    if (error(ec)) return 0;
    StringRef Name;
    StringRef Contents;
    uint64_t BaseAddr;
    bool BSS;
    if (error(Section.getName(Name))) return 0;
    if (error(Section.getContents(Contents))) return 0;
    BaseAddr = Section.getAddress();
    BSS = Section.isBSS();

    if (Name == secName)
      return BaseAddr;
  }
  return 0;
}

static void PrintBootSection(uint64_t pltOffset, bool isLittleEndian) {
  uint64_t offset = pltOffset - 4;
  if (isLittleEndian) {
    outs() &lt;&lt; "/*       0:*/	";
    outs() &lt;&lt; format("%02" PRIx64 " ", (offset &amp; 0xff));
    outs() &lt;&lt; format("%02" PRIx64 "", (offset &amp; 0xff00) &gt;&gt; 8);
    outs() &lt;&lt; " 00 36";
    outs() &lt;&lt; "                                  /*	jmp	0x";
    outs() &lt;&lt; format("%02" PRIx64 "%02" PRIx64 " */\n", (offset &amp; 0xff00) &gt;&gt; 8, 
                     (offset &amp; 0xff)); 
    outs() &lt;&lt;
      "/*       4:*/	04 00 00 36                                  /*	jmp	4 */\n";
    outs() &lt;&lt; "/*       8:*/	";
    outs() &lt;&lt; format("%02" PRIx64 " ", (offset &amp; 0xff));
    outs() &lt;&lt; format("%02" PRIx64 "", (offset &amp; 0xff00) &gt;&gt; 8);
    outs() &lt;&lt; " 00 36";
    outs() &lt;&lt; "                                  /*	jmp	0x";
    outs() &lt;&lt; format("%02" PRIx64 "%02" PRIx64 " */\n", (offset &amp; 0xff00) &gt;&gt; 8, 
                     (offset &amp; 0xff)); 
    outs() &lt;&lt;
      "/*       c:*/	fc ff ff 36                                  /*	jmp	-4 */\n";
  }
  else {
    outs() &lt;&lt; "/*       0:*/	36 00 ";
    outs() &lt;&lt; format("%02" PRIx64 " ", (offset &amp; 0xff00) &gt;&gt; 8);
    outs() &lt;&lt; format("%02" PRIx64 "", (offset &amp; 0xff));
    outs() &lt;&lt; "                                  /*	jmp	0x";
    outs() &lt;&lt; format("%02" PRIx64 "%02" PRIx64 " */\n", (offset &amp; 0xff00) &gt;&gt; 8, 
                     (offset &amp; 0xff)); 
    outs() &lt;&lt;
      "/*       4:*/	36 00 00 04                                  /*	jmp	4 */\n";
    outs() &lt;&lt; "/*       8:*/	36 00 ";
    outs() &lt;&lt; format("%02" PRIx64 " ", (offset &amp; 0xff00) &gt;&gt; 8);
    outs() &lt;&lt; format("%02" PRIx64 "", (offset &amp; 0xff));
    outs() &lt;&lt; "                                  /*	jmp	0x";
    outs() &lt;&lt; format("%02" PRIx64 "%02" PRIx64 " */\n", (offset &amp; 0xff00) &gt;&gt; 8, 
                     (offset &amp; 0xff)); 
    outs() &lt;&lt;
      "/*       c:*/	36 ff ff fc                                  /*	jmp	-4 */\n";
  }
}

#if 0
// Create by ref PrintSymbolTable()
static void FillJTI(const ObjectFile *o) {
  for (const SymbolRef &amp;Symbol : o-&gt;symbols()) {
    StringRef JTIBlockName;
    uint64_t BBAddr[0x10000];
    StringRef Name;
    uint64_t Address;
    SymbolRef::Type Type;
    uint64_t Size;
    uint32_t Flags = Symbol.getFlags();
    section_iterator Section = o-&gt;section_end();
    if (error(Section-&gt;getName(SectionName)))
      SectionName = "";
    if (SectionName != ".rodata") continue;
    if (error(Symbol.getName(Name)))
      continue;
  // For example: Name=JTI8_0 =&gt; JTIBlockName=BB8 (rule hit until _)
    if (strncmp(Name.c_str(), "JTI", strlen("JTI") == 0) {
      int i = 0;
      for (i = strlen("JTI"); Name[i] != '_'; i++);
      if (i &gt; strlen("JTI")) 
        JTIBlockName = "BB" + Name.substr(strlen("JTI"), i-strlen("JTI"));
    }
  // Then get all BB8_* address.
    Address = Section.getAddress();
    if (error(Symbol.getSection(Section)))
      continue;
    if (Section != ".text")
      continue;
}
#endif

static void Elf2Hex(const ObjectFile *o) {
  uint64_t lastDumpAddr = 0;

  const Target *TheTarget = getTarget(o);
  // getTarget() will have already issued a diagnostic if necessary, so
  // just bail here if it failed.
  if (!TheTarget)
    return;

  // Package up features to be passed to target/subtarget
  std::string FeaturesStr;
  if (MAttrs.size()) {
    SubtargetFeatures Features;
    for (unsigned i = 0; i != MAttrs.size(); ++i)
      Features.AddFeature(MAttrs[i]);
    FeaturesStr = Features.getString();
  }

  std::unique_ptr&lt;const MCRegisterInfo&gt; MRI(TheTarget-&gt;createMCRegInfo(TripleName));
  if (!MRI) {
    errs() &lt;&lt; "error: no register info for target " &lt;&lt; TripleName &lt;&lt; "\n";
    return;
  }

  // Set up disassembler.
  std::unique_ptr&lt;const MCAsmInfo&gt; AsmInfo(
    TheTarget-&gt;createMCAsmInfo(*MRI, TripleName));
  if (!AsmInfo) {
    errs() &lt;&lt; "error: no assembly info for target " &lt;&lt; TripleName &lt;&lt; "\n";
    return;
  }

  std::unique_ptr&lt;const MCSubtargetInfo&gt; STI(
    TheTarget-&gt;createMCSubtargetInfo(TripleName, "", FeaturesStr));
  if (!STI) {
    errs() &lt;&lt; "error: no subtarget info for target " &lt;&lt; TripleName &lt;&lt; "\n";
    return;
  }

  std::unique_ptr&lt;const MCInstrInfo&gt; MII(TheTarget-&gt;createMCInstrInfo());
  if (!MII) {
    errs() &lt;&lt; "error: no instruction info for target " &lt;&lt; TripleName &lt;&lt; "\n";
    return;
  }

  std::unique_ptr&lt;const MCObjectFileInfo&gt; MOFI(new MCObjectFileInfo);
  MCContext Ctx(AsmInfo.get(), MRI.get(), MOFI.get());

  std::unique_ptr&lt;MCDisassembler&gt; DisAsm(
    TheTarget-&gt;createMCDisassembler(*STI, Ctx));
  if (!DisAsm) {
    errs() &lt;&lt; "error: no disassembler for target " &lt;&lt; TripleName &lt;&lt; "\n";
    return;
  }

  std::unique_ptr&lt;const MCInstrAnalysis&gt; MIA(
      TheTarget-&gt;createMCInstrAnalysis(MII.get()));

  int AsmPrinterVariant = AsmInfo-&gt;getAssemblerDialect();
  std::unique_ptr&lt;MCInstPrinter&gt; IP(TheTarget-&gt;createMCInstPrinter(
      AsmPrinterVariant, *AsmInfo, *MII, *MRI, *STI));
  if (!IP) {
    errs() &lt;&lt; "error: no instruction printer for target " &lt;&lt; TripleName
      &lt;&lt; '\n';
    return;
  }

  uint64_t startAddr = GetSectionHeaderStartAddress(o, "_start");
//  outs() &lt;&lt; format("_start address:%08" PRIx64 "\n", startAddr);
#ifdef DLINK
  if (DumpSo) {
    DisassembleSoInHexFormat(o, DisAsm, IP, lastDumpAddr);
    PrintSoDataSections(o, lastDumpAddr, LittleEndian);
  }
  else
#endif
  {
    std::error_code EC;
    uint64_t pltOffset = SectionOffset(o, ".plt");
    PrintBootSection(pltOffset, LittleEndian);
  #ifdef DLINK
    if (LinkSo) {
      cpu0DynFunIndex.createPltName(o);
      cpu0DynFunIndex.createStrtab();
      raw_fd_ostream fd_plt_offset("dlconfig/plt_offset", EC, 
                                    sys::fs::F_Text);
      fd_plt_offset &lt;&lt; format("%08" PRIx64 " ", pltOffset);
    }
  #endif
    lastDumpAddr = 16;
    Fill0s(lastDumpAddr, 0x100);
    lastDumpAddr = 0x100;
    DisassembleObjectInHexFormat(o, DisAsm, IP, lastDumpAddr);
  }
}
</pre>
</div>
<p class="rubric">exlbt/llvm-objdump/llvm-objdump.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &quot;elf2hex.h&quot;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">DumpObject</span><span class="p">(</span><span class="k">const</span> <span class="n">ObjectFile</span> <span class="o">*</span><span class="n">o</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">ConvertElf2Hex</span><span class="p">)</span>
    <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;/*&quot;</span><span class="p">;</span>
  <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">getFileName</span><span class="p">()</span>
         <span class="o">&lt;&lt;</span> <span class="s">&quot;:</span><span class="se">\t</span><span class="s">file format &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">getFileFormatName</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">ConvertElf2Hex</span><span class="p">)</span>
    <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;*/&quot;</span><span class="p">;</span>
  <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">Disassemble</span><span class="p">)</span>
    <span class="n">DisassembleObject</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">Relocations</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Relocations</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">Disassemble</span><span class="p">)</span>
    <span class="n">PrintRelocations</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">SectionHeaders</span><span class="p">)</span>
    <span class="n">PrintSectionHeaders</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">SectionContents</span><span class="p">)</span>
    <span class="n">PrintSectionContents</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">ConvertElf2Hex</span><span class="p">)</span>
    <span class="n">Elf2Hex</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">SymbolTable</span><span class="p">)</span>
    <span class="n">PrintSymbolTable</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">UnwindInfo</span><span class="p">)</span>
    <span class="n">PrintUnwindInfo</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">PrivateHeaders</span><span class="p">)</span>
    <span class="n">printPrivateFileHeader</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">ExportsTrie</span><span class="p">)</span>
    <span class="n">printExportsTrie</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Rebase</span><span class="p">)</span>
    <span class="n">printRebaseTable</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Bind</span><span class="p">)</span>
    <span class="n">printBindTable</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">LazyBind</span><span class="p">)</span>
    <span class="n">printLazyBindTable</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">WeakBind</span><span class="p">)</span>
    <span class="n">printWeakBindTable</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Print a stack trace if we signal out.</span>
  <span class="n">sys</span><span class="o">::</span><span class="n">PrintStackTraceOnErrorSignal</span><span class="p">();</span>
  <span class="n">PrettyStackTraceProgram</span> <span class="n">X</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
  <span class="n">llvm_shutdown_obj</span> <span class="n">Y</span><span class="p">;</span>  <span class="c1">// Call llvm_shutdown() on exit.</span>

  <span class="c1">// Initialize targets and assembly printers/parsers.</span>
  <span class="n">llvm</span><span class="o">::</span><span class="n">InitializeAllTargetInfos</span><span class="p">();</span>
  <span class="n">llvm</span><span class="o">::</span><span class="n">InitializeAllTargetMCs</span><span class="p">();</span>
  <span class="n">llvm</span><span class="o">::</span><span class="n">InitializeAllAsmParsers</span><span class="p">();</span>
  <span class="n">llvm</span><span class="o">::</span><span class="n">InitializeAllDisassemblers</span><span class="p">();</span>

  <span class="c1">// Register the target printer for --version.</span>
  <span class="n">cl</span><span class="o">::</span><span class="n">AddExtraVersionPrinter</span><span class="p">(</span><span class="n">TargetRegistry</span><span class="o">::</span><span class="n">printRegisteredTargetsForVersion</span><span class="p">);</span>

  <span class="n">cl</span><span class="o">::</span><span class="n">ParseCommandLineOptions</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="s">&quot;llvm object file dumper</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">TripleName</span> <span class="o">=</span> <span class="n">Triple</span><span class="o">::</span><span class="n">normalize</span><span class="p">(</span><span class="n">TripleName</span><span class="p">);</span>

  <span class="n">ToolName</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

  <span class="c1">// Defaults to a.out if no filenames specified.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">InputFilenames</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">InputFilenames</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">&quot;a.out&quot;</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Disassemble</span>
      <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">Relocations</span>
      <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">SectionHeaders</span>
      <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">SectionContents</span>
      <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ConvertElf2Hex</span>
      <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">SymbolTable</span>
      <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">UnwindInfo</span>
      <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">PrivateHeaders</span>
      <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ExportsTrie</span>
      <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">Rebase</span>
      <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">Bind</span>
      <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">LazyBind</span>
      <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">WeakBind</span>
      <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">UniversalHeaders</span> <span class="o">&amp;&amp;</span> <span class="n">MachOOpt</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">cl</span><span class="o">::</span><span class="n">PrintHelpMessage</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">InputFilenames</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">InputFilenames</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
                <span class="n">DumpInput</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">ReturnValue</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The code included in &#8220;#ifdef DLINK&#8221; are for dynamic linker support.
The elf2hex.h supports both endian dump.</p>
</div>
<div class="section" id="create-cpu0-backend-under-lld">
<h2><a class="toc-backref" href="#id37">Create Cpu0 backend under LLD</a><a class="headerlink" href="#create-cpu0-backend-under-lld" title="Permalink to this headline">¶</a></h2>
<div class="section" id="setup-cpu0-backend-under-lld">
<h3><a class="toc-backref" href="#id38">Setup Cpu0 backend under lld</a><a class="headerlink" href="#setup-cpu0-backend-under-lld" title="Permalink to this headline">¶</a></h3>
<p>LLD project is underdevelopment and can be compiled only with c++11 standard
(C++2011 year announced standard).
For iMac, our software is OS X version 10.9.1 and Xcode version 5.0.2.
For old iMac software version, you can install VM (such as Virtual Box) and
build lld as Linux platform. Please download lld from llvm web <a class="footnote-reference" href="#id21" id="id3">[3]</a> and put lld
souce code on {llvm-src}/tools/lld just like we download llvm and clang as
shown in Appendex A of book &#8220;Tutorial: Creating an LLVM Backend for the Cpu0
Architecture&#8221; as follows.</p>
<div class="highlight-bash"><div class="highlight"><pre>1-160-136-173:tools Jonathan<span class="nv">$ </span><span class="nb">pwd</span>
/Users/Jonathan/llvm/test/src/tools
1-160-136-173:tools Jonathan<span class="nv">$ </span>ls
...
lld              llvm-config      llvm-extract    llvm-nm           llvm-stress   obj2yaml
</pre></div>
</div>
<p>Next, setup Cpu0 backend as follows,</p>
<div class="highlight-bash"><div class="highlight"><pre>1-160-136-173:Cpu0 Jonathan<span class="nv">$ </span><span class="nb">cd</span> ../../../tools/lld/lib/ReaderWriter/ELF/
1-160-136-173:ELF Jonathan<span class="nv">$ </span><span class="nb">pwd</span>
/Users/Jonathan/llvm/test/src/tools/lld/lib/ReaderWriter/ELF
1-160-136-173:ELF Jonathan<span class="nv">$ </span>cp -rf ~/test/lbt/exlbt/lld/* .
1-160-136-173:ELF Jonathan<span class="nv">$ </span>mv Reference.h ../../../include/lld/Core/.
</pre></div>
</div>
<p>Finally, update llvm-objdump to support converting ELF file to Hex file as
follows,</p>
<div class="highlight-bash"><div class="highlight"><pre>1-160-136-173:ELF Jonathan<span class="nv">$ </span><span class="nb">cd</span> ../../../../llvm-objdump/
1-160-136-173:llvm-objdump Jonathan<span class="nv">$ </span><span class="nb">pwd</span>
/Users/Jonathan/llvm/test/src/tools/llvm-objdump
1-160-136-173:llvm-objdump Jonathan<span class="nv">$ </span>cp -rf ~/test/lbt/exlbt/llvm-objdump/* .
</pre></div>
</div>
<p>Now, build lld with Cpu0 backend as follows,</p>
<div class="highlight-bash"><div class="highlight"><pre>1-160-136-173:cmake_debug_build Jonathan<span class="nv">$ </span>cmake -DCMAKE_CXX_COMPILER<span class="o">=</span>clang++ -
<span class="nv">DCMAKE_C_COMPILER</span><span class="o">=</span>clang -DCMAKE_CXX_FLAGS<span class="o">=</span>-std<span class="o">=</span>c++11 -DCMAKE_BUILD_TYPE<span class="o">=</span>Debug
-G <span class="s2">&quot;Xcode&quot;</span> ../src
...
-- Targeting Cpu0
...
-- Configuring <span class="k">done</span>
-- Generating <span class="k">done</span>
-- Build files have been written to: /Users/Jonathan/llvm/test/cmake_debug_build
</pre></div>
</div>
<p>If using VM (guest machine is Linux) or Linux, build as follows,</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="o">[</span>Gamma@localhost cmake_debug_build<span class="o">]</span><span class="nv">$ </span>cmake -DCMAKE_CXX_COMPILER<span class="o">=</span>g++ -
<span class="nv">DCMAKE_C_COMPILER</span><span class="o">=</span>gcc -DCMAKE_CXX_FLAGS<span class="o">=</span>-std<span class="o">=</span>c++11 -DCMAKE_BUILD_TYPE<span class="o">=</span>Debug
-G <span class="s2">&quot;Unix Makefiles&quot;</span> ../src
...
-- Targeting Cpu0
...
-- Configuring <span class="k">done</span>
-- Generating <span class="k">done</span>
-- Build files have been written to: /home/cschen/llvm/test/cmake_debug_build
</pre></div>
</div>
</div>
<div class="section" id="cpu0-backend-souce-code">
<h3><a class="toc-backref" href="#id39">Cpu0 backend souce code</a><a class="headerlink" href="#cpu0-backend-souce-code" title="Permalink to this headline">¶</a></h3>
<p>The code added on lld to support Cpu0 ELF as follows,</p>
<p class="rubric">exlbt/lld/CMakeLists.txt</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">target_link_libraries</span><span class="p">(</span><span class="n">lldELF</span>
  <span class="p">...</span>
  <span class="n">lldCpu0ELFTarget</span>
  <span class="n">lldCpu0elELFTarget</span>
  <span class="p">)</span>
</pre></div>
</div>
<p class="rubric">exlbt/lld/Atoms.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">SimpleELFDefinedAtom</span> <span class="o">:</span> <span class="k">public</span> <span class="n">SimpleDefinedAtom</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="kt">void</span> <span class="n">addReferenceELF_Cpu0</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">relocType</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">off</span><span class="p">,</span> <span class="k">const</span> <span class="n">Atom</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span>
                            <span class="n">Reference</span><span class="o">::</span><span class="n">Addend</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">addReferenceELF</span><span class="p">(</span><span class="n">Reference</span><span class="o">::</span><span class="n">KindArch</span><span class="o">::</span><span class="n">Cpu0</span><span class="p">,</span> <span class="n">relocType</span><span class="p">,</span> <span class="n">off</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">exlbt/lld/ELFFile.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ELFT</span><span class="o">&gt;</span> <span class="n">Reference</span><span class="o">::</span><span class="n">KindArch</span> <span class="n">ELFFile</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;::</span><span class="n">kindArch</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">_objFile</span><span class="o">-&gt;</span><span class="n">getHeader</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">e_machine</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="k">case</span> <span class="n">llvm</span>:<span class="o">:</span><span class="n">ELF</span><span class="o">::</span><span class="n">EM_CPU0</span><span class="o">:</span>
    <span class="k">return</span> <span class="n">Reference</span><span class="o">::</span><span class="n">KindArch</span><span class="o">::</span><span class="n">Cpu0</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">llvm</span>:<span class="o">:</span><span class="n">ELF</span><span class="o">::</span><span class="n">EM_CPU0_LE</span><span class="o">:</span>
    <span class="k">return</span> <span class="n">Reference</span><span class="o">::</span><span class="n">KindArch</span><span class="o">::</span><span class="n">Cpu0el</span><span class="p">;</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">exlbt/lld/ELFLinkingContext.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">uint16_t</span> <span class="n">ELFLinkingContext</span><span class="o">::</span><span class="n">getOutputMachine</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">getTriple</span><span class="p">().</span><span class="n">getArch</span><span class="p">())</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="k">case</span> <span class="n">llvm</span>:<span class="o">:</span><span class="n">Triple</span><span class="o">::</span><span class="n">cpu0</span><span class="o">:</span>
    <span class="k">return</span> <span class="n">llvm</span><span class="o">::</span><span class="n">ELF</span><span class="o">::</span><span class="n">EM_CPU0</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">llvm</span>:<span class="o">:</span><span class="n">Triple</span><span class="o">::</span><span class="n">cpu0el</span><span class="o">:</span>
    <span class="k">return</span> <span class="n">llvm</span><span class="o">::</span><span class="n">ELF</span><span class="o">::</span><span class="n">EM_CPU0_LE</span><span class="p">;</span>
  <span class="p">...</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ELFLinkingContext</span><span class="o">&gt;</span>
<span class="n">ELFLinkingContext</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">Triple</span> <span class="n">triple</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">triple</span><span class="p">.</span><span class="n">getArch</span><span class="p">())</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="k">case</span> <span class="n">llvm</span>:<span class="o">:</span><span class="n">Triple</span><span class="o">::</span><span class="n">cpu0</span><span class="o">:</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ELFLinkingContext</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="k">new</span> <span class="n">lld</span><span class="o">::</span><span class="n">elf</span><span class="o">::</span><span class="n">Cpu0LinkingContext</span><span class="p">(</span><span class="n">triple</span><span class="p">));</span>
  <span class="k">case</span> <span class="n">llvm</span>:<span class="o">:</span><span class="n">Triple</span><span class="o">::</span><span class="n">cpu0el</span><span class="o">:</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ELFLinkingContext</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="k">new</span> <span class="n">lld</span><span class="o">::</span><span class="n">elf</span><span class="o">::</span><span class="n">Cpu0elLinkingContext</span><span class="p">(</span><span class="n">triple</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">exlbt/lld/Targets.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &quot;Cpu0/Cpu0Target.h&quot;</span>
<span class="cp">#include &quot;Cpu0el/Cpu0Target.h&quot;</span>
</pre></div>
</div>
<p class="rubric">exlbt/lld/Reference.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">enum</span> <span class="k">class</span> <span class="nc">KindArch</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="n">Cpu0</span>    <span class="o">=</span> <span class="mi">98</span><span class="p">,</span>
  <span class="n">Cpu0el</span>  <span class="o">=</span> <span class="mi">99</span>
<span class="p">};</span>
</pre></div>
</div>
<p class="rubric">exlbt/lld/Cpu0/CMakeLists.txt</p>
<div class="highlight-c++"><pre>add_lld_library(lldCpu0ELFTarget
  Cpu0LinkingContext.cpp
  Cpu0TargetHandler.cpp
  Cpu0RelocationHandler.cpp
  Cpu0RelocationPass.cpp
  )

target_link_libraries(lldCpu0ELFTarget ${cmake_2_8_12_INTERFACE}
  lldCore
  )
</pre>
</div>
<p class="rubric">exlbt/lld/Cpu0/Cpu0DynamicLibraryWriter.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===- lib/ReaderWriter/ELF/Cpu0/Cpu0DynamicLibraryWriter.h ---------------===//</span>
<span class="c1">//</span>
<span class="c1">//                             The LLVM Linker</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="cp">#ifndef Cpu0_DYNAMIC_LIBRARY_WRITER_H</span>
<span class="cp">#define Cpu0_DYNAMIC_LIBRARY_WRITER_H</span>

<span class="cp">#include &quot;DynamicLibraryWriter.h&quot;</span>
<span class="cp">#include &quot;Cpu0LinkingContext.h&quot;</span>

<span class="k">namespace</span> <span class="n">lld</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">elf</span> <span class="p">{</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ELFT</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Cpu0DynamicLibraryWriter</span> <span class="o">:</span> <span class="k">public</span> <span class="n">DynamicLibraryWriter</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Cpu0DynamicLibraryWriter</span><span class="p">(</span><span class="n">Cpu0LinkingContext</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">,</span>
                             <span class="n">Cpu0TargetLayout</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">layout</span><span class="p">);</span>

<span class="nl">protected:</span>
  <span class="c1">// Add any runtime files and their atoms to the output</span>
  <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">createImplicitFiles</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">File</span><span class="o">&gt;&gt;</span> <span class="o">&amp;</span><span class="p">);</span>

  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">finalizeDefaultAtomValues</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">DynamicLibraryWriter</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;::</span><span class="n">finalizeDefaultAtomValues</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">addDefaultAtoms</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">DynamicLibraryWriter</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;::</span><span class="n">addDefaultAtoms</span><span class="p">();</span>
  <span class="p">}</span>

<span class="nl">private:</span>
  <span class="k">class</span> <span class="nc">GOTFile</span> <span class="o">:</span> <span class="k">public</span> <span class="n">SimpleFile</span> <span class="p">{</span>
  <span class="nl">public:</span>
    <span class="n">GOTFile</span><span class="p">(</span><span class="k">const</span> <span class="n">ELFLinkingContext</span> <span class="o">&amp;</span><span class="n">eti</span><span class="p">)</span> <span class="o">:</span> <span class="n">SimpleFile</span><span class="p">(</span><span class="s">&quot;GOTFile&quot;</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">llvm</span><span class="o">::</span><span class="n">BumpPtrAllocator</span> <span class="n">_alloc</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">GOTFile</span><span class="o">&gt;</span> <span class="n">_gotFile</span><span class="p">;</span>
  <span class="n">Cpu0LinkingContext</span> <span class="o">&amp;</span><span class="n">_context</span><span class="p">;</span>
  <span class="n">Cpu0TargetLayout</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">_cpu0Layout</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ELFT</span><span class="o">&gt;</span>
<span class="n">Cpu0DynamicLibraryWriter</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;::</span><span class="n">Cpu0DynamicLibraryWriter</span><span class="p">(</span>
    <span class="n">Cpu0LinkingContext</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">,</span> <span class="n">Cpu0TargetLayout</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">layout</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">DynamicLibraryWriter</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">layout</span><span class="p">),</span>
      <span class="n">_gotFile</span><span class="p">(</span><span class="k">new</span> <span class="n">GOTFile</span><span class="p">(</span><span class="n">context</span><span class="p">)),</span> <span class="n">_context</span><span class="p">(</span><span class="n">context</span><span class="p">),</span> <span class="n">_cpu0Layout</span><span class="p">(</span><span class="n">layout</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ELFT</span><span class="o">&gt;</span>
<span class="kt">bool</span> <span class="n">Cpu0DynamicLibraryWriter</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;::</span><span class="n">createImplicitFiles</span><span class="p">(</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">File</span><span class="o">&gt;&gt;</span> <span class="o">&amp;</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">DynamicLibraryWriter</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;::</span><span class="n">createImplicitFiles</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
  <span class="n">_gotFile</span><span class="o">-&gt;</span><span class="n">addAtom</span><span class="p">(</span><span class="o">*</span><span class="k">new</span> <span class="p">(</span><span class="n">_gotFile</span><span class="o">-&gt;</span><span class="n">_alloc</span><span class="p">)</span> <span class="n">GLOBAL_OFFSET_TABLEAtom</span><span class="p">(</span><span class="o">*</span><span class="n">_gotFile</span><span class="p">));</span>
  <span class="n">_gotFile</span><span class="o">-&gt;</span><span class="n">addAtom</span><span class="p">(</span><span class="o">*</span><span class="k">new</span> <span class="p">(</span><span class="n">_gotFile</span><span class="o">-&gt;</span><span class="n">_alloc</span><span class="p">)</span> <span class="n">DYNAMICAtom</span><span class="p">(</span><span class="o">*</span><span class="n">_gotFile</span><span class="p">));</span>
  <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">_gotFile</span><span class="p">));</span>
  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">}</span> <span class="c1">// namespace elf</span>
<span class="p">}</span> <span class="c1">// namespace lld</span>

<span class="cp">#endif</span>
</pre></div>
</div>
<p class="rubric">exlbt/lld/Cpu0/Cpu0ExecutableWriter.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===- lib/ReaderWriter/ELF/Cpu0/Cpu0ExecutableWriter.h ------------------===//</span>
<span class="c1">//</span>
<span class="c1">//                             The LLVM Linker</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="cp">#ifndef Cpu0_EXECUTABLE_WRITER_H</span>
<span class="cp">#define Cpu0_EXECUTABLE_WRITER_H</span>

<span class="cp">#include &quot;ExecutableWriter.h&quot;</span>
<span class="cp">#include &quot;Cpu0LinkingContext.h&quot;</span>

<span class="k">namespace</span> <span class="n">lld</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">elf</span> <span class="p">{</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ELFT</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Cpu0ExecutableWriter</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ExecutableWriter</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Cpu0ExecutableWriter</span><span class="p">(</span><span class="n">Cpu0LinkingContext</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">,</span>
                         <span class="n">Cpu0TargetLayout</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">layout</span><span class="p">);</span>

<span class="nl">protected:</span>
  <span class="c1">// Add any runtime files and their atoms to the output</span>
  <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">createImplicitFiles</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">File</span><span class="o">&gt;&gt;</span> <span class="o">&amp;</span><span class="p">);</span>

  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">finalizeDefaultAtomValues</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">ExecutableWriter</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;::</span><span class="n">finalizeDefaultAtomValues</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">addDefaultAtoms</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">ExecutableWriter</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;::</span><span class="n">addDefaultAtoms</span><span class="p">();</span>
  <span class="p">}</span>

<span class="nl">private:</span>
  <span class="k">class</span> <span class="nc">GOTFile</span> <span class="o">:</span> <span class="k">public</span> <span class="n">SimpleFile</span> <span class="p">{</span>
  <span class="nl">public:</span>
    <span class="n">GOTFile</span><span class="p">(</span><span class="k">const</span> <span class="n">ELFLinkingContext</span> <span class="o">&amp;</span><span class="n">eti</span><span class="p">)</span> <span class="o">:</span> <span class="n">SimpleFile</span><span class="p">(</span><span class="s">&quot;GOTFile&quot;</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">llvm</span><span class="o">::</span><span class="n">BumpPtrAllocator</span> <span class="n">_alloc</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">GOTFile</span><span class="o">&gt;</span> <span class="n">_gotFile</span><span class="p">;</span>
  <span class="n">Cpu0LinkingContext</span> <span class="o">&amp;</span><span class="n">_context</span><span class="p">;</span>
  <span class="n">Cpu0TargetLayout</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">_cpu0Layout</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ELFT</span><span class="o">&gt;</span>
<span class="n">Cpu0ExecutableWriter</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;::</span><span class="n">Cpu0ExecutableWriter</span><span class="p">(</span>
    <span class="n">Cpu0LinkingContext</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">,</span> <span class="n">Cpu0TargetLayout</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">layout</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">ExecutableWriter</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">layout</span><span class="p">),</span> <span class="n">_gotFile</span><span class="p">(</span><span class="k">new</span> <span class="n">GOTFile</span><span class="p">(</span><span class="n">context</span><span class="p">)),</span>
      <span class="n">_context</span><span class="p">(</span><span class="n">context</span><span class="p">),</span> <span class="n">_cpu0Layout</span><span class="p">(</span><span class="n">layout</span><span class="p">)</span> <span class="p">{}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ELFT</span><span class="o">&gt;</span>
<span class="kt">bool</span> <span class="n">Cpu0ExecutableWriter</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;::</span><span class="n">createImplicitFiles</span><span class="p">(</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">File</span><span class="o">&gt;&gt;</span> <span class="o">&amp;</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">ExecutableWriter</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;::</span><span class="n">createImplicitFiles</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
  <span class="n">_gotFile</span><span class="o">-&gt;</span><span class="n">addAtom</span><span class="p">(</span><span class="o">*</span><span class="k">new</span> <span class="p">(</span><span class="n">_gotFile</span><span class="o">-&gt;</span><span class="n">_alloc</span><span class="p">)</span> <span class="n">GLOBAL_OFFSET_TABLEAtom</span><span class="p">(</span><span class="o">*</span><span class="n">_gotFile</span><span class="p">));</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">_context</span><span class="p">.</span><span class="n">isDynamic</span><span class="p">())</span>
    <span class="n">_gotFile</span><span class="o">-&gt;</span><span class="n">addAtom</span><span class="p">(</span><span class="o">*</span><span class="k">new</span> <span class="p">(</span><span class="n">_gotFile</span><span class="o">-&gt;</span><span class="n">_alloc</span><span class="p">)</span> <span class="n">DYNAMICAtom</span><span class="p">(</span><span class="o">*</span><span class="n">_gotFile</span><span class="p">));</span>
  <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">_gotFile</span><span class="p">));</span>
  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">}</span> <span class="c1">// namespace elf</span>
<span class="p">}</span> <span class="c1">// namespace lld</span>

<span class="cp">#endif</span>
</pre></div>
</div>
<p class="rubric">exlbt/lld/Cpu0/Cpu0LinkingContext.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===- lib/ReaderWriter/ELF/Cpu0/Cpu0LinkingContext.h -----------------===//</span>
<span class="c1">//</span>
<span class="c1">//                             The LLVM Linker</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#ifndef LLD_READER_WRITER_ELF_CPU0_CPU0_LINKING_CONTEXT_H</span>
<span class="cp">#define LLD_READER_WRITER_ELF_CPU0_CPU0_LINKING_CONTEXT_H</span>

<span class="cp">#include &quot;Cpu0TargetHandler.h&quot;</span>

<span class="cp">#include &quot;lld/ReaderWriter/ELFLinkingContext.h&quot;</span>

<span class="cp">#include &quot;llvm/Object/ELF.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/ELF.h&quot;</span>

<span class="k">namespace</span> <span class="n">lld</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">elf</span> <span class="p">{</span>

<span class="c1">/// \brief Cpu0 internal references.</span>
<span class="k">enum</span> <span class="p">{</span>
  <span class="c1">/// \brief The 32 bit index of the relocation in the got this reference refers</span>
  <span class="c1">/// to.</span>
  <span class="n">LLD_R_CPU0_GOTRELINDEX</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Cpu0LinkingContext</span> <span class="n">final</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ELFLinkingContext</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Cpu0LinkingContext</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">Triple</span> <span class="n">triple</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">ELFLinkingContext</span><span class="p">(</span><span class="n">triple</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">TargetHandlerBase</span><span class="o">&gt;</span><span class="p">(</span>
                                      <span class="k">new</span> <span class="n">Cpu0TargetHandler</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">)))</span> <span class="p">{}</span>

<span class="c1">//  bool isLittleEndian() const override { return false; }</span>

  <span class="kt">void</span> <span class="n">addPasses</span><span class="p">(</span><span class="n">PassManager</span> <span class="o">&amp;</span><span class="p">)</span> <span class="n">override</span><span class="p">;</span>

  <span class="kt">uint64_t</span> <span class="n">getBaseAddress</span><span class="p">()</span> <span class="k">const</span> <span class="n">override</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_baseAddress</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
      <span class="k">return</span> <span class="mh">0x000000</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">_baseAddress</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">bool</span> <span class="n">isDynamicRelocation</span><span class="p">(</span><span class="k">const</span> <span class="n">DefinedAtom</span> <span class="o">&amp;</span><span class="p">,</span>
                           <span class="k">const</span> <span class="n">Reference</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">)</span> <span class="k">const</span> <span class="n">override</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">kindNamespace</span><span class="p">()</span> <span class="o">!=</span> <span class="n">Reference</span><span class="o">::</span><span class="n">KindNamespace</span><span class="o">::</span><span class="n">ELF</span><span class="p">)</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">kindArch</span><span class="p">()</span> <span class="o">==</span> <span class="n">Reference</span><span class="o">::</span><span class="n">KindArch</span><span class="o">::</span><span class="n">Cpu0</span><span class="p">);</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">kindValue</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">llvm</span>:<span class="o">:</span><span class="n">ELF</span><span class="o">::</span><span class="n">R_CPU0_GLOB_DAT</span><span class="o">:</span>
      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="nl">default:</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">isPLTRelocation</span><span class="p">(</span><span class="k">const</span> <span class="n">DefinedAtom</span> <span class="o">&amp;</span><span class="p">,</span>
                               <span class="k">const</span> <span class="n">Reference</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">)</span> <span class="k">const</span> <span class="n">override</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">kindNamespace</span><span class="p">()</span> <span class="o">!=</span> <span class="n">Reference</span><span class="o">::</span><span class="n">KindNamespace</span><span class="o">::</span><span class="n">ELF</span><span class="p">)</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">kindArch</span><span class="p">()</span> <span class="o">==</span> <span class="n">Reference</span><span class="o">::</span><span class="n">KindArch</span><span class="o">::</span><span class="n">Cpu0</span><span class="p">);</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">kindValue</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">llvm</span>:<span class="o">:</span><span class="n">ELF</span><span class="o">::</span><span class="n">R_CPU0_JUMP_SLOT</span><span class="o">:</span>
    <span class="k">case</span> <span class="n">llvm</span>:<span class="o">:</span><span class="n">ELF</span><span class="o">::</span><span class="n">R_CPU0_RELGOT</span><span class="o">:</span>
      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="nl">default:</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">/// \brief Cpu0 has two relative relocations</span>
  <span class="c1">/// a) for supporting relative relocs - R_CPU0_RELGOT</span>
  <span class="kt">bool</span> <span class="n">isRelativeReloc</span><span class="p">(</span><span class="k">const</span> <span class="n">Reference</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">)</span> <span class="k">const</span> <span class="n">override</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">kindNamespace</span><span class="p">()</span> <span class="o">!=</span> <span class="n">Reference</span><span class="o">::</span><span class="n">KindNamespace</span><span class="o">::</span><span class="n">ELF</span><span class="p">)</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">kindArch</span><span class="p">()</span> <span class="o">==</span> <span class="n">Reference</span><span class="o">::</span><span class="n">KindArch</span><span class="o">::</span><span class="n">Cpu0</span><span class="p">);</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">kindValue</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">llvm</span>:<span class="o">:</span><span class="n">ELF</span><span class="o">::</span><span class="n">R_CPU0_RELGOT</span><span class="o">:</span>
      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="nl">default:</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kt">bool</span> <span class="n">isStaticExecutable</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_isStaticExecutable</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// end namespace elf</span>
<span class="p">}</span> <span class="c1">// end namespace lld</span>

<span class="cp">#endif</span>
</pre></div>
</div>
<p class="rubric">exlbt/lld/Cpu0/Cpu0LinkingContext.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===- lib/ReaderWriter/ELF/Cpu0/Cpu0LinkingContext.cpp ---------------===//</span>
<span class="c1">//</span>
<span class="c1">//                             The LLVM Linker</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#include &quot;Cpu0LinkingContext.h&quot;</span>
<span class="cp">#include &quot;Cpu0RelocationPass.h&quot;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">lld</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">elf</span><span class="o">::</span><span class="n">Cpu0LinkingContext</span><span class="o">::</span><span class="n">addPasses</span><span class="p">(</span><span class="n">PassManager</span> <span class="o">&amp;</span><span class="n">pm</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">pass</span> <span class="o">=</span> <span class="n">createCpu0RelocationPass</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">pass</span><span class="p">)</span>
    <span class="n">pm</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">pass</span><span class="p">));</span>
  <span class="n">ELFLinkingContext</span><span class="o">::</span><span class="n">addPasses</span><span class="p">(</span><span class="n">pm</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">exlbt/lld/Cpu0/Cpu0RelocationHandler.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===- lib/ReaderWriter/ELF/Cpu0/Cpu0RelocationHandler.h --------------===//</span>
<span class="c1">//</span>
<span class="c1">//                             The LLVM Linker</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#ifndef CPU0_RELOCATION_HANDLER_H</span>
<span class="cp">#define CPU0_RELOCATION_HANDLER_H</span>

<span class="cp">#include &quot;Cpu0TargetHandler.h&quot;</span>

<span class="k">namespace</span> <span class="n">lld</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">elf</span> <span class="p">{</span>
<span class="k">typedef</span> <span class="n">llvm</span><span class="o">::</span><span class="n">object</span><span class="o">::</span><span class="n">ELFType</span><span class="o">&lt;</span><span class="n">llvm</span><span class="o">::</span><span class="n">support</span><span class="o">::</span><span class="n">big</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">false</span><span class="o">&gt;</span> <span class="n">Cpu0ELFType</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">Cpu0LinkingContext</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ELFT</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Cpu0TargetLayout</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Cpu0TargetRelocationHandler</span> <span class="n">final</span>
    <span class="o">:</span> <span class="k">public</span> <span class="n">TargetRelocationHandler</span><span class="o">&lt;</span><span class="n">Cpu0ELFType</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Cpu0TargetRelocationHandler</span><span class="p">(</span><span class="n">Cpu0TargetLayout</span><span class="o">&lt;</span><span class="n">Cpu0ELFType</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">layout</span><span class="p">,</span> 
                              <span class="n">Cpu0LinkingContext</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">,</span> 
                              <span class="n">ELFLinkingContext</span> <span class="o">&amp;</span><span class="n">targetInfo</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">TargetRelocationHandler</span><span class="o">&lt;</span><span class="n">Cpu0ELFType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">targetInfo</span><span class="p">),</span>
        <span class="n">_tlsSize</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">_cpu0Layout</span><span class="p">(</span><span class="n">layout</span><span class="p">),</span> 
        <span class="n">_context</span><span class="p">(</span><span class="n">context</span><span class="p">)</span> <span class="p">{}</span>

  <span class="n">std</span><span class="o">::</span><span class="n">error_code</span> <span class="n">applyRelocation</span><span class="p">(</span><span class="n">ELFWriter</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">llvm</span><span class="o">::</span><span class="n">FileOutputBuffer</span> <span class="o">&amp;</span><span class="p">,</span>
                                  <span class="k">const</span> <span class="n">lld</span><span class="o">::</span><span class="n">AtomLayout</span> <span class="o">&amp;</span><span class="p">,</span>
                                  <span class="k">const</span> <span class="n">Reference</span> <span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span> <span class="n">override</span><span class="p">;</span>

<span class="nl">private:</span>
  <span class="c1">// Cached size of the TLS segment.</span>
  <span class="k">mutable</span> <span class="kt">uint64_t</span> <span class="n">_tlsSize</span><span class="p">;</span>
  <span class="n">Cpu0TargetLayout</span><span class="o">&lt;</span><span class="n">Cpu0ELFType</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">_cpu0Layout</span><span class="p">;</span>
  <span class="n">Cpu0LinkingContext</span> <span class="o">&amp;</span><span class="n">_context</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">}</span> <span class="c1">// end namespace elf</span>
<span class="p">}</span> <span class="c1">// end namespace lld</span>

<span class="cp">#endif </span><span class="c1">// Cpu0_RELOCATION_HANDLER_H</span>
</pre></div>
</div>
<p class="rubric">exlbt/lld/Cpu0/Cpu0RelocationHandler.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===- lib/ReaderWriter/ELF/Cpu0/Cpu0RelocationHandler.cpp ------------===//</span>
<span class="c1">//</span>
<span class="c1">//                             The LLVM Linker</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#include &quot;Cpu0TargetHandler.h&quot;</span>
<span class="cp">#include &quot;Cpu0LinkingContext.h&quot;</span>
<span class="cp">#include &quot;llvm/Object/ObjectFile.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/raw_ostream.h&quot;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">lld</span><span class="p">;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">elf</span><span class="p">;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">object</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">bool</span> <span class="nf">error</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">error_code</span> <span class="n">ec</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ec</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

  <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Cpu0RelocationHandler.cpp : error reading file: &quot;</span> 
         <span class="o">&lt;&lt;</span> <span class="n">ec</span><span class="p">.</span><span class="n">message</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
  <span class="n">outs</span><span class="p">().</span><span class="n">flush</span><span class="p">();</span>
  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">namespace</span> <span class="p">{</span>
<span class="c1">/// \brief R_CPU0_HI16 - word64: (S + A) &gt;&gt; 16</span>
<span class="kt">void</span> <span class="n">relocHI16</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">location</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">P</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">S</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">A</span><span class="p">)</span> <span class="p">{</span>
 <span class="c1">// Don&#39;t know why A, ref.addend(), = 9</span>
  <span class="kt">uint32_t</span> <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)(</span><span class="n">S</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">);</span>
  <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">llvm</span><span class="o">::</span><span class="n">support</span><span class="o">::</span><span class="kt">ubig32_t</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">location</span><span class="p">)</span> <span class="o">=</span>
      <span class="n">result</span> <span class="o">|</span>
      <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="o">*</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">llvm</span><span class="o">::</span><span class="n">support</span><span class="o">::</span><span class="kt">ubig32_t</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">location</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">relocLO16</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">location</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">P</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">S</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">A</span><span class="p">)</span> <span class="p">{</span>
 <span class="c1">// Don&#39;t know why A, ref.addend(), = 9</span>
  <span class="kt">uint32_t</span> <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)(</span><span class="n">S</span> <span class="o">&amp;</span> <span class="mh">0x0000ffff</span><span class="p">);</span>
  <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">llvm</span><span class="o">::</span><span class="n">support</span><span class="o">::</span><span class="kt">ubig32_t</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">location</span><span class="p">)</span> <span class="o">=</span>
      <span class="n">result</span> <span class="o">|</span>
      <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="o">*</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">llvm</span><span class="o">::</span><span class="n">support</span><span class="o">::</span><span class="kt">ubig32_t</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">location</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">/// \brief R_CPU0_GOT16 - word32: S</span>
<span class="kt">void</span> <span class="n">relocGOT16</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">location</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">P</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">S</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">A</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">uint32_t</span> <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)(</span><span class="n">S</span><span class="p">);</span>
  <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">llvm</span><span class="o">::</span><span class="n">support</span><span class="o">::</span><span class="kt">ubig32_t</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">location</span><span class="p">)</span> <span class="o">=</span>
      <span class="n">result</span> <span class="o">|</span>
      <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="o">*</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">llvm</span><span class="o">::</span><span class="n">support</span><span class="o">::</span><span class="kt">ubig32_t</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">location</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">/// \brief R_CPU0_PC24 - word32: S + A - P</span>
<span class="kt">void</span> <span class="n">relocPC24</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">location</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">P</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">S</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">A</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">uint32_t</span> <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)(</span><span class="n">S</span>  <span class="o">-</span> <span class="n">P</span><span class="p">);</span>
  <span class="kt">uint32_t</span> <span class="n">machinecode</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="o">*</span> 
                         <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">llvm</span><span class="o">::</span><span class="n">support</span><span class="o">::</span><span class="kt">ubig32_t</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">location</span><span class="p">);</span>
  <span class="kt">uint32_t</span> <span class="n">opcode</span> <span class="o">=</span> <span class="p">(</span><span class="n">machinecode</span> <span class="o">&amp;</span> <span class="mh">0xff000000</span><span class="p">);</span>
  <span class="kt">uint32_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">machinecode</span> <span class="o">&amp;</span> <span class="mh">0x00ffffff</span><span class="p">);</span>
  <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">llvm</span><span class="o">::</span><span class="n">support</span><span class="o">::</span><span class="kt">ubig32_t</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">location</span><span class="p">)</span> <span class="o">=</span>
      <span class="p">(((</span><span class="n">result</span> <span class="o">+</span> <span class="n">offset</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x00ffffff</span><span class="p">)</span> <span class="o">|</span> <span class="n">opcode</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">/// \brief R_CPU0_32 - word32:  S</span>
<span class="kt">void</span> <span class="n">reloc32</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">location</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">P</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">S</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">A</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int32_t</span> <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)(</span><span class="n">S</span><span class="p">);</span>
  <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">llvm</span><span class="o">::</span><span class="n">support</span><span class="o">::</span><span class="kt">ubig32_t</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">location</span><span class="p">)</span> <span class="o">=</span>
      <span class="n">result</span> <span class="o">|</span>
      <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="o">*</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">llvm</span><span class="o">::</span><span class="n">support</span><span class="o">::</span><span class="kt">ubig32_t</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">location</span><span class="p">);</span>
  <span class="c1">// TODO: Make sure that the result zero extends to the 64bit value.</span>
<span class="p">}</span>
<span class="p">}</span> <span class="c1">// end anon namespace</span>

<span class="cp">#ifdef DLINKER</span>
<span class="k">class</span> <span class="nc">Cpu0SoPlt</span> <span class="p">{</span>
<span class="nl">private:</span>
  <span class="kt">uint32_t</span> <span class="n">funAddr</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
  <span class="kt">int</span> <span class="n">funAddrSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">public:</span>
  <span class="n">Cpu0TargetLayout</span><span class="o">&lt;</span><span class="n">Cpu0ELFType</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">_cpu0Layout</span><span class="p">;</span>
  <span class="kt">void</span> <span class="nf">createFunAddr</span><span class="p">(</span><span class="n">Cpu0TargetLayout</span><span class="o">&lt;</span><span class="n">Cpu0ELFType</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">cpu0Layout</span><span class="p">,</span> 
                     <span class="n">llvm</span><span class="o">::</span><span class="n">FileOutputBuffer</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">);</span>
  <span class="c1">// Return function index, 1: 1st function appear on section .text of .so.</span>
  <span class="c1">//   2: 2nd function ...</span>
  <span class="c1">// For example: 3 functions _Z2laii, _Z3fooii and _Z3barv. 1: is _Z2laii </span>
  <span class="c1">//   2 is _Z3fooii, 3: is _Z3barv.</span>
  <span class="kt">int</span> <span class="nf">getDynFunIndexByTargetAddr</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">fAddr</span><span class="p">);</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">Cpu0SoPlt</span><span class="o">::</span><span class="n">createFunAddr</span><span class="p">(</span><span class="n">Cpu0TargetLayout</span><span class="o">&lt;</span><span class="n">Cpu0ELFType</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">cpu0Layout</span><span class="p">,</span> 
                              <span class="n">llvm</span><span class="o">::</span><span class="n">FileOutputBuffer</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">dynsymSection</span> <span class="o">=</span> <span class="n">cpu0Layout</span><span class="o">-&gt;</span>
                       <span class="n">findOutputSection</span><span class="p">(</span><span class="s">&quot;.dynsym&quot;</span><span class="p">);</span>
  <span class="kt">uint64_t</span> <span class="n">dynsymFileOffset</span><span class="p">,</span> <span class="n">dynsymSize</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">dynsymSection</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">dynsymFileOffset</span> <span class="o">=</span> <span class="n">dynsymSection</span><span class="o">-&gt;</span><span class="n">fileOffset</span><span class="p">();</span>
    <span class="n">dynsymSize</span> <span class="o">=</span> <span class="n">dynsymSection</span><span class="o">-&gt;</span><span class="n">memSize</span><span class="p">();</span>
    <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">atomContent</span> <span class="o">=</span> <span class="n">buf</span><span class="p">.</span><span class="n">getBufferStart</span><span class="p">()</span> <span class="o">+</span> <span class="n">dynsymFileOffset</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">uint64_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dynsymSize</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">16</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">funAddr</span><span class="p">[</span><span class="n">funAddrSize</span><span class="p">]</span> <span class="o">=</span> 
        <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">llvm</span><span class="o">::</span><span class="n">support</span><span class="o">::</span><span class="kt">ubig32_t</span><span class="o">*&gt;</span><span class="p">((</span><span class="kt">uint32_t</span><span class="o">*</span><span class="p">)</span>
        <span class="p">(</span><span class="n">atomContent</span> <span class="o">+</span> <span class="n">i</span><span class="p">));</span>
      <span class="n">funAddrSize</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">Cpu0SoPlt</span><span class="o">::</span><span class="n">getDynFunIndexByTargetAddr</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">fAddr</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">funAddrSize</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Below statement fix the issue that both __tls_get_addr and first </span>
    <span class="c1">// function has the same file offset 0 issue.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">funAddrSize</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">funAddr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">funAddr</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
      <span class="k">continue</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">fAddr</span> <span class="o">==</span> <span class="n">funAddr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Cpu0SoPlt</span> <span class="n">cpu0SoPlt</span><span class="p">;</span>
<span class="cp">#endif </span><span class="c1">// DLINKER</span>

<span class="n">std</span><span class="o">::</span><span class="n">error_code</span> <span class="n">Cpu0TargetRelocationHandler</span><span class="o">::</span><span class="n">applyRelocation</span><span class="p">(</span>
    <span class="n">ELFWriter</span> <span class="o">&amp;</span><span class="n">writer</span><span class="p">,</span> <span class="n">llvm</span><span class="o">::</span><span class="n">FileOutputBuffer</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="n">lld</span><span class="o">::</span><span class="n">AtomLayout</span> <span class="o">&amp;</span><span class="n">atom</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">Reference</span> <span class="o">&amp;</span><span class="n">ref</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
<span class="cp">#ifdef DLINKER</span>
  <span class="k">static</span> <span class="kt">bool</span> <span class="n">firstTime</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">soName</span><span class="p">(</span><span class="s">&quot;libfoobar.cpu0.so&quot;</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">firstTime</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">_context</span><span class="p">.</span><span class="n">getOutputELFType</span><span class="p">()</span> <span class="o">==</span> <span class="n">llvm</span><span class="o">::</span><span class="n">ELF</span><span class="o">::</span><span class="n">ET_DYN</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">cpu0SoPlt</span><span class="p">.</span><span class="n">createFunAddr</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">_cpu0Layout</span><span class="p">),</span> <span class="n">buf</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">_context</span><span class="p">.</span><span class="n">getOutputELFType</span><span class="p">()</span> <span class="o">==</span> <span class="n">llvm</span><span class="o">::</span><span class="n">ELF</span><span class="o">::</span><span class="n">ET_EXEC</span> <span class="o">&amp;&amp;</span> 
             <span class="o">!</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">_context</span><span class="p">.</span><span class="n">isStaticExecutable</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">cpu0SoPlt</span><span class="p">.</span><span class="n">createFunAddr</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">_cpu0Layout</span><span class="p">),</span> <span class="n">buf</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">firstTime</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>
<span class="cp">#endif </span><span class="c1">// DLINKER</span>
  <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">atomContent</span> <span class="o">=</span> <span class="n">buf</span><span class="p">.</span><span class="n">getBufferStart</span><span class="p">()</span> <span class="o">+</span> <span class="n">atom</span><span class="p">.</span><span class="n">_fileOffset</span><span class="p">;</span>
  <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">location</span> <span class="o">=</span> <span class="n">atomContent</span> <span class="o">+</span> <span class="n">ref</span><span class="p">.</span><span class="n">offsetInAtom</span><span class="p">();</span>
  <span class="kt">uint64_t</span> <span class="n">targetVAddress</span> <span class="o">=</span> <span class="n">writer</span><span class="p">.</span><span class="n">addressOfAtom</span><span class="p">(</span><span class="n">ref</span><span class="p">.</span><span class="n">target</span><span class="p">());</span>
  <span class="kt">uint64_t</span> <span class="n">relocVAddress</span> <span class="o">=</span> <span class="n">atom</span><span class="p">.</span><span class="n">_virtualAddr</span> <span class="o">+</span> <span class="n">ref</span><span class="p">.</span><span class="n">offsetInAtom</span><span class="p">();</span>
<span class="cp">#if 1 </span><span class="c1">// For case R_CPU0_GOT16:</span>
<span class="c1">//  auto gotAtomIter = _context.getTargetHandler&lt;Cpu0ELFType&gt;().targetLayout().</span>
<span class="c1">//                     findAbsoluteAtom(&quot;_GLOBAL_OFFSET_TABLE_&quot;);</span>
<span class="c1">//  uint64_t globalOffsetTableAddress = writer.addressOfAtom(*gotAtomIter);</span>
<span class="c1">// .got.plt start from _GLOBAL_OFFSET_TABLE_</span>
  <span class="k">auto</span> <span class="n">gotpltSection</span> <span class="o">=</span> <span class="n">_cpu0Layout</span><span class="p">.</span><span class="n">findOutputSection</span><span class="p">(</span><span class="s">&quot;.got.plt&quot;</span><span class="p">);</span>
  <span class="kt">uint64_t</span> <span class="n">gotPltFileOffset</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">gotpltSection</span><span class="p">)</span>
    <span class="n">gotPltFileOffset</span> <span class="o">=</span> <span class="n">gotpltSection</span><span class="o">-&gt;</span><span class="n">fileOffset</span><span class="p">();</span>
  <span class="k">else</span>
    <span class="n">gotPltFileOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">ref</span><span class="p">.</span><span class="n">kindNamespace</span><span class="p">()</span> <span class="o">!=</span> <span class="n">Reference</span><span class="o">::</span><span class="n">KindNamespace</span><span class="o">::</span><span class="n">ELF</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">error_code</span><span class="p">();</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">ref</span><span class="p">.</span><span class="n">kindArch</span><span class="p">()</span> <span class="o">==</span> <span class="n">Reference</span><span class="o">::</span><span class="n">KindArch</span><span class="o">::</span><span class="n">Cpu0</span><span class="p">);</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">ref</span><span class="p">.</span><span class="n">kindValue</span><span class="p">())</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">R_CPU0_NONE</span>:
    <span class="k">break</span><span class="p">;</span>

  <span class="k">case</span> <span class="n">R_CPU0_HI16</span>:
    <span class="n">relocHI16</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">relocVAddress</span><span class="p">,</span> <span class="n">targetVAddress</span><span class="p">,</span> <span class="n">ref</span><span class="p">.</span><span class="n">addend</span><span class="p">());</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">R_CPU0_LO16</span>:
    <span class="n">relocLO16</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">relocVAddress</span><span class="p">,</span> <span class="n">targetVAddress</span><span class="p">,</span> <span class="n">ref</span><span class="p">.</span><span class="n">addend</span><span class="p">());</span>
    <span class="k">break</span><span class="p">;</span>
<span class="cp">#if 0</span><span class="c"> // Not support yet</span>
<span class="c">  case R_CPU0_GOT16:</span>
<span class="cp">#if 1</span>
<span class="c">    idx = cpu0SoPlt.getDynFunIndexByTargetAddr(targetVAddress);</span>
<span class="c">    relocGOT16(location, relocVAddress, idx, ref.addend());</span>
<span class="cp">#else</span>
<span class="c">    relocGOT16(location, relocVAddress, (targetVAddress - gotPltFileOffset), </span>
<span class="c">               ref.addend());</span>
<span class="cp">#endif</span>
    <span class="k">break</span><span class="p">;</span>
<span class="cp">#endif</span>
  <span class="k">case</span> <span class="n">R_CPU0_PC24</span>:
    <span class="n">relocPC24</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">relocVAddress</span><span class="p">,</span> <span class="n">targetVAddress</span><span class="p">,</span> <span class="n">ref</span><span class="p">.</span><span class="n">addend</span><span class="p">());</span>
    <span class="k">break</span><span class="p">;</span>
<span class="cp">#ifdef DLINKER</span>
  <span class="k">case</span> <span class="n">R_CPU0_CALL16</span>:
  <span class="c1">// offset at _GLOBAL_OFFSET_TABLE_ and $gp point to _GLOBAL_OFFSET_TABLE_.</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">cpu0SoPlt</span><span class="p">.</span><span class="n">getDynFunIndexByTargetAddr</span><span class="p">(</span><span class="n">targetVAddress</span><span class="p">);</span>
    <span class="n">reloc32</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">relocVAddress</span><span class="p">,</span> <span class="n">idx</span><span class="o">*</span><span class="mh">0x04</span><span class="o">+</span><span class="mi">16</span><span class="p">,</span> <span class="n">ref</span><span class="p">.</span><span class="n">addend</span><span class="p">());</span>
    <span class="k">break</span><span class="p">;</span>
<span class="cp">#endif </span><span class="c1">// DLINKER</span>
  <span class="k">case</span> <span class="n">R_CPU0_32</span>:
    <span class="n">reloc32</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">relocVAddress</span><span class="p">,</span> <span class="n">targetVAddress</span><span class="p">,</span> <span class="n">ref</span><span class="p">.</span><span class="n">addend</span><span class="p">());</span>
    <span class="k">break</span><span class="p">;</span>

  <span class="c1">// Runtime only relocations. Ignore here.</span>
  <span class="k">case</span> <span class="n">R_CPU0_JUMP_SLOT</span>:
  <span class="k">case</span> <span class="n">R_CPU0_GLOB_DAT</span>:
    <span class="k">break</span><span class="p">;</span>
  <span class="nl">default:</span>
    <span class="n">unhandledReferenceType</span><span class="p">(</span><span class="o">*</span><span class="n">atom</span><span class="p">.</span><span class="n">_atom</span><span class="p">,</span> <span class="n">ref</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">error_code</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">exlbt/lld/Cpu0/Cpu0RelocationPass.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===- lib/ReaderWriter/ELF/Cpu0/Cpu0RelocationPass.h -----------------===//</span>
<span class="c1">//</span>
<span class="c1">//                             The LLVM Linker</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">///</span>
<span class="c1">/// \file</span>
<span class="c1">/// \brief Declares the relocation processing pass for Cpu0. This includes</span>
<span class="c1">///   GOT and PLT entries, TLS, COPY, and ifunc.</span>
<span class="c1">///</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#ifndef LLD_READER_WRITER_ELF_CPU0_CPU0_RELOCATION_PASS_H</span>
<span class="cp">#define LLD_READER_WRITER_ELF_CPU0_CPU0_RELOCATION_PASS_H</span>

<span class="cp">#include &lt;memory&gt;</span>

<span class="k">namespace</span> <span class="n">lld</span> <span class="p">{</span>
<span class="k">class</span> <span class="nc">Pass</span><span class="p">;</span>
<span class="k">namespace</span> <span class="n">elf</span> <span class="p">{</span>
<span class="k">class</span> <span class="nc">Cpu0LinkingContext</span><span class="p">;</span>

<span class="c1">/// \brief Create Cpu0 relocation pass for the given linking context.</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Pass</span><span class="o">&gt;</span>
<span class="n">createCpu0RelocationPass</span><span class="p">(</span><span class="k">const</span> <span class="n">Cpu0LinkingContext</span> <span class="o">&amp;</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#endif</span>
</pre></div>
</div>
<p class="rubric">exlbt/lld/Cpu0/Cpu0RelocationPass.cpp</p>
<div class="highlight-c++"><pre>//===- lib/ReaderWriter/ELF/Cpu0/Cpu0RelocationPass.cpp ---------------===//
//
//                             The LLVM Linker
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
///
/// \file
/// \brief Defines the relocation processing pass for Cpu0. This includes
///   GOT and PLT entries, TLS, COPY, and ifunc.
///
/// This is based on section 4.4.1 of the AMD64 ABI (no stable URL as of Oct,
/// 2013).
///
/// This also includes aditional behaivor that gnu-ld and gold implement but
/// which is not specified anywhere.
///
//===----------------------------------------------------------------------===//

#include "Atoms.h"
#include "Cpu0RelocationPass.h"
#include "Cpu0LinkingContext.h"

#include "lld/Core/Simple.h"

#include "llvm/ADT/DenseMap.h"


using namespace lld;
using namespace lld::elf;
using namespace llvm::ELF;

namespace {
// .plt value (entry 0)
const uint8_t cpu0BootAtomContent[16] = {
  0x36, 0xff, 0xff, 0xfc, // jmp start
  0x36, 0x00, 0x00, 0x04, // jmp 4
  0x36, 0xff, 0xff, 0xfc, // jmp ISR
  0x36, 0xff, 0xff, 0xfc // jmp -4
};

#ifdef DLINKER
// .got values
const uint8_t cpu0GotAtomContent[16] = { 0 };

// .plt value (entry 0)
const uint8_t cpu0Plt0AtomContent[16] = {
  0x02, 0xeb, 0x00, 0x04, // st $lr, $zero, reloc-index ($gp)
  0x02, 0xcb, 0x00, 0x08, // st $fp, $zero, reloc-index ($gp)
  0x02, 0xdb, 0x00, 0x0c, // st $sp, $zero, reloc-index ($gp)
  0x36, 0xff, 0xff, 0xfc  // jmp dynamic_linker
};

// .plt values (other entries)
const uint8_t cpu0PltAtomContent[16] = {
  0x01, 0x6b, 0x00, 0x10, // ld $t9, 0x10($gp) (0x10($gp) point to plt0
  0x3c, 0x60, 0x00, 0x00, // ret $t9 // jump to Cpu0.Stub
  0x00, 0x00, 0x00, 0x00, // nop
  0x00, 0x00, 0x00, 0x00  // nop
};
#endif // DLINKER

/// boot record
class Cpu0BootAtom : public PLT0Atom {
public:
  Cpu0BootAtom(const File &amp;f) : PLT0Atom(f) {
#ifndef NDEBUG
    _name = ".PLT0";
#endif
  }
  virtual ArrayRef&lt;uint8_t&gt; rawContent() const {
    return ArrayRef&lt;uint8_t&gt;(cpu0BootAtomContent, 16);
  }
};

#ifdef DLINKER
/// \brief Atoms that are used by Cpu0 dynamic linking
class Cpu0GOTAtom : public GOTAtom {
public:
  Cpu0GOTAtom(const File &amp;f, StringRef secName) : GOTAtom(f, secName) {}

  ArrayRef&lt;uint8_t&gt; rawContent() const override {
    return ArrayRef&lt;uint8_t&gt;(cpu0GotAtomContent, 16);
  }
};

class Cpu0PLT0Atom : public PLT0Atom {
public:
  Cpu0PLT0Atom(const File &amp;f) : PLT0Atom(f) {
#ifndef NDEBUG
    _name = ".PLT0";
#endif
  }
  ArrayRef&lt;uint8_t&gt; rawContent() const override {
    return ArrayRef&lt;uint8_t&gt;(cpu0Plt0AtomContent, 16);
  }
};

class Cpu0PLTAtom : public PLTAtom {
public:
  Cpu0PLTAtom(const File &amp;f, StringRef secName) : PLTAtom(f, secName) {}

  ArrayRef&lt;uint8_t&gt; rawContent() const override {
    return ArrayRef&lt;uint8_t&gt;(cpu0PltAtomContent, 16);
  }
};
#endif // DLINKER

class ELFPassFile : public SimpleFile {
public:
  ELFPassFile(const ELFLinkingContext &amp;eti) : SimpleFile("ELFPassFile") {
    setOrdinal(eti.getNextOrdinalAndIncrement());
  }

  llvm::BumpPtrAllocator _alloc;
};

/// \brief CRTP base for handling relocations.
template &lt;class Derived&gt; class RelocationPass : public Pass {
  /// \brief Handle a specific reference.
  void handleReference(const DefinedAtom &amp;atom, const Reference &amp;ref) {
    if (ref.kindNamespace() != Reference::KindNamespace::ELF)
      return;
    assert(ref.kindArch() == Reference::KindArch::Cpu0);
    switch (ref.kindValue()) {
    case R_CPU0_CALL16:
      static_cast&lt;Derived *&gt;(this)-&gt;handlePLT32(ref);
      break;

    case R_CPU0_PC24:
      static_cast&lt;Derived *&gt;(this)-&gt;handlePlain(ref);
      break;
    }
  }

protected:
#ifdef DLINKER
  /// \brief get the PLT entry for a given IFUNC Atom.
  ///
  /// If the entry does not exist. Both the GOT and PLT entry is created.
  const PLTAtom *getIFUNCPLTEntry(const DefinedAtom *da) {
    auto plt = _pltMap.find(da);
    if (plt != _pltMap.end())
      return plt-&gt;second;
    auto ga = new (_file._alloc) Cpu0GOTAtom(_file, ".got.plt");
    ga-&gt;addReferenceELF_Cpu0(R_CPU0_RELGOT, 0, da, 0);
    auto pa = new (_file._alloc) Cpu0PLTAtom(_file, ".plt");
    pa-&gt;addReferenceELF_Cpu0(R_CPU0_PC24, 2, ga, -4);
#ifndef NDEBUG
    ga-&gt;_name = "__got_ifunc_";
    ga-&gt;_name += da-&gt;name();
    pa-&gt;_name = "__plt_ifunc_";
    pa-&gt;_name += da-&gt;name();
#endif
    _gotMap[da] = ga;
    _pltMap[da] = pa;
    _gotVector.push_back(ga);
    _pltVector.push_back(pa);
    return pa;
  }
#endif // DLINKER

  /// \brief Redirect the call to the PLT stub for the target IFUNC.
  ///
  /// This create a PLT and GOT entry for the IFUNC if one does not exist. The
  /// GOT entry and a IRELATIVE relocation to the original target resolver.
  std::error_code handleIFUNC(const Reference &amp;ref) {
    auto target = dyn_cast_or_null&lt;const DefinedAtom&gt;(ref.target());
#ifdef DLINKER
    if (target &amp;&amp; target-&gt;contentType() == DefinedAtom::typeResolver)
      const_cast&lt;Reference &amp;&gt;(ref).setTarget(getIFUNCPLTEntry(target));
#endif // DLINKER
    return std::error_code();
  }

  /// \brief Create a GOT entry for the TP offset of a TLS atom.
  const GOTAtom *getGOTTPOFF(const Atom *atom) {
    auto got = _gotMap.find(atom);
    if (got == _gotMap.end()) {
      auto g = new (_file._alloc) Cpu0GOTAtom(_file, ".got");
      g-&gt;addReferenceELF_Cpu0(R_CPU0_TLS_TPREL32, 0, atom, 0);
#ifndef NDEBUG
      g-&gt;_name = "__got_tls_";
      g-&gt;_name += atom-&gt;name();
#endif
      _gotMap[atom] = g;
      _gotVector.push_back(g);
      return g;
    }
    return got-&gt;second;
  }

  /// \brief Create a GOT entry containing 0.
  const GOTAtom *getNullGOT() {
    if (!_null) {
      _null = new (_file._alloc) Cpu0GOTAtom(_file, ".got.plt");
#ifndef NDEBUG
      _null-&gt;_name = "__got_null";
#endif
    }
    return _null;
  }

  const GOTAtom *getGOT(const DefinedAtom *da) {
    auto got = _gotMap.find(da);
    if (got == _gotMap.end()) {
      auto g = new (_file._alloc) Cpu0GOTAtom(_file, ".got");
      g-&gt;addReferenceELF_Cpu0(R_CPU0_32, 0, da, 0);
#ifndef NDEBUG
      g-&gt;_name = "__got_";
      g-&gt;_name += da-&gt;name();
#endif
      _gotMap[da] = g;
      _gotVector.push_back(g);
      return g;
    }
    return got-&gt;second;
  }

public:
  RelocationPass(const ELFLinkingContext &amp;ctx)
      : _file(ctx), _ctx(ctx), _null(nullptr), _PLT0(nullptr), _got0(nullptr), 
        _boot(new Cpu0BootAtom(_file)) {}

  /// \brief Do the pass.
  ///
  /// The goal here is to first process each reference individually. Each call
  /// to handleReference may modify the reference itself and/or create new
  /// atoms which must be stored in one of the maps below.
  ///
  /// After all references are handled, the atoms created during that are all
  /// added to mf.
  void perform(std::unique_ptr&lt;MutableFile&gt; &amp;mf) override {
    ScopedTask task(getDefaultDomain(), "Cpu0 GOT/PLT Pass");
    // Process all references.
    for (const auto &amp;atom : mf-&gt;defined())
      for (const auto &amp;ref : *atom)
        handleReference(*atom, *ref);

    // Add all created atoms to the link.
    uint64_t ordinal = 0;
    if (_ctx.getOutputELFType() == llvm::ELF::ET_EXEC) {
      MutableFile::DefinedAtomRange atomRange = mf-&gt;definedAtoms();
      auto it = atomRange.begin();
      bool find = false;
      for (it = atomRange.begin(); it &lt; atomRange.end(); it++) {
        if ((*it)-&gt;name() == "start") {
          find = true;
          break;
        }
      }
      assert(find &amp;&amp; "not found start\n");
      _boot-&gt;addReferenceELF_Cpu0(R_CPU0_PC24, 0, *it, -3);
      find = false;
      for (it = atomRange.begin(); it &lt; atomRange.end(); it++) {
        if ((*it)-&gt;name() == "ISR") {
          find = true;
          break;
        }
      }
      assert(find &amp;&amp; "not found ISR\n");
      _boot-&gt;addReferenceELF_Cpu0(R_CPU0_PC24, 8, *it, -3);
      _boot-&gt;setOrdinal(ordinal++);
      mf-&gt;addAtom(*_boot);
    }
#ifdef DLINKER
    if (_PLT0) {
      MutableFile::DefinedAtomRange atomRange = mf-&gt;definedAtoms();
      auto it = atomRange.begin();
      bool find = false;
      for (it = atomRange.begin(); it &lt; atomRange.end(); it++) {
        if ((*it)-&gt;name() == "_Z14dynamic_linkerv") {
          find = true;
          break;
        }
      }
      assert(find &amp;&amp; "Cannot find _Z14dynamic_linkerv()");
      _PLT0-&gt;addReferenceELF_Cpu0(R_CPU0_PC24, 12, *it, -3);
      _PLT0-&gt;setOrdinal(ordinal++);
      mf-&gt;addAtom(*_PLT0);
    }
    for (auto &amp;plt : _pltVector) {
      plt-&gt;setOrdinal(ordinal++);
      mf-&gt;addAtom(*plt);
    }
    if (_null) {
      _null-&gt;setOrdinal(ordinal++);
      mf-&gt;addAtom(*_null);
    }
    if (_PLT0) {
      _got0-&gt;setOrdinal(ordinal++);
      mf-&gt;addAtom(*_got0);
    }
    for (auto &amp;got : _gotVector) {
      got-&gt;setOrdinal(ordinal++);
      mf-&gt;addAtom(*got);
    }
    for (auto obj : _objectVector) {
      obj-&gt;setOrdinal(ordinal++);
      mf-&gt;addAtom(*obj);
    }
#endif // DLINKER
  }

protected:
  /// \brief Owner of all the Atoms created by this pass.
  ELFPassFile _file;
  const ELFLinkingContext &amp;_ctx;

  /// \brief Map Atoms to their GOT entries.
  llvm::DenseMap&lt;const Atom *, GOTAtom *&gt; _gotMap;

  /// \brief Map Atoms to their PLT entries.
  llvm::DenseMap&lt;const Atom *, PLTAtom *&gt; _pltMap;

  /// \brief Map Atoms to their Object entries.
  llvm::DenseMap&lt;const Atom *, ObjectAtom *&gt; _objectMap;

  /// \brief the list of GOT/PLT atoms
  std::vector&lt;GOTAtom *&gt; _gotVector;
  std::vector&lt;PLTAtom *&gt; _pltVector;
  std::vector&lt;ObjectAtom *&gt; _objectVector;
  PLT0Atom *_boot;

  /// \brief GOT entry that is always 0. Used for undefined weaks.
  GOTAtom *_null;

  /// \brief The got and plt entries for .PLT0. This is used to call into the
  /// dynamic linker for symbol resolution.
  /// @{
  PLT0Atom *_PLT0;
  GOTAtom *_got0;
  /// @}
};

/// This implements the static relocation model. Meaning GOT and PLT entries are
/// not created for references that can be directly resolved. These are
/// converted to a direct relocation. For entries that do require a GOT or PLT
/// entry, that entry is statically bound.
///
/// TLS always assumes module 1 and attempts to remove indirection.
class StaticRelocationPass final
    : public RelocationPass&lt;StaticRelocationPass&gt; {
public:
  StaticRelocationPass(const elf::Cpu0LinkingContext &amp;ctx)
      : RelocationPass(ctx) {}

  std::error_code handlePlain(const Reference &amp;ref) { return handleIFUNC(ref); }

  std::error_code handlePLT32(const Reference &amp;ref) {
    // __tls_get_addr is handled elsewhere.
    if (ref.target() &amp;&amp; ref.target()-&gt;name() == "__tls_get_addr") {
      const_cast&lt;Reference &amp;&gt;(ref).setKindValue(R_CPU0_NONE);
      return std::error_code();
    }
    // Static code doesn't need PLTs.
    const_cast&lt;Reference &amp;&gt;(ref).setKindValue(R_CPU0_PC24);
    // Handle IFUNC.
    if (const DefinedAtom *da =
            dyn_cast_or_null&lt;const DefinedAtom&gt;(ref.target()))
      if (da-&gt;contentType() == DefinedAtom::typeResolver)
        return handleIFUNC(ref);
    return std::error_code();
  }

  std::error_code handleGOT(const Reference &amp;ref) {
    if (isa&lt;UndefinedAtom&gt;(ref.target()))
      const_cast&lt;Reference &amp;&gt;(ref).setTarget(getNullGOT());
    else if (const DefinedAtom *da = dyn_cast&lt;const DefinedAtom&gt;(ref.target()))
      const_cast&lt;Reference &amp;&gt;(ref).setTarget(getGOT(da));
    return std::error_code();
  }
};

#ifdef DLINKER
class DynamicRelocationPass final
    : public RelocationPass&lt;DynamicRelocationPass&gt; {
public:
  DynamicRelocationPass(const elf::Cpu0LinkingContext &amp;ctx)
      : RelocationPass(ctx) {}

  const PLT0Atom *getPLT0() {
    if (_PLT0)
      return _PLT0;
    // Fill in the null entry.
    getNullGOT();
    _PLT0 = new (_file._alloc) Cpu0PLT0Atom(_file);
    _got0 = new (_file._alloc) Cpu0GOTAtom(_file, ".got.plt");
#ifndef NDEBUG
    _got0-&gt;_name = "__got0";
#endif
    return _PLT0;
  }

  const PLTAtom *getPLTEntry(const Atom *a) {
    auto plt = _pltMap.find(a);
    if (plt != _pltMap.end())
      return plt-&gt;second;
    auto ga = new (_file._alloc) Cpu0GOTAtom(_file, ".got.plt");
    ga-&gt;addReferenceELF_Cpu0(R_CPU0_JUMP_SLOT, 0, a, 0);
    auto pa = new (_file._alloc) Cpu0PLTAtom(_file, ".plt");
    getPLT0();  // add _PLT0 and _got0

    // Set the starting address of the got entry to the second instruction in
    // the plt entry.
    ga-&gt;addReferenceELF_Cpu0(R_CPU0_32, 0, pa, 4);
#ifndef NDEBUG
    ga-&gt;_name = "__got_";
    ga-&gt;_name += a-&gt;name();
    pa-&gt;_name = "__plt_";
    pa-&gt;_name += a-&gt;name();
#endif
    _gotMap[a] = ga;
    _pltMap[a] = pa;
    _gotVector.push_back(ga);
    _pltVector.push_back(pa);
    return pa;
  }

#if 0 // Not support at this point
  const ObjectAtom *getObjectEntry(const SharedLibraryAtom *a) {
    auto obj = _objectMap.find(a);
    if (obj != _objectMap.end())
      return obj-&gt;second;

    auto oa = new (_file._alloc) ObjectAtom(_file);
    // This needs to point to the atom that we just created.
    oa-&gt;addReferenceELF_Cpu0(R_Cpu0_COPY, 0, oa, 0);

    oa-&gt;_name = a-&gt;name();
    oa-&gt;_size = a-&gt;size();

    _objectMap[a] = oa;
    _objectVector.push_back(oa);
    return oa;
  }
#endif

  std::error_code handlePlain(const Reference &amp;ref) {
    if (!ref.target())
      return std::error_code();
    if (auto sla = dyn_cast&lt;SharedLibraryAtom&gt;(ref.target())) {
#if 0 // Not support at this point
      if (sla-&gt;type() == SharedLibraryAtom::Type::Data)
        const_cast&lt;Reference &amp;&gt;(ref).setTarget(getObjectEntry(sla));
      else 
#endif
      if (sla-&gt;type() == SharedLibraryAtom::Type::Code)
        const_cast&lt;Reference &amp;&gt;(ref).setTarget(getPLTEntry(sla));
    } else
      return handleIFUNC(ref);
    return std::error_code();
  }

  std::error_code handlePLT32(const Reference &amp;ref) {
    // Handle IFUNC.
    if (const DefinedAtom *da =
            dyn_cast_or_null&lt;const DefinedAtom&gt;(ref.target()))
      if (da-&gt;contentType() == DefinedAtom::typeResolver)
        return handleIFUNC(ref);
    if (isa&lt;const SharedLibraryAtom&gt;(ref.target())) {
      const_cast&lt;Reference &amp;&gt;(ref).setTarget(getPLTEntry(ref.target()));
      // Turn this into a PC24 to the PLT entry.
    #if 1
      const_cast&lt;Reference &amp;&gt;(ref).setKindValue(R_CPU0_PC24);
    #endif
    }
    return std::error_code();
  }

  const GOTAtom *getSharedGOT(const Atom *a) {
    auto got = _gotMap.find(a);
    if (got == _gotMap.end()) {
      auto g = new (_file._alloc) Cpu0GOTAtom(_file, ".got.dyn");
      g-&gt;addReferenceELF_Cpu0(R_CPU0_GLOB_DAT, 0, a, 0);
#ifndef NDEBUG
      g-&gt;_name = "__got_";
      g-&gt;_name += a-&gt;name();
#endif
      _gotMap[a] = g;
      _gotVector.push_back(g);
      return g;
    }
    return got-&gt;second;
  }

  std::error_code handleGOT(const Reference &amp;ref) {
    if (const DefinedAtom *da = dyn_cast&lt;const DefinedAtom&gt;(ref.target()))
      const_cast&lt;Reference &amp;&gt;(ref).setTarget(getGOT(da));
    // Handle undefined atoms in the same way as shared lib atoms: to be
    // resolved at run time.
    else if (isa&lt;SharedLibraryAtom&gt;(ref.target()) ||
             isa&lt;UndefinedAtom&gt;(ref.target()))
      const_cast&lt;Reference &amp;&gt;(ref).setTarget(getSharedGOT(ref.target()));
    return std::error_code();
  }
};
#endif // DLINKER
} // end anon namespace

std::unique_ptr&lt;Pass&gt;
lld::elf::createCpu0RelocationPass(const Cpu0LinkingContext &amp;ctx) {
  switch (ctx.getOutputELFType()) {
  case llvm::ELF::ET_EXEC:
  // when the output file is execution file: e.g. a.out
#ifdef DLINKER
    if (ctx.isDynamic())
    // when the a.out refer to shared object *.so
      return std::unique_ptr&lt;Pass&gt;(new DynamicRelocationPass(ctx));
    else
#endif // DLINKER
      return std::unique_ptr&lt;Pass&gt;(new StaticRelocationPass(ctx));
#ifdef DLINKER
  case llvm::ELF::ET_DYN:
  // when the output file is shared object: e.g. foobar.so
    return std::unique_ptr&lt;Pass&gt;(new DynamicRelocationPass(ctx));
#endif // DLINKER
  case llvm::ELF::ET_REL:
    return std::unique_ptr&lt;Pass&gt;();
  default:
    llvm_unreachable("Unhandled output file type");
  }
}
</pre>
</div>
<p class="rubric">exlbt/lld/Cpu0/Cpu0LinkingContext.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===- lib/ReaderWriter/ELF/Cpu0/Cpu0LinkingContext.cpp ---------------===//</span>
<span class="c1">//</span>
<span class="c1">//                             The LLVM Linker</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#include &quot;Cpu0LinkingContext.h&quot;</span>
<span class="cp">#include &quot;Cpu0RelocationPass.h&quot;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">lld</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">elf</span><span class="o">::</span><span class="n">Cpu0LinkingContext</span><span class="o">::</span><span class="n">addPasses</span><span class="p">(</span><span class="n">PassManager</span> <span class="o">&amp;</span><span class="n">pm</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">pass</span> <span class="o">=</span> <span class="n">createCpu0RelocationPass</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">pass</span><span class="p">)</span>
    <span class="n">pm</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">pass</span><span class="p">));</span>
  <span class="n">ELFLinkingContext</span><span class="o">::</span><span class="n">addPasses</span><span class="p">(</span><span class="n">pm</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">exlbt/lld/Cpu0/Cpu0Target.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===- lib/ReaderWriter/ELF/Cpu0/Cpu0Target.h -------------------------===//</span>
<span class="c1">//</span>
<span class="c1">//                             The LLVM Linker</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#include &quot;Cpu0LinkingContext.h&quot;</span>
</pre></div>
</div>
<p class="rubric">exlbt/lld/Cpu0/Cpu0TargetHandler.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===- lib/ReaderWriter/ELF/Cpu0/Cpu0TargetHandler.h ------------------===//</span>
<span class="c1">//</span>
<span class="c1">//                             The LLVM Linker</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#ifndef LLD_READER_WRITER_ELF_CPU0_CPU0_TARGET_HANDLER_H</span>
<span class="cp">#define LLD_READER_WRITER_ELF_CPU0_CPU0_TARGET_HANDLER_H</span>

<span class="cp">#include &quot;Cpu0ELFFile.h&quot;</span>
<span class="cp">#include &quot;Cpu0ELFReader.h&quot;</span>
<span class="cp">#include &quot;Cpu0RelocationHandler.h&quot;</span>
<span class="cp">#include &quot;DefaultTargetHandler.h&quot;</span>
<span class="cp">#include &quot;TargetLayout.h&quot;</span>

<span class="cp">#include &quot;lld/Core/Simple.h&quot;</span>

<span class="cp">#define DLINKER</span>

<span class="k">namespace</span> <span class="n">lld</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">elf</span> <span class="p">{</span>
<span class="k">typedef</span> <span class="n">llvm</span><span class="o">::</span><span class="n">object</span><span class="o">::</span><span class="n">ELFType</span><span class="o">&lt;</span><span class="n">llvm</span><span class="o">::</span><span class="n">support</span><span class="o">::</span><span class="n">big</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">false</span><span class="o">&gt;</span> <span class="n">Cpu0ELFType</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">Cpu0LinkingContext</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ELFT</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Cpu0TargetLayout</span> <span class="o">:</span> <span class="k">public</span> <span class="n">TargetLayout</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Cpu0TargetLayout</span><span class="p">(</span><span class="n">Cpu0LinkingContext</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">TargetLayout</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;</span><span class="p">(</span><span class="n">context</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Cpu0TargetHandler</span> <span class="n">final</span>
    <span class="o">:</span> <span class="k">public</span> <span class="n">DefaultTargetHandler</span><span class="o">&lt;</span><span class="n">Cpu0ELFType</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Cpu0TargetHandler</span><span class="p">(</span><span class="n">Cpu0LinkingContext</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">);</span>

  <span class="n">Cpu0TargetLayout</span><span class="o">&lt;</span><span class="n">Cpu0ELFType</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">getTargetLayout</span><span class="p">()</span> <span class="n">override</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="n">_cpu0TargetLayout</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">registerRelocationNames</span><span class="p">(</span><span class="n">Registry</span> <span class="o">&amp;</span><span class="n">registry</span><span class="p">)</span> <span class="n">override</span><span class="p">;</span>

  <span class="k">const</span> <span class="n">Cpu0TargetRelocationHandler</span> <span class="o">&amp;</span><span class="n">getRelocationHandler</span><span class="p">()</span> <span class="k">const</span> <span class="n">override</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="n">_cpu0RelocationHandler</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
  <span class="p">}</span>

  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Reader</span><span class="o">&gt;</span> <span class="n">getObjReader</span><span class="p">(</span><span class="kt">bool</span> <span class="n">atomizeStrings</span><span class="p">)</span> <span class="n">override</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Reader</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">Cpu0ELFObjectReader</span><span class="p">(</span><span class="n">atomizeStrings</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Reader</span><span class="o">&gt;</span> <span class="n">getDSOReader</span><span class="p">(</span><span class="kt">bool</span> <span class="n">useShlibUndefines</span><span class="p">)</span> <span class="n">override</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Reader</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">Cpu0ELFDSOReader</span><span class="p">(</span><span class="n">useShlibUndefines</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Writer</span><span class="o">&gt;</span> <span class="n">getWriter</span><span class="p">()</span> <span class="n">override</span><span class="p">;</span>

<span class="nl">private:</span>
  <span class="k">static</span> <span class="k">const</span> <span class="n">Registry</span><span class="o">::</span><span class="n">KindStrings</span> <span class="n">kindStrings</span><span class="p">[];</span>
  <span class="n">Cpu0LinkingContext</span> <span class="o">&amp;</span><span class="n">_context</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Cpu0TargetLayout</span><span class="o">&lt;</span><span class="n">Cpu0ELFType</span><span class="o">&gt;&gt;</span> <span class="n">_cpu0TargetLayout</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Cpu0TargetRelocationHandler</span><span class="o">&gt;</span> <span class="n">_cpu0RelocationHandler</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">}</span> <span class="c1">// end namespace elf</span>
<span class="p">}</span> <span class="c1">// end namespace lld</span>

<span class="cp">#endif</span>
</pre></div>
</div>
<p class="rubric">exlbt/lld/Cpu0/Cpu0TargetHandler.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===- lib/ReaderWriter/ELF/Cpu0/Cpu0TargetHandler.cpp ----------------===//</span>
<span class="c1">//</span>
<span class="c1">//                             The LLVM Linker</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#include &quot;Atoms.h&quot;</span>
<span class="cp">#include &quot;Cpu0DynamicLibraryWriter.h&quot;</span>
<span class="cp">#include &quot;Cpu0ExecutableWriter.h&quot;</span>
<span class="cp">#include &quot;Cpu0LinkingContext.h&quot;</span>
<span class="cp">#include &quot;Cpu0TargetHandler.h&quot;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">lld</span><span class="p">;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">elf</span><span class="p">;</span>

<span class="n">Cpu0TargetHandler</span><span class="o">::</span><span class="n">Cpu0TargetHandler</span><span class="p">(</span><span class="n">Cpu0LinkingContext</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">DefaultTargetHandler</span><span class="p">(</span><span class="n">context</span><span class="p">),</span> <span class="n">_context</span><span class="p">(</span><span class="n">context</span><span class="p">),</span>
      <span class="n">_cpu0TargetLayout</span><span class="p">(</span><span class="k">new</span> <span class="n">Cpu0TargetLayout</span><span class="o">&lt;</span><span class="n">Cpu0ELFType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">context</span><span class="p">)),</span>
      <span class="n">_cpu0RelocationHandler</span><span class="p">(</span>
          <span class="k">new</span> <span class="n">Cpu0TargetRelocationHandler</span><span class="p">(</span><span class="o">*</span><span class="n">_cpu0TargetLayout</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="n">context</span><span class="p">,</span> 
                                          <span class="n">context</span><span class="p">))</span> <span class="p">{}</span>

<span class="kt">void</span> <span class="n">Cpu0TargetHandler</span><span class="o">::</span><span class="n">registerRelocationNames</span><span class="p">(</span><span class="n">Registry</span> <span class="o">&amp;</span><span class="n">registry</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">registry</span><span class="p">.</span><span class="n">addKindTable</span><span class="p">(</span><span class="n">Reference</span><span class="o">::</span><span class="n">KindNamespace</span><span class="o">::</span><span class="n">ELF</span><span class="p">,</span>
                        <span class="n">Reference</span><span class="o">::</span><span class="n">KindArch</span><span class="o">::</span><span class="n">Cpu0</span><span class="p">,</span> <span class="n">kindStrings</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Writer</span><span class="o">&gt;</span> <span class="n">Cpu0TargetHandler</span><span class="o">::</span><span class="n">getWriter</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">_context</span><span class="p">.</span><span class="n">getOutputELFType</span><span class="p">())</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">llvm</span>:<span class="o">:</span><span class="n">ELF</span><span class="o">::</span><span class="n">ET_EXEC</span><span class="o">:</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Writer</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">Cpu0ExecutableWriter</span><span class="o">&lt;</span><span class="n">Cpu0ELFType</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="n">_context</span><span class="p">,</span> <span class="o">*</span><span class="n">_cpu0TargetLayout</span><span class="p">.</span><span class="n">get</span><span class="p">()));</span>
  <span class="k">case</span> <span class="n">llvm</span>:<span class="o">:</span><span class="n">ELF</span><span class="o">::</span><span class="n">ET_DYN</span><span class="o">:</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Writer</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="k">new</span> <span class="n">Cpu0DynamicLibraryWriter</span><span class="o">&lt;</span><span class="n">Cpu0ELFType</span><span class="o">&gt;</span><span class="p">(</span>
            <span class="n">_context</span><span class="p">,</span> <span class="o">*</span><span class="n">_cpu0TargetLayout</span><span class="p">.</span><span class="n">get</span><span class="p">()));</span>
  <span class="k">case</span> <span class="n">llvm</span>:<span class="o">:</span><span class="n">ELF</span><span class="o">::</span><span class="n">ET_REL</span><span class="o">:</span>
    <span class="n">llvm_unreachable</span><span class="p">(</span><span class="s">&quot;TODO: support -r mode&quot;</span><span class="p">);</span>
  <span class="nl">default:</span>
    <span class="n">llvm_unreachable</span><span class="p">(</span><span class="s">&quot;unsupported output type&quot;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="cp">#define ELF_RELOC(name, value) LLD_KIND_STRING_ENTRY(name),</span>

<span class="k">const</span> <span class="n">Registry</span><span class="o">::</span><span class="n">KindStrings</span> <span class="n">Cpu0TargetHandler</span><span class="o">::</span><span class="n">kindStrings</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
<span class="cp">#include &quot;llvm/Support/ELFRelocs/Cpu0.def&quot;</span>
  <span class="n">LLD_KIND_STRING_ENTRY</span><span class="p">(</span><span class="n">LLD_R_CPU0_GOTRELINDEX</span><span class="p">),</span>
  <span class="n">LLD_KIND_STRING_END</span>
<span class="p">};</span>

<span class="cp">#undef ELF_RELOC</span>
</pre></div>
</div>
<p class="rubric">exlbt/lld/Cpu0el/CMakeLists.txt</p>
<div class="highlight-c++"><pre>add_lld_library(lldCpu0elELFTarget
  Cpu0LinkingContext.cpp
  Cpu0TargetHandler.cpp
  Cpu0RelocationHandler.cpp
  Cpu0RelocationPass.cpp
  )

target_link_libraries(lldCpu0elELFTarget ${cmake_2_8_12_INTERFACE}
  lldCore
  )
</pre>
</div>
<p class="rubric">exlbt/lld/Cpu0el/Cpu0DynamicLibraryWriter.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===- lib/ReaderWriter/ELF/Cpu0/Cpu0DynamicLibraryWriter.h ---------------===//</span>
<span class="c1">//</span>
<span class="c1">//                             The LLVM Linker</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="cp">#ifndef CPU0EL_DYNAMIC_LIBRARY_WRITER_H</span>
<span class="cp">#define CPU0EL_DYNAMIC_LIBRARY_WRITER_H</span>

<span class="cp">#include &quot;DynamicLibraryWriter.h&quot;</span>
<span class="cp">#include &quot;Cpu0LinkingContext.h&quot;</span>

<span class="k">namespace</span> <span class="n">lld</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">elf</span> <span class="p">{</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ELFT</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Cpu0DynamicLibraryWriter</span> <span class="o">:</span> <span class="k">public</span> <span class="n">DynamicLibraryWriter</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Cpu0DynamicLibraryWriter</span><span class="p">(</span><span class="n">Cpu0elLinkingContext</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">,</span>
                           <span class="n">Cpu0elTargetLayout</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">layout</span><span class="p">);</span>

<span class="nl">protected:</span>
  <span class="c1">// Add any runtime files and their atoms to the output</span>
  <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">createImplicitFiles</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">File</span><span class="o">&gt;&gt;</span> <span class="o">&amp;</span><span class="p">);</span>

  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">finalizeDefaultAtomValues</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">DynamicLibraryWriter</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;::</span><span class="n">finalizeDefaultAtomValues</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">addDefaultAtoms</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">DynamicLibraryWriter</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;::</span><span class="n">addDefaultAtoms</span><span class="p">();</span>
  <span class="p">}</span>

<span class="nl">private:</span>
  <span class="k">class</span> <span class="nc">GOTFile</span> <span class="o">:</span> <span class="k">public</span> <span class="n">SimpleFile</span> <span class="p">{</span>
  <span class="nl">public:</span>
    <span class="n">GOTFile</span><span class="p">(</span><span class="k">const</span> <span class="n">ELFLinkingContext</span> <span class="o">&amp;</span><span class="n">eti</span><span class="p">)</span> <span class="o">:</span> <span class="n">SimpleFile</span><span class="p">(</span><span class="s">&quot;GOTFile&quot;</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">llvm</span><span class="o">::</span><span class="n">BumpPtrAllocator</span> <span class="n">_alloc</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">GOTFile</span><span class="o">&gt;</span> <span class="n">_gotFile</span><span class="p">;</span>
  <span class="n">Cpu0elLinkingContext</span> <span class="o">&amp;</span><span class="n">_context</span><span class="p">;</span>
  <span class="n">Cpu0elTargetLayout</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">_cpu0Layout</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ELFT</span><span class="o">&gt;</span>
<span class="n">Cpu0DynamicLibraryWriter</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;::</span><span class="n">Cpu0DynamicLibraryWriter</span><span class="p">(</span>
    <span class="n">Cpu0elLinkingContext</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">,</span> <span class="n">Cpu0elTargetLayout</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">layout</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">DynamicLibraryWriter</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">layout</span><span class="p">),</span>
      <span class="n">_gotFile</span><span class="p">(</span><span class="k">new</span> <span class="n">GOTFile</span><span class="p">(</span><span class="n">context</span><span class="p">)),</span> <span class="n">_context</span><span class="p">(</span><span class="n">context</span><span class="p">),</span> <span class="n">_cpu0Layout</span><span class="p">(</span><span class="n">layout</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ELFT</span><span class="o">&gt;</span>
<span class="kt">bool</span> <span class="n">Cpu0DynamicLibraryWriter</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;::</span><span class="n">createImplicitFiles</span><span class="p">(</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">File</span><span class="o">&gt;&gt;</span> <span class="o">&amp;</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">DynamicLibraryWriter</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;::</span><span class="n">createImplicitFiles</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
  <span class="n">_gotFile</span><span class="o">-&gt;</span><span class="n">addAtom</span><span class="p">(</span><span class="o">*</span><span class="k">new</span> <span class="p">(</span><span class="n">_gotFile</span><span class="o">-&gt;</span><span class="n">_alloc</span><span class="p">)</span> <span class="n">GLOBAL_OFFSET_TABLEAtom</span><span class="p">(</span><span class="o">*</span><span class="n">_gotFile</span><span class="p">));</span>
  <span class="n">_gotFile</span><span class="o">-&gt;</span><span class="n">addAtom</span><span class="p">(</span><span class="o">*</span><span class="k">new</span> <span class="p">(</span><span class="n">_gotFile</span><span class="o">-&gt;</span><span class="n">_alloc</span><span class="p">)</span> <span class="n">DYNAMICAtom</span><span class="p">(</span><span class="o">*</span><span class="n">_gotFile</span><span class="p">));</span>
  <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">_gotFile</span><span class="p">));</span>
  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">}</span> <span class="c1">// namespace elf</span>
<span class="p">}</span> <span class="c1">// namespace lld</span>

<span class="cp">#endif</span>
</pre></div>
</div>
<p class="rubric">exlbt/lld/Cpu0el/Cpu0ExecutableWriter.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===- lib/ReaderWriter/ELF/Cpu0/Cpu0ExecutableWriter.h ------------------===//</span>
<span class="c1">//</span>
<span class="c1">//                             The LLVM Linker</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="cp">#ifndef CPU0EL_EXECUTABLE_WRITER_H</span>
<span class="cp">#define CPU0EL_EXECUTABLE_WRITER_H</span>

<span class="cp">#include &quot;ExecutableWriter.h&quot;</span>
<span class="cp">#include &quot;Cpu0LinkingContext.h&quot;</span>

<span class="k">namespace</span> <span class="n">lld</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">elf</span> <span class="p">{</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ELFT</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Cpu0ExecutableWriter</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ExecutableWriter</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Cpu0ExecutableWriter</span><span class="p">(</span><span class="n">Cpu0elLinkingContext</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">,</span>
                         <span class="n">Cpu0elTargetLayout</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">layout</span><span class="p">);</span>

<span class="nl">protected:</span>
  <span class="c1">// Add any runtime files and their atoms to the output</span>
  <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">createImplicitFiles</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">File</span><span class="o">&gt;&gt;</span> <span class="o">&amp;</span><span class="p">);</span>

  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">finalizeDefaultAtomValues</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">ExecutableWriter</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;::</span><span class="n">finalizeDefaultAtomValues</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">addDefaultAtoms</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">ExecutableWriter</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;::</span><span class="n">addDefaultAtoms</span><span class="p">();</span>
  <span class="p">}</span>

<span class="nl">private:</span>
  <span class="k">class</span> <span class="nc">GOTFile</span> <span class="o">:</span> <span class="k">public</span> <span class="n">SimpleFile</span> <span class="p">{</span>
  <span class="nl">public:</span>
    <span class="n">GOTFile</span><span class="p">(</span><span class="k">const</span> <span class="n">ELFLinkingContext</span> <span class="o">&amp;</span><span class="n">eti</span><span class="p">)</span> <span class="o">:</span> <span class="n">SimpleFile</span><span class="p">(</span><span class="s">&quot;GOTFile&quot;</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">llvm</span><span class="o">::</span><span class="n">BumpPtrAllocator</span> <span class="n">_alloc</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">GOTFile</span><span class="o">&gt;</span> <span class="n">_gotFile</span><span class="p">;</span>
  <span class="n">Cpu0elLinkingContext</span> <span class="o">&amp;</span><span class="n">_context</span><span class="p">;</span>
  <span class="n">Cpu0elTargetLayout</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">_cpu0Layout</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ELFT</span><span class="o">&gt;</span>
<span class="n">Cpu0ExecutableWriter</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;::</span><span class="n">Cpu0ExecutableWriter</span><span class="p">(</span>
    <span class="n">Cpu0elLinkingContext</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">,</span> <span class="n">Cpu0elTargetLayout</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">layout</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">ExecutableWriter</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">layout</span><span class="p">),</span> <span class="n">_gotFile</span><span class="p">(</span><span class="k">new</span> <span class="n">GOTFile</span><span class="p">(</span><span class="n">context</span><span class="p">)),</span>
      <span class="n">_context</span><span class="p">(</span><span class="n">context</span><span class="p">),</span> <span class="n">_cpu0Layout</span><span class="p">(</span><span class="n">layout</span><span class="p">)</span> <span class="p">{}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ELFT</span><span class="o">&gt;</span>
<span class="kt">bool</span> <span class="n">Cpu0ExecutableWriter</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;::</span><span class="n">createImplicitFiles</span><span class="p">(</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">File</span><span class="o">&gt;&gt;</span> <span class="o">&amp;</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">ExecutableWriter</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;::</span><span class="n">createImplicitFiles</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
  <span class="n">_gotFile</span><span class="o">-&gt;</span><span class="n">addAtom</span><span class="p">(</span><span class="o">*</span><span class="k">new</span> <span class="p">(</span><span class="n">_gotFile</span><span class="o">-&gt;</span><span class="n">_alloc</span><span class="p">)</span> <span class="n">GLOBAL_OFFSET_TABLEAtom</span><span class="p">(</span><span class="o">*</span><span class="n">_gotFile</span><span class="p">));</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">_context</span><span class="p">.</span><span class="n">isDynamic</span><span class="p">())</span>
    <span class="n">_gotFile</span><span class="o">-&gt;</span><span class="n">addAtom</span><span class="p">(</span><span class="o">*</span><span class="k">new</span> <span class="p">(</span><span class="n">_gotFile</span><span class="o">-&gt;</span><span class="n">_alloc</span><span class="p">)</span> <span class="n">DYNAMICAtom</span><span class="p">(</span><span class="o">*</span><span class="n">_gotFile</span><span class="p">));</span>
  <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">_gotFile</span><span class="p">));</span>
  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">}</span> <span class="c1">// namespace elf</span>
<span class="p">}</span> <span class="c1">// namespace lld</span>

<span class="cp">#endif</span>
</pre></div>
</div>
<p class="rubric">exlbt/lld/Cpu0el/Cpu0LinkingContext.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===- lib/ReaderWriter/ELF/Cpu0/Cpu0LinkingContext.h -----------------===//</span>
<span class="c1">//</span>
<span class="c1">//                             The LLVM Linker</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#ifndef LLD_READER_WRITER_ELF_CPU0EL_CPU0EL_LINKING_CONTEXT_H</span>
<span class="cp">#define LLD_READER_WRITER_ELF_CPU0EL_CPU0EL_LINKING_CONTEXT_H</span>

<span class="cp">#include &quot;Cpu0TargetHandler.h&quot;</span>

<span class="cp">#include &quot;lld/ReaderWriter/ELFLinkingContext.h&quot;</span>

<span class="cp">#include &quot;llvm/Object/ELF.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/ELF.h&quot;</span>

<span class="k">namespace</span> <span class="n">lld</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">elf</span> <span class="p">{</span>

<span class="c1">/// \brief Cpu0 internal references.</span>
<span class="k">enum</span> <span class="p">{</span>
  <span class="c1">/// \brief The 32 bit index of the relocation in the got this reference refers</span>
  <span class="c1">/// to.</span>
  <span class="n">LLD_R_CPU0EL_GOTRELINDEX</span> <span class="o">=</span> <span class="mi">1025</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Cpu0elLinkingContext</span> <span class="n">final</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ELFLinkingContext</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Cpu0elLinkingContext</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">Triple</span> <span class="n">triple</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">ELFLinkingContext</span><span class="p">(</span><span class="n">triple</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">TargetHandlerBase</span><span class="o">&gt;</span><span class="p">(</span>
                                      <span class="k">new</span> <span class="n">Cpu0elTargetHandler</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">)))</span> <span class="p">{}</span>

<span class="c1">//  bool isLittleEndian() const override { return false; }</span>

  <span class="kt">void</span> <span class="n">addPasses</span><span class="p">(</span><span class="n">PassManager</span> <span class="o">&amp;</span><span class="p">)</span> <span class="n">override</span><span class="p">;</span>

  <span class="kt">uint64_t</span> <span class="n">getBaseAddress</span><span class="p">()</span> <span class="k">const</span> <span class="n">override</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_baseAddress</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
      <span class="k">return</span> <span class="mh">0x000000</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">_baseAddress</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">bool</span> <span class="n">isDynamicRelocation</span><span class="p">(</span><span class="k">const</span> <span class="n">DefinedAtom</span> <span class="o">&amp;</span><span class="p">,</span>
                           <span class="k">const</span> <span class="n">Reference</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">)</span> <span class="k">const</span> <span class="n">override</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">kindNamespace</span><span class="p">()</span> <span class="o">!=</span> <span class="n">Reference</span><span class="o">::</span><span class="n">KindNamespace</span><span class="o">::</span><span class="n">ELF</span><span class="p">)</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">kindArch</span><span class="p">()</span> <span class="o">==</span> <span class="n">Reference</span><span class="o">::</span><span class="n">KindArch</span><span class="o">::</span><span class="n">Cpu0</span><span class="p">);</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">kindValue</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">llvm</span>:<span class="o">:</span><span class="n">ELF</span><span class="o">::</span><span class="n">R_CPU0_GLOB_DAT</span><span class="o">:</span>
      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="nl">default:</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">isPLTRelocation</span><span class="p">(</span><span class="k">const</span> <span class="n">DefinedAtom</span> <span class="o">&amp;</span><span class="p">,</span>
                               <span class="k">const</span> <span class="n">Reference</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">)</span> <span class="k">const</span> <span class="n">override</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">kindNamespace</span><span class="p">()</span> <span class="o">!=</span> <span class="n">Reference</span><span class="o">::</span><span class="n">KindNamespace</span><span class="o">::</span><span class="n">ELF</span><span class="p">)</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">kindArch</span><span class="p">()</span> <span class="o">==</span> <span class="n">Reference</span><span class="o">::</span><span class="n">KindArch</span><span class="o">::</span><span class="n">Cpu0</span><span class="p">);</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">kindValue</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">llvm</span>:<span class="o">:</span><span class="n">ELF</span><span class="o">::</span><span class="n">R_CPU0_JUMP_SLOT</span><span class="o">:</span>
    <span class="k">case</span> <span class="n">llvm</span>:<span class="o">:</span><span class="n">ELF</span><span class="o">::</span><span class="n">R_CPU0_RELGOT</span><span class="o">:</span>
      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="nl">default:</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">/// \brief Cpu0 has two relative relocations</span>
  <span class="c1">/// a) for supporting relative relocs - R_CPU0_RELGOT</span>
  <span class="kt">bool</span> <span class="n">isRelativeReloc</span><span class="p">(</span><span class="k">const</span> <span class="n">Reference</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">)</span> <span class="k">const</span> <span class="n">override</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">kindNamespace</span><span class="p">()</span> <span class="o">!=</span> <span class="n">Reference</span><span class="o">::</span><span class="n">KindNamespace</span><span class="o">::</span><span class="n">ELF</span><span class="p">)</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">kindArch</span><span class="p">()</span> <span class="o">==</span> <span class="n">Reference</span><span class="o">::</span><span class="n">KindArch</span><span class="o">::</span><span class="n">Cpu0</span><span class="p">);</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">kindValue</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">llvm</span>:<span class="o">:</span><span class="n">ELF</span><span class="o">::</span><span class="n">R_CPU0_RELGOT</span><span class="o">:</span>
      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="nl">default:</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kt">bool</span> <span class="n">isStaticExecutable</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_isStaticExecutable</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// end namespace elf</span>
<span class="p">}</span> <span class="c1">// end namespace lld</span>

<span class="cp">#endif</span>
</pre></div>
</div>
<p class="rubric">exlbt/lld/Cpu0el/Cpu0LinkingContext.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===- lib/ReaderWriter/ELF/Cpu0/Cpu0LinkingContext.cpp ---------------===//</span>
<span class="c1">//</span>
<span class="c1">//                             The LLVM Linker</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#include &quot;Cpu0LinkingContext.h&quot;</span>
<span class="cp">#include &quot;Cpu0RelocationPass.h&quot;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">lld</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">elf</span><span class="o">::</span><span class="n">Cpu0elLinkingContext</span><span class="o">::</span><span class="n">addPasses</span><span class="p">(</span><span class="n">PassManager</span> <span class="o">&amp;</span><span class="n">pm</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">pass</span> <span class="o">=</span> <span class="n">createCpu0RelocationPass</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">pass</span><span class="p">)</span>
    <span class="n">pm</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">pass</span><span class="p">));</span>
  <span class="n">ELFLinkingContext</span><span class="o">::</span><span class="n">addPasses</span><span class="p">(</span><span class="n">pm</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">exlbt/lld/Cpu0el/Cpu0RelocationHandler.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===- lib/ReaderWriter/ELF/Cpu0/Cpu0RelocationHandler.h --------------===//</span>
<span class="c1">//</span>
<span class="c1">//                             The LLVM Linker</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#ifndef CPU0EL_RELOCATION_HANDLER_H</span>
<span class="cp">#define CPU0EL_RELOCATION_HANDLER_H</span>

<span class="cp">#include &quot;Cpu0TargetHandler.h&quot;</span>

<span class="k">namespace</span> <span class="n">lld</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">elf</span> <span class="p">{</span>
<span class="k">typedef</span> <span class="n">llvm</span><span class="o">::</span><span class="n">object</span><span class="o">::</span><span class="n">ELFType</span><span class="o">&lt;</span><span class="n">llvm</span><span class="o">::</span><span class="n">support</span><span class="o">::</span><span class="n">little</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">false</span><span class="o">&gt;</span> <span class="n">Cpu0elELFType</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">Cpu0elLinkingContext</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ELFT</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Cpu0elTargetLayout</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Cpu0elTargetRelocationHandler</span> <span class="n">final</span>
    <span class="o">:</span> <span class="k">public</span> <span class="n">TargetRelocationHandler</span><span class="o">&lt;</span><span class="n">Cpu0elELFType</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Cpu0elTargetRelocationHandler</span><span class="p">(</span><span class="n">Cpu0elTargetLayout</span><span class="o">&lt;</span><span class="n">Cpu0elELFType</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">layout</span><span class="p">,</span> 
                              <span class="n">Cpu0elLinkingContext</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">,</span> 
                              <span class="n">ELFLinkingContext</span> <span class="o">&amp;</span><span class="n">targetInfo</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">TargetRelocationHandler</span><span class="o">&lt;</span><span class="n">Cpu0elELFType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">targetInfo</span><span class="p">),</span>
        <span class="n">_tlsSize</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">_cpu0Layout</span><span class="p">(</span><span class="n">layout</span><span class="p">),</span> 
        <span class="n">_context</span><span class="p">(</span><span class="n">context</span><span class="p">)</span> <span class="p">{}</span>

  <span class="n">std</span><span class="o">::</span><span class="n">error_code</span> <span class="n">applyRelocation</span><span class="p">(</span><span class="n">ELFWriter</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">llvm</span><span class="o">::</span><span class="n">FileOutputBuffer</span> <span class="o">&amp;</span><span class="p">,</span>
                                  <span class="k">const</span> <span class="n">lld</span><span class="o">::</span><span class="n">AtomLayout</span> <span class="o">&amp;</span><span class="p">,</span>
                                  <span class="k">const</span> <span class="n">Reference</span> <span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span> <span class="n">override</span><span class="p">;</span>

<span class="nl">private:</span>
  <span class="c1">// Cached size of the TLS segment.</span>
  <span class="k">mutable</span> <span class="kt">uint64_t</span> <span class="n">_tlsSize</span><span class="p">;</span>
  <span class="n">Cpu0elTargetLayout</span><span class="o">&lt;</span><span class="n">Cpu0elELFType</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">_cpu0Layout</span><span class="p">;</span>
  <span class="n">Cpu0elLinkingContext</span> <span class="o">&amp;</span><span class="n">_context</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">}</span> <span class="c1">// end namespace elf</span>
<span class="p">}</span> <span class="c1">// end namespace lld</span>

<span class="cp">#endif </span><span class="c1">// CPU0EL_RELOCATION_HANDLER_H</span>
</pre></div>
</div>
<p class="rubric">exlbt/lld/Cpu0el/Cpu0RelocationHandler.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===- lib/ReaderWriter/ELF/Cpu0/Cpu0RelocationHandler.cpp ------------===//</span>
<span class="c1">//</span>
<span class="c1">//                             The LLVM Linker</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#include &quot;Cpu0TargetHandler.h&quot;</span>
<span class="cp">#include &quot;Cpu0LinkingContext.h&quot;</span>
<span class="cp">#include &quot;llvm/Object/ObjectFile.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/raw_ostream.h&quot;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">lld</span><span class="p">;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">elf</span><span class="p">;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">object</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">bool</span> <span class="nf">error</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">error_code</span> <span class="n">ec</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ec</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

  <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Cpu0RelocationHandler.cpp : error reading file: &quot;</span> 
         <span class="o">&lt;&lt;</span> <span class="n">ec</span><span class="p">.</span><span class="n">message</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
  <span class="n">outs</span><span class="p">().</span><span class="n">flush</span><span class="p">();</span>
  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">namespace</span> <span class="p">{</span>
<span class="c1">/// \brief R_CPU0_HI16 - word64: (S + A) &gt;&gt; 16</span>
<span class="kt">void</span> <span class="n">relocHI16</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">location</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">P</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">S</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">A</span><span class="p">)</span> <span class="p">{</span>
 <span class="c1">// Don&#39;t know why A, ref.addend(), = 9</span>
  <span class="kt">uint32_t</span> <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)(</span><span class="n">S</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">);</span>
  <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">llvm</span><span class="o">::</span><span class="n">support</span><span class="o">::</span><span class="kt">ulittle32_t</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">location</span><span class="p">)</span> <span class="o">=</span>
      <span class="n">result</span> <span class="o">|</span>
      <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="o">*</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">llvm</span><span class="o">::</span><span class="n">support</span><span class="o">::</span><span class="kt">ulittle32_t</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">location</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">relocLO16</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">location</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">P</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">S</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">A</span><span class="p">)</span> <span class="p">{</span>
 <span class="c1">// Don&#39;t know why A, ref.addend(), = 9</span>
  <span class="kt">uint32_t</span> <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)(</span><span class="n">S</span> <span class="o">&amp;</span> <span class="mh">0x0000ffff</span><span class="p">);</span>
  <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">llvm</span><span class="o">::</span><span class="n">support</span><span class="o">::</span><span class="kt">ulittle32_t</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">location</span><span class="p">)</span> <span class="o">=</span>
      <span class="n">result</span> <span class="o">|</span>
      <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="o">*</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">llvm</span><span class="o">::</span><span class="n">support</span><span class="o">::</span><span class="kt">ulittle32_t</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">location</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">/// \brief R_CPU0_GOT16 - word32: S</span>
<span class="kt">void</span> <span class="n">relocGOT16</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">location</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">P</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">S</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">A</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">uint32_t</span> <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)(</span><span class="n">S</span><span class="p">);</span>
  <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">llvm</span><span class="o">::</span><span class="n">support</span><span class="o">::</span><span class="kt">ulittle32_t</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">location</span><span class="p">)</span> <span class="o">=</span>
      <span class="n">result</span> <span class="o">|</span>
      <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="o">*</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">llvm</span><span class="o">::</span><span class="n">support</span><span class="o">::</span><span class="kt">ulittle32_t</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">location</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">/// \brief R_CPU0_PC24 - word32: S + A - P</span>
<span class="kt">void</span> <span class="n">relocPC24</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">location</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">P</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">S</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">A</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">uint32_t</span> <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)(</span><span class="n">S</span>  <span class="o">-</span> <span class="n">P</span><span class="p">);</span>

  <span class="kt">uint32_t</span> <span class="n">machinecode</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="o">*</span> 
                           <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">llvm</span><span class="o">::</span><span class="n">support</span><span class="o">::</span><span class="kt">ulittle32_t</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">location</span><span class="p">);</span>
  <span class="kt">uint32_t</span> <span class="n">opcode</span> <span class="o">=</span> <span class="p">(</span><span class="n">machinecode</span> <span class="o">&amp;</span> <span class="mh">0xff000000</span><span class="p">);</span>
  <span class="kt">uint32_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">machinecode</span> <span class="o">&amp;</span> <span class="mh">0x00ffffff</span><span class="p">);</span>
  <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">llvm</span><span class="o">::</span><span class="n">support</span><span class="o">::</span><span class="kt">ulittle32_t</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">location</span><span class="p">)</span> <span class="o">=</span>
      <span class="p">(((</span><span class="n">result</span> <span class="o">+</span> <span class="n">offset</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x00ffffff</span><span class="p">)</span> <span class="o">|</span> <span class="n">opcode</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">/// \brief R_CPU0_32 - word32:  S</span>
<span class="kt">void</span> <span class="n">reloc32</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">location</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">P</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">S</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">A</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int32_t</span> <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)(</span><span class="n">S</span><span class="p">);</span>
  <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">llvm</span><span class="o">::</span><span class="n">support</span><span class="o">::</span><span class="kt">ulittle32_t</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">location</span><span class="p">)</span> <span class="o">=</span>
      <span class="n">result</span> <span class="o">|</span>
      <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="o">*</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">llvm</span><span class="o">::</span><span class="n">support</span><span class="o">::</span><span class="kt">ubig32_t</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">location</span><span class="p">);</span>
  <span class="c1">// TODO: Make sure that the result zero extends to the 64bit value.</span>
<span class="p">}</span>
<span class="p">}</span> <span class="c1">// end anon namespace</span>

<span class="cp">#ifdef DLINKER</span>
<span class="k">class</span> <span class="nc">Cpu0elSoPlt</span> <span class="p">{</span>
<span class="nl">private:</span>
  <span class="kt">uint32_t</span> <span class="n">funAddr</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
  <span class="kt">int</span> <span class="n">funAddrSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">public:</span>
  <span class="n">Cpu0elTargetLayout</span><span class="o">&lt;</span><span class="n">Cpu0elELFType</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">_cpu0Layout</span><span class="p">;</span>
  <span class="kt">void</span> <span class="nf">createFunAddr</span><span class="p">(</span><span class="n">Cpu0elTargetLayout</span><span class="o">&lt;</span><span class="n">Cpu0elELFType</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">cpu0Layout</span><span class="p">,</span> 
                     <span class="n">llvm</span><span class="o">::</span><span class="n">FileOutputBuffer</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">);</span>
  <span class="c1">// Return function index, 1: 1st function appear on section .text of .so.</span>
  <span class="c1">//   2: 2nd function ...</span>
  <span class="c1">// For example: 3 functions _Z2laii, _Z3fooii and _Z3barv. 1: is _Z2laii </span>
  <span class="c1">//   2 is _Z3fooii, 3: is _Z3barv.</span>
  <span class="kt">int</span> <span class="nf">getDynFunIndexByTargetAddr</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">fAddr</span><span class="p">);</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">Cpu0elSoPlt</span><span class="o">::</span><span class="n">createFunAddr</span><span class="p">(</span><span class="n">Cpu0elTargetLayout</span><span class="o">&lt;</span><span class="n">Cpu0elELFType</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">cpu0Layout</span><span class="p">,</span> 
                              <span class="n">llvm</span><span class="o">::</span><span class="n">FileOutputBuffer</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">dynsymSection</span> <span class="o">=</span> <span class="n">cpu0Layout</span><span class="o">-&gt;</span>
                       <span class="n">findOutputSection</span><span class="p">(</span><span class="s">&quot;.dynsym&quot;</span><span class="p">);</span>
  <span class="kt">uint64_t</span> <span class="n">dynsymFileOffset</span><span class="p">,</span> <span class="n">dynsymSize</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">dynsymSection</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">dynsymFileOffset</span> <span class="o">=</span> <span class="n">dynsymSection</span><span class="o">-&gt;</span><span class="n">fileOffset</span><span class="p">();</span>
    <span class="n">dynsymSize</span> <span class="o">=</span> <span class="n">dynsymSection</span><span class="o">-&gt;</span><span class="n">memSize</span><span class="p">();</span>
    <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">atomContent</span> <span class="o">=</span> <span class="n">buf</span><span class="p">.</span><span class="n">getBufferStart</span><span class="p">()</span> <span class="o">+</span> <span class="n">dynsymFileOffset</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">uint64_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dynsymSize</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">16</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">funAddr</span><span class="p">[</span><span class="n">funAddrSize</span><span class="p">]</span> <span class="o">=</span> 
        <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">llvm</span><span class="o">::</span><span class="n">support</span><span class="o">::</span><span class="kt">ubig32_t</span><span class="o">*&gt;</span><span class="p">((</span><span class="kt">uint32_t</span><span class="o">*</span><span class="p">)</span>
        <span class="p">(</span><span class="n">atomContent</span> <span class="o">+</span> <span class="n">i</span><span class="p">));</span>
      <span class="n">funAddrSize</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">Cpu0elSoPlt</span><span class="o">::</span><span class="n">getDynFunIndexByTargetAddr</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">fAddr</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">funAddrSize</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Below statement fix the issue that both __tls_get_addr and first </span>
    <span class="c1">// function has the same file offset 0 issue.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">funAddrSize</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">funAddr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">funAddr</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
      <span class="k">continue</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">fAddr</span> <span class="o">==</span> <span class="n">funAddr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Cpu0elSoPlt</span> <span class="n">cpu0elSoPlt</span><span class="p">;</span>
<span class="cp">#endif </span><span class="c1">// DLINKER</span>

<span class="n">std</span><span class="o">::</span><span class="n">error_code</span> <span class="n">Cpu0elTargetRelocationHandler</span><span class="o">::</span><span class="n">applyRelocation</span><span class="p">(</span>
    <span class="n">ELFWriter</span> <span class="o">&amp;</span><span class="n">writer</span><span class="p">,</span> <span class="n">llvm</span><span class="o">::</span><span class="n">FileOutputBuffer</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="n">lld</span><span class="o">::</span><span class="n">AtomLayout</span> <span class="o">&amp;</span><span class="n">atom</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">Reference</span> <span class="o">&amp;</span><span class="n">ref</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
<span class="cp">#ifdef DLINKER</span>
  <span class="k">static</span> <span class="kt">bool</span> <span class="n">firstTime</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">soName</span><span class="p">(</span><span class="s">&quot;libfoobar.cpu0.so&quot;</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">firstTime</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">_context</span><span class="p">.</span><span class="n">getOutputELFType</span><span class="p">()</span> <span class="o">==</span> <span class="n">llvm</span><span class="o">::</span><span class="n">ELF</span><span class="o">::</span><span class="n">ET_DYN</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">cpu0elSoPlt</span><span class="p">.</span><span class="n">createFunAddr</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">_cpu0Layout</span><span class="p">),</span> <span class="n">buf</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">_context</span><span class="p">.</span><span class="n">getOutputELFType</span><span class="p">()</span> <span class="o">==</span> <span class="n">llvm</span><span class="o">::</span><span class="n">ELF</span><span class="o">::</span><span class="n">ET_EXEC</span> <span class="o">&amp;&amp;</span> 
             <span class="o">!</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">_context</span><span class="p">.</span><span class="n">isStaticExecutable</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">cpu0elSoPlt</span><span class="p">.</span><span class="n">createFunAddr</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">_cpu0Layout</span><span class="p">),</span> <span class="n">buf</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">firstTime</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>
<span class="cp">#endif </span><span class="c1">// DLINKER</span>
  <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">atomContent</span> <span class="o">=</span> <span class="n">buf</span><span class="p">.</span><span class="n">getBufferStart</span><span class="p">()</span> <span class="o">+</span> <span class="n">atom</span><span class="p">.</span><span class="n">_fileOffset</span><span class="p">;</span>
  <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">location</span> <span class="o">=</span> <span class="n">atomContent</span> <span class="o">+</span> <span class="n">ref</span><span class="p">.</span><span class="n">offsetInAtom</span><span class="p">();</span>
  <span class="kt">uint64_t</span> <span class="n">targetVAddress</span> <span class="o">=</span> <span class="n">writer</span><span class="p">.</span><span class="n">addressOfAtom</span><span class="p">(</span><span class="n">ref</span><span class="p">.</span><span class="n">target</span><span class="p">());</span>
  <span class="kt">uint64_t</span> <span class="n">relocVAddress</span> <span class="o">=</span> <span class="n">atom</span><span class="p">.</span><span class="n">_virtualAddr</span> <span class="o">+</span> <span class="n">ref</span><span class="p">.</span><span class="n">offsetInAtom</span><span class="p">();</span>
<span class="cp">#if 1 </span><span class="c1">// For case R_CPU0_GOT16:</span>
<span class="c1">//  auto gotAtomIter = _context.getTargetHandler&lt;Cpu0elELFType&gt;().targetLayout().</span>
<span class="c1">//                     findAbsoluteAtom(&quot;_GLOBAL_OFFSET_TABLE_&quot;);</span>
<span class="c1">//  uint64_t globalOffsetTableAddress = writer.addressOfAtom(*gotAtomIter);</span>
<span class="c1">// .got.plt start from _GLOBAL_OFFSET_TABLE_</span>
  <span class="k">auto</span> <span class="n">gotpltSection</span> <span class="o">=</span> <span class="n">_cpu0Layout</span><span class="p">.</span><span class="n">findOutputSection</span><span class="p">(</span><span class="s">&quot;.got.plt&quot;</span><span class="p">);</span>
  <span class="kt">uint64_t</span> <span class="n">gotPltFileOffset</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">gotpltSection</span><span class="p">)</span>
    <span class="n">gotPltFileOffset</span> <span class="o">=</span> <span class="n">gotpltSection</span><span class="o">-&gt;</span><span class="n">fileOffset</span><span class="p">();</span>
  <span class="k">else</span>
    <span class="n">gotPltFileOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">ref</span><span class="p">.</span><span class="n">kindNamespace</span><span class="p">()</span> <span class="o">!=</span> <span class="n">Reference</span><span class="o">::</span><span class="n">KindNamespace</span><span class="o">::</span><span class="n">ELF</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">error_code</span><span class="p">();</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">ref</span><span class="p">.</span><span class="n">kindArch</span><span class="p">()</span> <span class="o">==</span> <span class="n">Reference</span><span class="o">::</span><span class="n">KindArch</span><span class="o">::</span><span class="n">Cpu0</span><span class="p">);</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">ref</span><span class="p">.</span><span class="n">kindValue</span><span class="p">())</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">R_CPU0_NONE</span>:
    <span class="k">break</span><span class="p">;</span>

  <span class="k">case</span> <span class="n">R_CPU0_HI16</span>:
    <span class="n">relocHI16</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">relocVAddress</span><span class="p">,</span> <span class="n">targetVAddress</span><span class="p">,</span> <span class="n">ref</span><span class="p">.</span><span class="n">addend</span><span class="p">());</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">R_CPU0_LO16</span>:
    <span class="n">relocLO16</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">relocVAddress</span><span class="p">,</span> <span class="n">targetVAddress</span><span class="p">,</span> <span class="n">ref</span><span class="p">.</span><span class="n">addend</span><span class="p">());</span>
    <span class="k">break</span><span class="p">;</span>
<span class="cp">#if 0</span><span class="c"> // Not support yet</span>
<span class="c">  case R_CPU0_GOT16:</span>
<span class="cp">#if 1</span>
<span class="c">    idx = cpu0elSoPlt.getDynFunIndexByTargetAddr(targetVAddress);</span>
<span class="c">    relocGOT16(location, relocVAddress, idx, ref.addend());</span>
<span class="cp">#else</span>
<span class="c">    relocGOT16(location, relocVAddress, (targetVAddress - gotPltFileOffset), </span>
<span class="c">               ref.addend());</span>
<span class="cp">#endif</span>
    <span class="k">break</span><span class="p">;</span>
<span class="cp">#endif</span>
  <span class="k">case</span> <span class="n">R_CPU0_PC24</span>:
    <span class="n">relocPC24</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">relocVAddress</span><span class="p">,</span> <span class="n">targetVAddress</span><span class="p">,</span> <span class="n">ref</span><span class="p">.</span><span class="n">addend</span><span class="p">());</span>
    <span class="k">break</span><span class="p">;</span>
<span class="cp">#ifdef DLINKER</span>
  <span class="k">case</span> <span class="n">R_CPU0_CALL16</span>:
  <span class="c1">// offset at _GLOBAL_OFFSET_TABLE_ and $gp point to _GLOBAL_OFFSET_TABLE_.</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">cpu0elSoPlt</span><span class="p">.</span><span class="n">getDynFunIndexByTargetAddr</span><span class="p">(</span><span class="n">targetVAddress</span><span class="p">);</span>
    <span class="n">reloc32</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">relocVAddress</span><span class="p">,</span> <span class="n">idx</span><span class="o">*</span><span class="mh">0x04</span><span class="o">+</span><span class="mi">16</span><span class="p">,</span> <span class="n">ref</span><span class="p">.</span><span class="n">addend</span><span class="p">());</span>
    <span class="k">break</span><span class="p">;</span>
<span class="cp">#endif </span><span class="c1">// DLINKER</span>
  <span class="k">case</span> <span class="n">R_CPU0_32</span>:
    <span class="n">reloc32</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">relocVAddress</span><span class="p">,</span> <span class="n">targetVAddress</span><span class="p">,</span> <span class="n">ref</span><span class="p">.</span><span class="n">addend</span><span class="p">());</span>
    <span class="k">break</span><span class="p">;</span>

  <span class="c1">// Runtime only relocations. Ignore here.</span>
  <span class="k">case</span> <span class="n">R_CPU0_JUMP_SLOT</span>:
  <span class="k">case</span> <span class="n">R_CPU0_GLOB_DAT</span>:
    <span class="k">break</span><span class="p">;</span>
  <span class="nl">default:</span>
    <span class="n">unhandledReferenceType</span><span class="p">(</span><span class="o">*</span><span class="n">atom</span><span class="p">.</span><span class="n">_atom</span><span class="p">,</span> <span class="n">ref</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">error_code</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">exlbt/lld/Cpu0el/Cpu0RelocationPass.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===- lib/ReaderWriter/ELF/Cpu0/Cpu0RelocationPass.h -----------------===//</span>
<span class="c1">//</span>
<span class="c1">//                             The LLVM Linker</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">///</span>
<span class="c1">/// \file</span>
<span class="c1">/// \brief Declares the relocation processing pass for Cpu0. This includes</span>
<span class="c1">///   GOT and PLT entries, TLS, COPY, and ifunc.</span>
<span class="c1">///</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#ifndef LLD_READER_WRITER_ELF_CPU0EL_CPU0EL_RELOCATION_PASS_H</span>
<span class="cp">#define LLD_READER_WRITER_ELF_CPU0EL_CPU0EL_RELOCATION_PASS_H</span>

<span class="cp">#include &lt;memory&gt;</span>

<span class="k">namespace</span> <span class="n">lld</span> <span class="p">{</span>
<span class="k">class</span> <span class="nc">Pass</span><span class="p">;</span>
<span class="k">namespace</span> <span class="n">elf</span> <span class="p">{</span>
<span class="k">class</span> <span class="nc">Cpu0elLinkingContext</span><span class="p">;</span>

<span class="c1">/// \brief Create Cpu0 relocation pass for the given linking context.</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Pass</span><span class="o">&gt;</span>
<span class="n">createCpu0RelocationPass</span><span class="p">(</span><span class="k">const</span> <span class="n">Cpu0elLinkingContext</span> <span class="o">&amp;</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#endif</span>
</pre></div>
</div>
<p class="rubric">exlbt/lld/Cpu0el/Cpu0RelocationPass.cpp</p>
<div class="highlight-c++"><pre>//===- lib/ReaderWriter/ELF/Cpu0/Cpu0RelocationPass.cpp ---------------===//
//
//                             The LLVM Linker
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
///
/// \file
/// \brief Defines the relocation processing pass for Cpu0. This includes
///   GOT and PLT entries, TLS, COPY, and ifunc.
///
/// This is based on section 4.4.1 of the AMD64 ABI (no stable URL as of Oct,
/// 2013).
///
/// This also includes aditional behaivor that gnu-ld and gold implement but
/// which is not specified anywhere.
///
//===----------------------------------------------------------------------===//

#include "Atoms.h"
#include "Cpu0RelocationPass.h"
#include "Cpu0LinkingContext.h"

#include "lld/Core/Simple.h"

#include "llvm/ADT/DenseMap.h"


using namespace lld;
using namespace lld::elf;
using namespace llvm::ELF;

namespace {
// .plt value (entry 0)
const uint8_t cpu0BootAtomContent[16] = {
  0xfc, 0xff, 0xff, 0x36, // jmp start
  0x04, 0x00, 0x00, 0x36, // jmp 4
  0xfc, 0xff, 0xff, 0x36, // jmp ISR
  0xfc, 0xff, 0xff, 0x36 // jmp -4
};

#ifdef DLINKER
// .got values
const uint8_t cpu0GotAtomContent[16] = { 0 };

// .plt value (entry 0)
const uint8_t cpu0Plt0AtomContent[16] = {
  0x04, 0x00, 0xeb, 0x02, // st $lr, $zero, reloc-index ($gp)
  0x08, 0x00, 0xcb, 0x02, // st $fp, $zero, reloc-index ($gp)
  0x0c, 0x00, 0xdb, 0x02, // st $sp, $zero, reloc-index ($gp)
  0xfc, 0xff, 0xff, 0x36  // jmp dynamic_linker
};

// .plt values (other entries)
const uint8_t cpu0PltAtomContent[16] = {
  0x10, 0x00, 0x6b, 0x01, // ld $t9, 0x10($gp) (0x10($gp) point to plt0
  0x00, 0x00, 0x60, 0x3c, // ret $t9 // jump to Cpu0.Stub
  0x00, 0x00, 0x00, 0x00, // nop
  0x00, 0x00, 0x00, 0x00  // nop
};
#endif // DLINKER

/// boot record
class Cpu0BootAtom : public PLT0Atom {
public:
  Cpu0BootAtom(const File &amp;f) : PLT0Atom(f) {
#ifndef NDEBUG
    _name = ".PLT0";
#endif
  }
  virtual ArrayRef&lt;uint8_t&gt; rawContent() const {
    return ArrayRef&lt;uint8_t&gt;(cpu0BootAtomContent, 16);
  }
};

#ifdef DLINKER
/// \brief Atoms that are used by Cpu0 dynamic linking
class Cpu0GOTAtom : public GOTAtom {
public:
  Cpu0GOTAtom(const File &amp;f, StringRef secName) : GOTAtom(f, secName) {}

  ArrayRef&lt;uint8_t&gt; rawContent() const override {
    return ArrayRef&lt;uint8_t&gt;(cpu0GotAtomContent, 16);
  }
};

class Cpu0PLT0Atom : public PLT0Atom {
public:
  Cpu0PLT0Atom(const File &amp;f) : PLT0Atom(f) {
#ifndef NDEBUG
    _name = ".PLT0";
#endif
  }
  ArrayRef&lt;uint8_t&gt; rawContent() const override {
    return ArrayRef&lt;uint8_t&gt;(cpu0Plt0AtomContent, 16);
  }
};

class Cpu0PLTAtom : public PLTAtom {
public:
  Cpu0PLTAtom(const File &amp;f, StringRef secName) : PLTAtom(f, secName) {}

  ArrayRef&lt;uint8_t&gt; rawContent() const override {
    return ArrayRef&lt;uint8_t&gt;(cpu0PltAtomContent, 16);
  }
};
#endif // DLINKER

class ELFPassFile : public SimpleFile {
public:
  ELFPassFile(const ELFLinkingContext &amp;eti) : SimpleFile("ELFPassFile") {
    setOrdinal(eti.getNextOrdinalAndIncrement());
  }

  llvm::BumpPtrAllocator _alloc;
};

/// \brief CRTP base for handling relocations.
template &lt;class Derived&gt; class RelocationPass : public Pass {
  /// \brief Handle a specific reference.
  void handleReference(const DefinedAtom &amp;atom, const Reference &amp;ref) {
    if (ref.kindNamespace() != Reference::KindNamespace::ELF)
      return;
    assert(ref.kindArch() == Reference::KindArch::Cpu0);
    switch (ref.kindValue()) {
    case R_CPU0_CALL16:
      static_cast&lt;Derived *&gt;(this)-&gt;handlePLT32(ref);
      break;

    case R_CPU0_PC24:
      static_cast&lt;Derived *&gt;(this)-&gt;handlePlain(ref);
      break;
    }
  }

protected:
#ifdef DLINKER
  /// \brief get the PLT entry for a given IFUNC Atom.
  ///
  /// If the entry does not exist. Both the GOT and PLT entry is created.
  const PLTAtom *getIFUNCPLTEntry(const DefinedAtom *da) {
    auto plt = _pltMap.find(da);
    if (plt != _pltMap.end())
      return plt-&gt;second;
    auto ga = new (_file._alloc) Cpu0GOTAtom(_file, ".got.plt");
    ga-&gt;addReferenceELF_Cpu0(R_CPU0_RELGOT, 0, da, 0);
    auto pa = new (_file._alloc) Cpu0PLTAtom(_file, ".plt");
    pa-&gt;addReferenceELF_Cpu0(R_CPU0_PC24, 2, ga, -4);
#ifndef NDEBUG
    ga-&gt;_name = "__got_ifunc_";
    ga-&gt;_name += da-&gt;name();
    pa-&gt;_name = "__plt_ifunc_";
    pa-&gt;_name += da-&gt;name();
#endif
    _gotMap[da] = ga;
    _pltMap[da] = pa;
    _gotVector.push_back(ga);
    _pltVector.push_back(pa);
    return pa;
  }
#endif // DLINKER

  /// \brief Redirect the call to the PLT stub for the target IFUNC.
  ///
  /// This create a PLT and GOT entry for the IFUNC if one does not exist. The
  /// GOT entry and a IRELATIVE relocation to the original target resolver.
  std::error_code handleIFUNC(const Reference &amp;ref) {
    auto target = dyn_cast_or_null&lt;const DefinedAtom&gt;(ref.target());
#ifdef DLINKER
    if (target &amp;&amp; target-&gt;contentType() == DefinedAtom::typeResolver)
      const_cast&lt;Reference &amp;&gt;(ref).setTarget(getIFUNCPLTEntry(target));
#endif // DLINKER
    return std::error_code();
  }

  /// \brief Create a GOT entry for the TP offset of a TLS atom.
  const GOTAtom *getGOTTPOFF(const Atom *atom) {
    auto got = _gotMap.find(atom);
    if (got == _gotMap.end()) {
      auto g = new (_file._alloc) Cpu0GOTAtom(_file, ".got");
      g-&gt;addReferenceELF_Cpu0(R_CPU0_TLS_TPREL32, 0, atom, 0);
#ifndef NDEBUG
      g-&gt;_name = "__got_tls_";
      g-&gt;_name += atom-&gt;name();
#endif
      _gotMap[atom] = g;
      _gotVector.push_back(g);
      return g;
    }
    return got-&gt;second;
  }

  /// \brief Create a GOT entry containing 0.
  const GOTAtom *getNullGOT() {
    if (!_null) {
      _null = new (_file._alloc) Cpu0GOTAtom(_file, ".got.plt");
#ifndef NDEBUG
      _null-&gt;_name = "__got_null";
#endif
    }
    return _null;
  }

  const GOTAtom *getGOT(const DefinedAtom *da) {
    auto got = _gotMap.find(da);
    if (got == _gotMap.end()) {
      auto g = new (_file._alloc) Cpu0GOTAtom(_file, ".got");
      g-&gt;addReferenceELF_Cpu0(R_CPU0_32, 0, da, 0);
#ifndef NDEBUG
      g-&gt;_name = "__got_";
      g-&gt;_name += da-&gt;name();
#endif
      _gotMap[da] = g;
      _gotVector.push_back(g);
      return g;
    }
    return got-&gt;second;
  }

public:
  RelocationPass(const ELFLinkingContext &amp;ctx)
      : _file(ctx), _ctx(ctx), _null(nullptr), _PLT0(nullptr), _got0(nullptr), 
        _boot(new Cpu0BootAtom(_file)) {}

  /// \brief Do the pass.
  ///
  /// The goal here is to first process each reference individually. Each call
  /// to handleReference may modify the reference itself and/or create new
  /// atoms which must be stored in one of the maps below.
  ///
  /// After all references are handled, the atoms created during that are all
  /// added to mf.
  void perform(std::unique_ptr&lt;MutableFile&gt; &amp;mf) override {
    ScopedTask task(getDefaultDomain(), "Cpu0 GOT/PLT Pass");
    // Process all references.
    for (const auto &amp;atom : mf-&gt;defined())
      for (const auto &amp;ref : *atom)
        handleReference(*atom, *ref);

    // Add all created atoms to the link.
    uint64_t ordinal = 0;
    if (_ctx.getOutputELFType() == llvm::ELF::ET_EXEC) {
      MutableFile::DefinedAtomRange atomRange = mf-&gt;definedAtoms();
      auto it = atomRange.begin();
      bool find = false;
      for (it = atomRange.begin(); it &lt; atomRange.end(); it++) {
        if ((*it)-&gt;name() == "start") {
          find = true;
          break;
        }
      }
      assert(find &amp;&amp; "not found start\n");
      _boot-&gt;addReferenceELF_Cpu0(R_CPU0_PC24, 0, *it, -3);
      find = false;
      for (it = atomRange.begin(); it &lt; atomRange.end(); it++) {
        if ((*it)-&gt;name() == "ISR") {
          find = true;
          break;
        }
      }
      assert(find &amp;&amp; "not found ISR\n");
      _boot-&gt;addReferenceELF_Cpu0(R_CPU0_PC24, 8, *it, -3);
      _boot-&gt;setOrdinal(ordinal++);
      mf-&gt;addAtom(*_boot);
    }
#ifdef DLINKER
    if (_PLT0) {
      MutableFile::DefinedAtomRange atomRange = mf-&gt;definedAtoms();
      auto it = atomRange.begin();
      bool find = false;
      for (it = atomRange.begin(); it &lt; atomRange.end(); it++) {
        if ((*it)-&gt;name() == "_Z14dynamic_linkerv") {
          find = true;
          break;
        }
      }
      assert(find &amp;&amp; "Cannot find _Z14dynamic_linkerv()");
      _PLT0-&gt;addReferenceELF_Cpu0(R_CPU0_PC24, 12, *it, -3);
      _PLT0-&gt;setOrdinal(ordinal++);
      mf-&gt;addAtom(*_PLT0);
    }
    for (auto &amp;plt : _pltVector) {
      plt-&gt;setOrdinal(ordinal++);
      mf-&gt;addAtom(*plt);
    }
    if (_null) {
      _null-&gt;setOrdinal(ordinal++);
      mf-&gt;addAtom(*_null);
    }
    if (_PLT0) {
      _got0-&gt;setOrdinal(ordinal++);
      mf-&gt;addAtom(*_got0);
    }
    for (auto &amp;got : _gotVector) {
      got-&gt;setOrdinal(ordinal++);
      mf-&gt;addAtom(*got);
    }
    for (auto obj : _objectVector) {
      obj-&gt;setOrdinal(ordinal++);
      mf-&gt;addAtom(*obj);
    }
#endif // DLINKER
  }

protected:
  /// \brief Owner of all the Atoms created by this pass.
  ELFPassFile _file;
  const ELFLinkingContext &amp;_ctx;

  /// \brief Map Atoms to their GOT entries.
  llvm::DenseMap&lt;const Atom *, GOTAtom *&gt; _gotMap;

  /// \brief Map Atoms to their PLT entries.
  llvm::DenseMap&lt;const Atom *, PLTAtom *&gt; _pltMap;

  /// \brief Map Atoms to their Object entries.
  llvm::DenseMap&lt;const Atom *, ObjectAtom *&gt; _objectMap;

  /// \brief the list of GOT/PLT atoms
  std::vector&lt;GOTAtom *&gt; _gotVector;
  std::vector&lt;PLTAtom *&gt; _pltVector;
  std::vector&lt;ObjectAtom *&gt; _objectVector;
  PLT0Atom *_boot;

  /// \brief GOT entry that is always 0. Used for undefined weaks.
  GOTAtom *_null;

  /// \brief The got and plt entries for .PLT0. This is used to call into the
  /// dynamic linker for symbol resolution.
  /// @{
  PLT0Atom *_PLT0;
  GOTAtom *_got0;
  /// @}
};

/// This implements the static relocation model. Meaning GOT and PLT entries are
/// not created for references that can be directly resolved. These are
/// converted to a direct relocation. For entries that do require a GOT or PLT
/// entry, that entry is statically bound.
///
/// TLS always assumes module 1 and attempts to remove indirection.
class StaticRelocationPass final
    : public RelocationPass&lt;StaticRelocationPass&gt; {
public:
  StaticRelocationPass(const elf::Cpu0elLinkingContext &amp;ctx)
      : RelocationPass(ctx) {}

  std::error_code handlePlain(const Reference &amp;ref) { return handleIFUNC(ref); }

  std::error_code handlePLT32(const Reference &amp;ref) {
    // __tls_get_addr is handled elsewhere.
    if (ref.target() &amp;&amp; ref.target()-&gt;name() == "__tls_get_addr") {
      const_cast&lt;Reference &amp;&gt;(ref).setKindValue(R_CPU0_NONE);
      return std::error_code();
    }
    // Static code doesn't need PLTs.
    const_cast&lt;Reference &amp;&gt;(ref).setKindValue(R_CPU0_PC24);
    // Handle IFUNC.
    if (const DefinedAtom *da =
            dyn_cast_or_null&lt;const DefinedAtom&gt;(ref.target()))
      if (da-&gt;contentType() == DefinedAtom::typeResolver)
        return handleIFUNC(ref);
    return std::error_code();
  }

  std::error_code handleGOT(const Reference &amp;ref) {
    if (isa&lt;UndefinedAtom&gt;(ref.target()))
      const_cast&lt;Reference &amp;&gt;(ref).setTarget(getNullGOT());
    else if (const DefinedAtom *da = dyn_cast&lt;const DefinedAtom&gt;(ref.target()))
      const_cast&lt;Reference &amp;&gt;(ref).setTarget(getGOT(da));
    return std::error_code();
  }
};

#ifdef DLINKER
class DynamicRelocationPass final
    : public RelocationPass&lt;DynamicRelocationPass&gt; {
public:
  DynamicRelocationPass(const elf::Cpu0elLinkingContext &amp;ctx)
      : RelocationPass(ctx) {}

  const PLT0Atom *getPLT0() {
    if (_PLT0)
      return _PLT0;
    // Fill in the null entry.
    getNullGOT();
    _PLT0 = new (_file._alloc) Cpu0PLT0Atom(_file);
    _got0 = new (_file._alloc) Cpu0GOTAtom(_file, ".got.plt");
#ifndef NDEBUG
    _got0-&gt;_name = "__got0";
#endif
    return _PLT0;
  }

  const PLTAtom *getPLTEntry(const Atom *a) {
    auto plt = _pltMap.find(a);
    if (plt != _pltMap.end())
      return plt-&gt;second;
    auto ga = new (_file._alloc) Cpu0GOTAtom(_file, ".got.plt");
    ga-&gt;addReferenceELF_Cpu0(R_CPU0_JUMP_SLOT, 0, a, 0);
    auto pa = new (_file._alloc) Cpu0PLTAtom(_file, ".plt");
    getPLT0();  // add _PLT0 and _got0

    // Set the starting address of the got entry to the second instruction in
    // the plt entry.
    ga-&gt;addReferenceELF_Cpu0(R_CPU0_32, 0, pa, 4);
#ifndef NDEBUG
    ga-&gt;_name = "__got_";
    ga-&gt;_name += a-&gt;name();
    pa-&gt;_name = "__plt_";
    pa-&gt;_name += a-&gt;name();
#endif
    _gotMap[a] = ga;
    _pltMap[a] = pa;
    _gotVector.push_back(ga);
    _pltVector.push_back(pa);
    return pa;
  }

#if 0 // Not support at this point
  const ObjectAtom *getObjectEntry(const SharedLibraryAtom *a) {
    auto obj = _objectMap.find(a);
    if (obj != _objectMap.end())
      return obj-&gt;second;

    auto oa = new (_file._alloc) ObjectAtom(_file);
    // This needs to point to the atom that we just created.
    oa-&gt;addReferenceELF_Cpu0(R_Cpu0_COPY, 0, oa, 0);

    oa-&gt;_name = a-&gt;name();
    oa-&gt;_size = a-&gt;size();

    _objectMap[a] = oa;
    _objectVector.push_back(oa);
    return oa;
  }
#endif

  std::error_code handlePlain(const Reference &amp;ref) {
    if (!ref.target())
      return std::error_code();
    if (auto sla = dyn_cast&lt;SharedLibraryAtom&gt;(ref.target())) {
#if 0 // Not support at this point
      if (sla-&gt;type() == SharedLibraryAtom::Type::Data)
        const_cast&lt;Reference &amp;&gt;(ref).setTarget(getObjectEntry(sla));
      else 
#endif
      if (sla-&gt;type() == SharedLibraryAtom::Type::Code)
        const_cast&lt;Reference &amp;&gt;(ref).setTarget(getPLTEntry(sla));
    } else
      return handleIFUNC(ref);
    return std::error_code();
  }

  std::error_code handlePLT32(const Reference &amp;ref) {
    // Handle IFUNC.
    if (const DefinedAtom *da =
            dyn_cast_or_null&lt;const DefinedAtom&gt;(ref.target()))
      if (da-&gt;contentType() == DefinedAtom::typeResolver)
        return handleIFUNC(ref);
    if (isa&lt;const SharedLibraryAtom&gt;(ref.target())) {
      const_cast&lt;Reference &amp;&gt;(ref).setTarget(getPLTEntry(ref.target()));
      // Turn this into a PC24 to the PLT entry.
    #if 1
      const_cast&lt;Reference &amp;&gt;(ref).setKindValue(R_CPU0_PC24);
    #endif
    }
    return std::error_code();
  }

  const GOTAtom *getSharedGOT(const Atom *a) {
    auto got = _gotMap.find(a);
    if (got == _gotMap.end()) {
      auto g = new (_file._alloc) Cpu0GOTAtom(_file, ".got.dyn");
      g-&gt;addReferenceELF_Cpu0(R_CPU0_GLOB_DAT, 0, a, 0);
#ifndef NDEBUG
      g-&gt;_name = "__got_";
      g-&gt;_name += a-&gt;name();
#endif
      _gotMap[a] = g;
      _gotVector.push_back(g);
      return g;
    }
    return got-&gt;second;
  }

  std::error_code handleGOT(const Reference &amp;ref) {
    if (const DefinedAtom *da = dyn_cast&lt;const DefinedAtom&gt;(ref.target()))
      const_cast&lt;Reference &amp;&gt;(ref).setTarget(getGOT(da));
    // Handle undefined atoms in the same way as shared lib atoms: to be
    // resolved at run time.
    else if (isa&lt;SharedLibraryAtom&gt;(ref.target()) ||
             isa&lt;UndefinedAtom&gt;(ref.target()))
      const_cast&lt;Reference &amp;&gt;(ref).setTarget(getSharedGOT(ref.target()));
    return std::error_code();
  }
};
#endif // DLINKER
} // end anon namespace

std::unique_ptr&lt;Pass&gt;
lld::elf::createCpu0RelocationPass(const Cpu0elLinkingContext &amp;ctx) {
  switch (ctx.getOutputELFType()) {
  case llvm::ELF::ET_EXEC:
  // when the output file is execution file: e.g. a.out
#ifdef DLINKER
    if (ctx.isDynamic())
    // when the a.out refer to shared object *.so
      return std::unique_ptr&lt;Pass&gt;(new DynamicRelocationPass(ctx));
    else
#endif // DLINKER
      return std::unique_ptr&lt;Pass&gt;(new StaticRelocationPass(ctx));
#ifdef DLINKER
  case llvm::ELF::ET_DYN:
  // when the output file is shared object: e.g. foobar.so
    return std::unique_ptr&lt;Pass&gt;(new DynamicRelocationPass(ctx));
#endif // DLINKER
  case llvm::ELF::ET_REL:
    return std::unique_ptr&lt;Pass&gt;();
  default:
    llvm_unreachable("Unhandled output file type");
  }
}
</pre>
</div>
<p class="rubric">exlbt/lld/Cpu0el/Cpu0LinkingContext.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===- lib/ReaderWriter/ELF/Cpu0/Cpu0LinkingContext.cpp ---------------===//</span>
<span class="c1">//</span>
<span class="c1">//                             The LLVM Linker</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#include &quot;Cpu0LinkingContext.h&quot;</span>
<span class="cp">#include &quot;Cpu0RelocationPass.h&quot;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">lld</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">elf</span><span class="o">::</span><span class="n">Cpu0elLinkingContext</span><span class="o">::</span><span class="n">addPasses</span><span class="p">(</span><span class="n">PassManager</span> <span class="o">&amp;</span><span class="n">pm</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">pass</span> <span class="o">=</span> <span class="n">createCpu0RelocationPass</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">pass</span><span class="p">)</span>
    <span class="n">pm</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">pass</span><span class="p">));</span>
  <span class="n">ELFLinkingContext</span><span class="o">::</span><span class="n">addPasses</span><span class="p">(</span><span class="n">pm</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">exlbt/lld/Cpu0el/Cpu0Target.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===- lib/ReaderWriter/ELF/Cpu0/Cpu0Target.h -------------------------===//</span>
<span class="c1">//</span>
<span class="c1">//                             The LLVM Linker</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#include &quot;Cpu0LinkingContext.h&quot;</span>
</pre></div>
</div>
<p class="rubric">exlbt/lld/Cpu0el/Cpu0TargetHandler.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===- lib/ReaderWriter/ELF/Cpu0/Cpu0TargetHandler.h ------------------===//</span>
<span class="c1">//</span>
<span class="c1">//                             The LLVM Linker</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#ifndef LLD_READER_WRITER_ELF_CPU0EL_CPU0EL_TARGET_HANDLER_H</span>
<span class="cp">#define LLD_READER_WRITER_ELF_CPU0EL_CPU0EL_TARGET_HANDLER_H</span>

<span class="cp">#include &quot;Cpu0ELFFile.h&quot;</span>
<span class="cp">#include &quot;Cpu0ELFReader.h&quot;</span>
<span class="cp">#include &quot;Cpu0RelocationHandler.h&quot;</span>
<span class="cp">#include &quot;DefaultTargetHandler.h&quot;</span>
<span class="cp">#include &quot;TargetLayout.h&quot;</span>

<span class="cp">#include &quot;lld/Core/Simple.h&quot;</span>

<span class="cp">#define DLINKER</span>

<span class="k">namespace</span> <span class="n">lld</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">elf</span> <span class="p">{</span>
<span class="k">typedef</span> <span class="n">llvm</span><span class="o">::</span><span class="n">object</span><span class="o">::</span><span class="n">ELFType</span><span class="o">&lt;</span><span class="n">llvm</span><span class="o">::</span><span class="n">support</span><span class="o">::</span><span class="n">little</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">false</span><span class="o">&gt;</span> <span class="n">Cpu0elELFType</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">Cpu0elLinkingContext</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ELFT</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Cpu0elTargetLayout</span> <span class="o">:</span> <span class="k">public</span> <span class="n">TargetLayout</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Cpu0elTargetLayout</span><span class="p">(</span><span class="n">Cpu0elLinkingContext</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">TargetLayout</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;</span><span class="p">(</span><span class="n">context</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Cpu0elTargetHandler</span> <span class="n">final</span>
    <span class="o">:</span> <span class="k">public</span> <span class="n">DefaultTargetHandler</span><span class="o">&lt;</span><span class="n">Cpu0elELFType</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Cpu0elTargetHandler</span><span class="p">(</span><span class="n">Cpu0elLinkingContext</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">);</span>

  <span class="n">Cpu0elTargetLayout</span><span class="o">&lt;</span><span class="n">Cpu0elELFType</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">getTargetLayout</span><span class="p">()</span> <span class="n">override</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="n">_cpu0TargetLayout</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">registerRelocationNames</span><span class="p">(</span><span class="n">Registry</span> <span class="o">&amp;</span><span class="n">registry</span><span class="p">)</span> <span class="n">override</span><span class="p">;</span>

  <span class="k">const</span> <span class="n">Cpu0elTargetRelocationHandler</span> <span class="o">&amp;</span><span class="n">getRelocationHandler</span><span class="p">()</span> <span class="k">const</span> <span class="n">override</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="n">_cpu0RelocationHandler</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
  <span class="p">}</span>

  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Reader</span><span class="o">&gt;</span> <span class="n">getObjReader</span><span class="p">(</span><span class="kt">bool</span> <span class="n">atomizeStrings</span><span class="p">)</span> <span class="n">override</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Reader</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">Cpu0elELFObjectReader</span><span class="p">(</span><span class="n">atomizeStrings</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Reader</span><span class="o">&gt;</span> <span class="n">getDSOReader</span><span class="p">(</span><span class="kt">bool</span> <span class="n">useShlibUndefines</span><span class="p">)</span> <span class="n">override</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Reader</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">Cpu0elELFDSOReader</span><span class="p">(</span><span class="n">useShlibUndefines</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Writer</span><span class="o">&gt;</span> <span class="n">getWriter</span><span class="p">()</span> <span class="n">override</span><span class="p">;</span>

<span class="nl">private:</span>
  <span class="k">static</span> <span class="k">const</span> <span class="n">Registry</span><span class="o">::</span><span class="n">KindStrings</span> <span class="n">kindStrings</span><span class="p">[];</span>
  <span class="n">Cpu0elLinkingContext</span> <span class="o">&amp;</span><span class="n">_context</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Cpu0elTargetLayout</span><span class="o">&lt;</span><span class="n">Cpu0elELFType</span><span class="o">&gt;&gt;</span> <span class="n">_cpu0TargetLayout</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Cpu0elTargetRelocationHandler</span><span class="o">&gt;</span> <span class="n">_cpu0RelocationHandler</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">}</span> <span class="c1">// end namespace elf</span>
<span class="p">}</span> <span class="c1">// end namespace lld</span>

<span class="cp">#endif</span>
</pre></div>
</div>
<p class="rubric">exlbt/lld/Cpu0el/Cpu0TargetHandler.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===- lib/ReaderWriter/ELF/Cpu0/Cpu0TargetHandler.cpp ----------------===//</span>
<span class="c1">//</span>
<span class="c1">//                             The LLVM Linker</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#include &quot;Atoms.h&quot;</span>
<span class="cp">#include &quot;Cpu0DynamicLibraryWriter.h&quot;</span>
<span class="cp">#include &quot;Cpu0ExecutableWriter.h&quot;</span>
<span class="cp">#include &quot;Cpu0LinkingContext.h&quot;</span>
<span class="cp">#include &quot;Cpu0TargetHandler.h&quot;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">lld</span><span class="p">;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">elf</span><span class="p">;</span>

<span class="n">Cpu0TargetHandler</span><span class="o">::</span><span class="n">Cpu0TargetHandler</span><span class="p">(</span><span class="n">Cpu0LinkingContext</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">DefaultTargetHandler</span><span class="p">(</span><span class="n">context</span><span class="p">),</span> <span class="n">_context</span><span class="p">(</span><span class="n">context</span><span class="p">),</span>
      <span class="n">_cpu0TargetLayout</span><span class="p">(</span><span class="k">new</span> <span class="n">Cpu0TargetLayout</span><span class="o">&lt;</span><span class="n">Cpu0ELFType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">context</span><span class="p">)),</span>
      <span class="n">_cpu0RelocationHandler</span><span class="p">(</span>
          <span class="k">new</span> <span class="n">Cpu0TargetRelocationHandler</span><span class="p">(</span><span class="o">*</span><span class="n">_cpu0TargetLayout</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="n">context</span><span class="p">,</span> 
                                          <span class="n">context</span><span class="p">))</span> <span class="p">{}</span>

<span class="kt">void</span> <span class="n">Cpu0TargetHandler</span><span class="o">::</span><span class="n">registerRelocationNames</span><span class="p">(</span><span class="n">Registry</span> <span class="o">&amp;</span><span class="n">registry</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">registry</span><span class="p">.</span><span class="n">addKindTable</span><span class="p">(</span><span class="n">Reference</span><span class="o">::</span><span class="n">KindNamespace</span><span class="o">::</span><span class="n">ELF</span><span class="p">,</span>
                        <span class="n">Reference</span><span class="o">::</span><span class="n">KindArch</span><span class="o">::</span><span class="n">Cpu0</span><span class="p">,</span> <span class="n">kindStrings</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Writer</span><span class="o">&gt;</span> <span class="n">Cpu0TargetHandler</span><span class="o">::</span><span class="n">getWriter</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">_context</span><span class="p">.</span><span class="n">getOutputELFType</span><span class="p">())</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">llvm</span>:<span class="o">:</span><span class="n">ELF</span><span class="o">::</span><span class="n">ET_EXEC</span><span class="o">:</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Writer</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">Cpu0ExecutableWriter</span><span class="o">&lt;</span><span class="n">Cpu0ELFType</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="n">_context</span><span class="p">,</span> <span class="o">*</span><span class="n">_cpu0TargetLayout</span><span class="p">.</span><span class="n">get</span><span class="p">()));</span>
  <span class="k">case</span> <span class="n">llvm</span>:<span class="o">:</span><span class="n">ELF</span><span class="o">::</span><span class="n">ET_DYN</span><span class="o">:</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Writer</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="k">new</span> <span class="n">Cpu0DynamicLibraryWriter</span><span class="o">&lt;</span><span class="n">Cpu0ELFType</span><span class="o">&gt;</span><span class="p">(</span>
            <span class="n">_context</span><span class="p">,</span> <span class="o">*</span><span class="n">_cpu0TargetLayout</span><span class="p">.</span><span class="n">get</span><span class="p">()));</span>
  <span class="k">case</span> <span class="n">llvm</span>:<span class="o">:</span><span class="n">ELF</span><span class="o">::</span><span class="n">ET_REL</span><span class="o">:</span>
    <span class="n">llvm_unreachable</span><span class="p">(</span><span class="s">&quot;TODO: support -r mode&quot;</span><span class="p">);</span>
  <span class="nl">default:</span>
    <span class="n">llvm_unreachable</span><span class="p">(</span><span class="s">&quot;unsupported output type&quot;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="cp">#define ELF_RELOC(name, value) LLD_KIND_STRING_ENTRY(name),</span>

<span class="k">const</span> <span class="n">Registry</span><span class="o">::</span><span class="n">KindStrings</span> <span class="n">Cpu0TargetHandler</span><span class="o">::</span><span class="n">kindStrings</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
<span class="cp">#include &quot;llvm/Support/ELFRelocs/Cpu0.def&quot;</span>
  <span class="n">LLD_KIND_STRING_ENTRY</span><span class="p">(</span><span class="n">LLD_R_CPU0_GOTRELINDEX</span><span class="p">),</span>
  <span class="n">LLD_KIND_STRING_END</span>
<span class="p">};</span>

<span class="cp">#undef ELF_RELOC</span>
</pre></div>
</div>
<p>Above code in Cpu0 lld support both endian for static link and dynamic link.
The &#8220;#ifdef DLINKER&#8221; is for dynamic link support.
The directory Cpu0 is for big endian and Cpu0el is for little endian.
They are almost same. I believe the lld structure will change to support both
endian but at this point, the best way to do both endian support is duplicate
the directory.</p>
</div>
<div class="section" id="lld-introduction">
<h3><a class="toc-backref" href="#id40">LLD introduction</a><a class="headerlink" href="#lld-introduction" title="Permalink to this headline">¶</a></h3>
<p>In general, linker do the Relocation Records Resolve as Chapter ELF support
depicted, and optimization for those cannot finish in compiler stage. One of
the optimization opportunities in linker is Dead Code Stripping which is
explained in this section.</p>
<p>List the LLD project status as follows,</p>
<ul class="simple">
<li>The lld project aims to to be the built-in linker for clang/llvm.
Currently, clang must invoke the system linker to produce executables.</li>
<li>web site <a class="reference external" href="http://lld.llvm.org/">http://lld.llvm.org/</a></li>
<li>Current Status<ul>
<li>lld is in its early stages of development.</li>
<li>It can currently self host on Linux x86-64 with -static.</li>
</ul>
</li>
<li>How to build<ul>
<li>cmake -DCMAKE_CXX_COMPILER=g++ -DCMAKE_C_COMPILER=gcc -DCMAKE_CXX_FLAGS=-std
=c++11 -DCMAKE_BUILD_TYPE=Debug -G &#8220;Unix Makefiles&#8221; ../src/</li>
</ul>
</li>
</ul>
<p>This whole book focuses on backend design, and this chapter is same.
To help readers
understand the lld document, first we list the linking steps from lld web.
After that, explain each step with the class of source code and what kind of
Cpu0 backend implementation needed in each step.
Since some of the following come from our understanding,
please read the lld design web document first (only a few pages),
<a class="reference external" href="http://lld.llvm.org/design.html">http://lld.llvm.org/design.html</a>, then reading the following to
ensure you agree to our understanding.</p>
<div class="section" id="how-lld-do-the-linker-job">
<h4><a class="toc-backref" href="#id41">How LLD do the linker job</a><a class="headerlink" href="#how-lld-do-the-linker-job" title="Permalink to this headline">¶</a></h4>
<ul>
<li><p class="first">LLD structure</p>
<ul class="simple">
<li>Internal structure Atom<ul>
<li>Like llvm IR, lld operating and optimize in Atom.</li>
</ul>
</li>
<li>ELF reader/writer, Mach-O reader/writer, COFF<ul>
<li>Connect to any specific linker format by implement the concrete Read/Writer.</li>
<li>e.g. Implement Microsoft link format Reader/Writer
=&gt; extend lld to support Microsoft link format.</li>
</ul>
</li>
</ul>
</li>
<li><p class="first">Atom</p>
<ul class="simple">
<li>An atom is an indivisible chunk of code or data.</li>
<li>Typically each user written function or global variable is an atom.</li>
<li>In addition, the compiler may emit other atoms, such as for literal c-strings
or floating point constants, or for runtime data structures like dwarf unwind
info or pointers to initializers.</li>
</ul>
</li>
<li><p class="first">Atoms classified:</p>
<ul class="simple">
<li>The following Hello World code can be classified with these different kinds of
Atoms as follows,</li>
</ul>
<p class="rubric">Atom example code</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">extern</span> <span class="kt">int</span> <span class="nf">printf</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">format</span><span class="p">,</span> <span class="p">...);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="s">&quot;Hello world!&quot;</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li>DefinedAtom<ul>
<li>95% of all atoms. This is a chunk of code or data</li>
</ul>
</li>
<li>UndefinedAtom<ul>
<li>printf in this example.</li>
</ul>
</li>
<li>SharedLibraryAtom<ul>
<li>Symbols defined in shared library (file *.so).</li>
</ul>
</li>
<li>AbsoluteAtom<ul>
<li>This is for embedded support where some stuff is implemented in ROM at some
fixed address.</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="figure align-center" id="lld-atom">
<a class="reference internal image-reference" href="_images/atom.png"><img alt="_images/atom.png" src="_images/atom.png" /></a>
<p class="caption">Figure 2: Atom classified (from lld web)</p>
</div>
</div>
<div class="section" id="linking-steps">
<h4><a class="toc-backref" href="#id42">Linking Steps</a><a class="headerlink" href="#linking-steps" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>Command line processing<ul>
<li>lld -flavor gnu -target cpu0-unknown-linux-gnu hello.o printf-stdarg.o -o a.out</li>
</ul>
</li>
<li>Parsing input files<ul>
<li>ELF reader =&gt; create lld:File</li>
</ul>
</li>
<li>Resolving<ul>
<li>dead code stripping</li>
</ul>
</li>
<li>Passes/Optimizations<ul>
<li>Like llvm passes, give backend a chance to do something like optimization.</li>
</ul>
</li>
<li>Generate output file<ul>
<li>Resolving Relocation Records – I guess in this step</li>
</ul>
</li>
</ul>
<div class="section" id="command-line-processing">
<h5><a class="toc-backref" href="#id43">Command line processing</a><a class="headerlink" href="#command-line-processing" title="Permalink to this headline">¶</a></h5>
<p>To support a new backend, the following code added for Command line processing.</p>
<p class="rubric">lld/lib/ReaderWriter/ELF/ELFLinkingContext.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">uint16_t</span> <span class="n">ELFLinkingContext</span><span class="o">::</span><span class="n">getOutputMachine</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">getTriple</span><span class="p">().</span><span class="n">getArch</span><span class="p">())</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="k">case</span> <span class="n">llvm</span>:<span class="o">:</span><span class="n">Triple</span><span class="o">::</span><span class="n">cpu0</span><span class="o">:</span>
    <span class="k">return</span> <span class="n">llvm</span><span class="o">::</span><span class="n">ELF</span><span class="o">::</span><span class="n">EM_CPU0</span><span class="p">;</span>
  <span class="nl">default:</span>
    <span class="n">llvm_unreachable</span><span class="p">(</span><span class="s">&quot;Unhandled arch&quot;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ELFLinkingContext</span><span class="o">&gt;</span>
<span class="n">ELFLinkingContext</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">Triple</span> <span class="n">triple</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">triple</span><span class="p">.</span><span class="n">getArch</span><span class="p">())</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="k">case</span> <span class="n">llvm</span>:<span class="o">:</span><span class="n">Triple</span><span class="o">::</span><span class="n">cpu0</span><span class="o">:</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ELFLinkingContext</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="k">new</span> <span class="n">lld</span><span class="o">::</span><span class="n">elf</span><span class="o">::</span><span class="n">Cpu0LinkingContext</span><span class="p">(</span><span class="n">triple</span><span class="p">));</span>
  <span class="nl">default:</span>
    <span class="k">return</span> <span class="n">nullptr</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="parsing-input-files">
<h5><a class="toc-backref" href="#id44">Parsing input files</a><a class="headerlink" href="#parsing-input-files" title="Permalink to this headline">¶</a></h5>
<ul>
<li><p class="first">Input Files</p>
<ul class="simple">
<li>A goal of lld is to be file format independent.</li>
<li>The lld::Reader is the base class for all object file readers</li>
<li>Every Reader subclass defines its own “options” class (for instance the
mach-o Reader defines the class ReaderOptionsMachO). This options class is
the one-and-only way to control how the Reader operates when parsing an input
file into an Atom graph</li>
</ul>
</li>
<li><p class="first">Reader</p>
<ul>
<li><p class="first">The base class lld::reader and the elf specific file format reader as follows,</p>
<p class="rubric">lld/lib/ReaderWriter/Reader.cpp</p>
<div class="highlight-c++"><pre>~/llvm/test/src/tools/lld/lib/ReaderWriter$ cat Reader.cpp
...
#include "lld/ReaderWriter/Reader.h"

#include "llvm/ADT/OwningPtr.h"
#include "llvm/ADT/StringRef.h"
#include "llvm/Support/MemoryBuffer.h"
#include "llvm/Support/system_error.h"

namespace lld {
Reader::~Reader() {
}
} // end namespace lld</pre>
</div>
<p class="rubric">lld/lib/ReaderWriter/ELF/Reader.cpp</p>
<div class="highlight-c++"><pre>~/llvm/test/src/tools/lld/lib/ReaderWriter/ELF$ cat Reader.cpp
namespace lld {
namespace elf {
...
class ELFReader : public Reader {
public:
  ELFReader(const ELFLinkingContext &amp;ctx)
      : lld::Reader(ctx), _elfLinkingContext(ctx) {}

  error_code parseFile(std::unique_ptr&lt;MemoryBuffer&gt; &amp;mb,
                       std::vector&lt;std::unique_ptr&lt;File&gt; &gt; &amp;result) const {
…
private:
  const ELFLinkingContext &amp;_elfLinkingContext;
};
} // end namespace elf

std::unique_ptr&lt;Reader&gt; createReaderELF(const ELFLinkingContext &amp;context) {
  return std::unique_ptr&lt;Reader&gt;(new elf::ELFReader(context));
}
} // end namespace lld</pre>
</div>
</li>
</ul>
</li>
<li><p class="first">lld::File representations</p>
<ul class="simple">
<li>In memory, abstract C++ classes (lld::Atom, lld::Reference, and lld::File).<ul>
<li>Data structure keeped in memory to be fast</li>
</ul>
</li>
<li>textual (in YAML)<ul>
<li>target-triple:   x86_64-apple-darwin11</li>
<li>atoms:<ul>
<li>name:    _main</li>
<li>scope:   global</li>
<li>type:    code</li>
<li>content: [ 55, 48, 89, e5, 48, 8d, 3d, 00, 00, 00, 00, 30, c0, e8, 00, 00,
00, 00, 31, c0, 5d, c3 ]</li>
</ul>
</li>
</ul>
</li>
<li>binary format (“native”)<ul>
<li>With this model for the native file format, files can be read and turned
into the in-memory graph of lld::Atoms with just a few memory allocations.
And the format can easily adapt over time to new features.</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="resolving">
<h5><a class="toc-backref" href="#id45">Resolving</a><a class="headerlink" href="#resolving" title="Permalink to this headline">¶</a></h5>
<ul class="simple">
<li>Dead code stripping (if requested) is done at the end of resolving.</li>
<li>The linker does a simple mark-and-sweep. It starts with <strong>“root”</strong> atoms (like
“main” in a main executable) and follows each references and marks each Atom
that it visits as <strong>“live”</strong>.</li>
<li>When done, all atoms not marked <strong>“live”</strong> are removed.</li>
</ul>
<p class="rubric">Dead code stripping - example (modified from llvm lto document web)</p>
<p class="rubric">a.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">extern</span> <span class="kt">int</span> <span class="nf">foo1</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="nf">foo2</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="nf">foo4</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</pre></div>
</div>
<p class="rubric">a.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &quot;a.h&quot;</span>

<span class="k">static</span> <span class="kt">signed</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">foo2</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">foo3</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="mi">10</span><span class="o">+</span><span class="n">foo4</span><span class="p">());</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">foo1</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">foo3</span><span class="p">();</span>

  <span class="n">data</span> <span class="o">=</span> <span class="n">data</span> <span class="o">+</span> <span class="mi">42</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">ch13_1.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &quot;a.h&quot;</span>

<span class="kt">void</span> <span class="nf">ISR</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">asm</span><span class="p">(</span><span class="s">&quot;ISR:&quot;</span><span class="p">);</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">foo4</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="mi">5</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">foo1</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Above code can be reduced to <a class="pageref" href="#lld-deadcodestripping">Figure  3</a> to perform
mark and swip in graph for Dead Code Stripping.</p>
<div class="figure align-center" id="lld-deadcodestripping">
<a class="reference internal image-reference" href="_images/deadcodestripping.png"><img alt="_images/deadcodestripping.png" src="_images/deadcodestripping.png" /></a>
<p class="caption">Figure 3: Atom classified (from lld web)</p>
</div>
<p>As above example, the foo2() is an isolated node without any reference. It&#8217;s
dead code and can be removed in linker optimization. We test this example by
build-ch13_1.sh and find foo2() cannot be removed.
There are two possibilities for this situation.
One is we do not trigger lld dead code stripping
optimization in command (the default is not do it). The other is lld hasn&#8217;t
implemented it yet at this point. It&#8217;s reasonable since the
lld is in its early stages of development. We didn&#8217;t dig it more, since the
Cpu0 backend tutorial just need a linker to finish Relocation Records Resolve
and see how it runs on PC.</p>
<p>Remind, llvm-linker is the linker works on IR level linker optimization.
Sometime when you got the obj file only (if you have a.o in this case),
the native linker (such as lld) have the opportunity to do Dead Code Stripping
while the IR linker hasn&#8217;t.</p>
</div>
<div class="section" id="passes-optimizations">
<h5><a class="toc-backref" href="#id46">Passes/Optimizations</a><a class="headerlink" href="#passes-optimizations" title="Permalink to this headline">¶</a></h5>
<ul class="simple">
<li>Passes<ul>
<li>stub (PLT) generation</li>
<li>GOT instantiation</li>
<li>order_file optimization</li>
<li>branch island generation</li>
<li>branch shim generation</li>
<li>Objective-C optimizations (Darwin specific)</li>
<li>TLV instantiation (Darwin specific)</li>
<li>DTrace probe processing (Darwin specific)</li>
<li>compact unwind encoding (Darwin specific)</li>
</ul>
</li>
</ul>
<p>The Cpu0RelocationPass.cpp and Cpu0RelocationPass.h are example codes for lld
backend Passes. The Relocation Pass structure shown as <a class="pageref" href="#lld-f3">Figure  4</a>.
The Cpu0 backend has two Relocation Passes and both of them are children of
RelocationPass. The StaticRelocationPass is for static linker and
DynamicRelocationPass is for dynamic linker. We will see how to register a
relocation pass according the staic or dynamic linker you like to do in
next section.</p>
<div class="figure align-center" id="lld-f3">
<a class="reference internal image-reference" href="_images/3.png"><img alt="_images/3.png" src="_images/3.png" /></a>
<p class="caption">Figure 4: Cpu0 lld RelocationPass</p>
</div>
<p>All lld backends which want to handle the Relocation
Records Resolve need to register a pass when the lld backend code is up.
After register the pass, LLD will do last two
steps, Passes/Optimization and Generate Output file, interactivly just like the
&#8220;Parsing and Generating code&#8221; in compiler.
LLD will do Passes/Optimization and call your
lld backend hook function &#8220;applyRelocation()&#8221; (defined in
Cpu0TargetRelocationHandler.cpp) to finish the address binding in linker stage.
Based on this understanding, we believe the &#8220;applyRelocation()&#8221; is at the step
of Generate output file rather than Passes/Optimization even LLD web document
didn&#8217;t indicate this.</p>
<p>The following code will register a pass when the lld backend code is up.</p>
<p class="rubric">exlbt/lld/Cpu0/Cpu0RelocationPass.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Pass</span><span class="o">&gt;</span>
<span class="n">lld</span><span class="o">::</span><span class="n">elf</span><span class="o">::</span><span class="n">createCpu0RelocationPass</span><span class="p">(</span><span class="k">const</span> <span class="n">Cpu0LinkingContext</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">ctx</span><span class="p">.</span><span class="n">getOutputELFType</span><span class="p">())</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">llvm</span>:<span class="o">:</span><span class="n">ELF</span><span class="o">::</span><span class="n">ET_EXEC</span><span class="o">:</span>
  <span class="c1">// when the output file is execution file: e.g. a.out</span>
<span class="cp">#ifdef DLINKER</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="p">.</span><span class="n">isDynamic</span><span class="p">())</span>
    <span class="c1">// when the a.out refer to shared object *.so</span>
      <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Pass</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">DynamicRelocationPass</span><span class="p">(</span><span class="n">ctx</span><span class="p">));</span>
    <span class="k">else</span>
<span class="cp">#endif </span><span class="c1">// DLINKER</span>
      <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Pass</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">StaticRelocationPass</span><span class="p">(</span><span class="n">ctx</span><span class="p">));</span>
<span class="cp">#ifdef DLINKER</span>
  <span class="k">case</span> <span class="n">llvm</span>:<span class="o">:</span><span class="n">ELF</span><span class="o">::</span><span class="n">ET_DYN</span><span class="o">:</span>
  <span class="c1">// when the output file is shared object: e.g. foobar.so</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Pass</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">DynamicRelocationPass</span><span class="p">(</span><span class="n">ctx</span><span class="p">));</span>
<span class="cp">#endif </span><span class="c1">// DLINKER</span>
  <span class="k">case</span> <span class="n">llvm</span>:<span class="o">:</span><span class="n">ELF</span><span class="o">::</span><span class="n">ET_REL</span><span class="o">:</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Pass</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="nl">default:</span>
    <span class="n">llvm_unreachable</span><span class="p">(</span><span class="s">&quot;Unhandled output file type&quot;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="generate-output-file">
<h5><a class="toc-backref" href="#id47">Generate Output File</a><a class="headerlink" href="#generate-output-file" title="Permalink to this headline">¶</a></h5>
<ul>
<li><p class="first">All concrete writers (e.g. ELF, mach-o, etc) are subclasses of the lld::Writer
class.</p>
</li>
<li><p class="first">Every Writer subclass defines its own “options” class (for instance the mach-o
Writer defines the class WriterOptionsMachO). This options class is the
one-and-only way to control how the Writer operates when producing an output
file from an Atom graph.</p>
</li>
<li><p class="first">Writer</p>
<p class="rubric">lld/lib/ReaderWriter</p>
<div class="highlight-c++"><pre>~/llvm/test/src/tools/lld/lib/ReaderWriter$ cat Writer.cpp
...
#include "lld/Core/File.h"
#include "lld/ReaderWriter/Writer.h"

namespace lld {
Writer::Writer() {
}

Writer::~Writer() {
}

bool Writer::createImplicitFiles(std::vector&lt;std::unique_ptr&lt;File&gt; &gt; &amp;) {
  return true;
}
} // end namespace lld</pre>
</div>
<p class="rubric">lld/lib/ReaderWriter</p>
<div class="highlight-c++"><pre>~/llvm/test/src/tools/lld/lib/ReaderWriter/ELF$ cat Writer.cpp
namespace lld {

std::unique_ptr&lt;Writer&gt; createWriterELF(const ELFLinkingContext &amp;info) {
  using llvm::object::ELFType;
  ...
  switch (info.getOutputELFType()) {
  case llvm::ELF::ET_EXEC:
    if (info.is64Bits()) {
      if (info.isLittleEndian())
        return std::unique_ptr&lt;Writer&gt;(new
            elf::ExecutableWriter&lt;ELFType&lt;support::little, 8, true&gt;&gt;(info));
      else
        return std::unique_ptr&lt;Writer&gt;(new
                elf::ExecutableWriter&lt;ELFType&lt;support::big, 8, true&gt;&gt;(info));
...

} // namespace lld</pre>
</div>
</li>
</ul>
<p>After register a relocation pass, lld backend hook function &#8220;applyRelocation()&#8221;
will be called by lld driver to finish the address binding in linker stage.</p>
<p class="rubric">exlbt/lld/Cpu0/Cpu0RelocationHandler.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">ErrorOr</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">Cpu0TargetRelocationHandler</span><span class="o">::</span><span class="n">applyRelocation</span><span class="p">(</span>
    <span class="n">ELFWriter</span> <span class="o">&amp;</span><span class="n">writer</span><span class="p">,</span> <span class="n">llvm</span><span class="o">::</span><span class="n">FileOutputBuffer</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="n">lld</span><span class="o">::</span><span class="n">AtomLayout</span> <span class="o">&amp;</span><span class="n">atom</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">Reference</span> <span class="o">&amp;</span><span class="n">ref</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">atomContent</span> <span class="o">=</span> <span class="n">buf</span><span class="p">.</span><span class="n">getBufferStart</span><span class="p">()</span> <span class="o">+</span> <span class="n">atom</span><span class="p">.</span><span class="n">_fileOffset</span><span class="p">;</span>
  <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">location</span> <span class="o">=</span> <span class="n">atomContent</span> <span class="o">+</span> <span class="n">ref</span><span class="p">.</span><span class="n">offsetInAtom</span><span class="p">();</span>
  <span class="kt">uint64_t</span> <span class="n">targetVAddress</span> <span class="o">=</span> <span class="n">writer</span><span class="p">.</span><span class="n">addressOfAtom</span><span class="p">(</span><span class="n">ref</span><span class="p">.</span><span class="n">target</span><span class="p">());</span>
  <span class="kt">uint64_t</span> <span class="n">relocVAddress</span> <span class="o">=</span> <span class="n">atom</span><span class="p">.</span><span class="n">_virtualAddr</span> <span class="o">+</span> <span class="n">ref</span><span class="p">.</span><span class="n">offsetInAtom</span><span class="p">();</span>
  <span class="p">...</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">ref</span><span class="p">.</span><span class="n">kind</span><span class="p">())</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">R_CPU0_NONE</span>:
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">R_CPU0_HI16</span>:
    <span class="n">relocHI16</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">relocVAddress</span><span class="p">,</span> <span class="n">targetVAddress</span><span class="p">,</span> <span class="n">ref</span><span class="p">.</span><span class="n">addend</span><span class="p">());</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">R_CPU0_LO16</span>:
    <span class="n">relocLO16</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">relocVAddress</span><span class="p">,</span> <span class="n">targetVAddress</span><span class="p">,</span> <span class="n">ref</span><span class="p">.</span><span class="n">addend</span><span class="p">());</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="p">...</span>
  <span class="k">case</span> <span class="n">R_CPU0_PC24</span>:
    <span class="n">relocPC24</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">relocVAddress</span><span class="p">,</span> <span class="n">targetVAddress</span><span class="p">,</span> <span class="n">ref</span><span class="p">.</span><span class="n">addend</span><span class="p">());</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="p">...</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">error_code</span><span class="o">::</span><span class="n">success</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">exlbt/input/ch_hello.c</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">extern</span> <span class="kt">int</span> <span class="nf">printf</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">format</span><span class="p">,</span> <span class="p">...);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="s">&quot;Hello world!&quot;</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">exlbt/input/build-hello.sh</p>
<div class="highlight-c++"><pre>#!/usr/bin/env bash

source functions.sh

sh_name=build-hello.sh
argNum=$#
arg1=$1
arg2=$2

prologue;

clang -target mips-unknown-linux-gnu -c start.cpp -emit-llvm -o start.bc
clang -target mips-unknown-linux-gnu -c debug.cpp -emit-llvm -o debug.bc
clang -target mips-unknown-linux-gnu -c printf-stdarg-def.c -emit-llvm \
-o printf-stdarg-def.bc
clang -target mips-unknown-linux-gnu -c printf-stdarg.c -emit-llvm \
-o printf-stdarg.bc
clang -target mips-unknown-linux-gnu -c ch_hello.c -emit-llvm -o ch_hello.bc
${TOOLDIR}/llc -march=cpu0${endian} -mcpu=${CPU} -relocation-model=static \
-filetype=obj start.bc -o start.cpu0.o
${TOOLDIR}/llc -march=cpu0${endian} -mcpu=${CPU} -relocation-model=static \
-filetype=obj debug.bc -o debug.cpu0.o
${TOOLDIR}/llc -march=cpu0${endian} -mcpu=${CPU} -relocation-model=static \
-filetype=obj printf-stdarg-def.bc -o printf-stdarg-def.cpu0.o
${TOOLDIR}/llc -march=cpu0${endian} -mcpu=${CPU} -relocation-model=static \
-filetype=obj printf-stdarg.bc -o printf-stdarg.cpu0.o
${TOOLDIR}/llc -march=cpu0${endian} -mcpu=${CPU} -relocation-model=static \
-filetype=obj ch_hello.bc -o ch_hello.cpu0.o
${TOOLDIR}/llc -march=cpu0${endian} -mcpu=${CPU} -relocation-model=static \
-filetype=obj lib_cpu0.ll -o lib_cpu0.o
${TOOLDIR}/lld -flavor gnu -target cpu0${endian}-unknown-linux-gnu \
start.cpu0.o debug.cpu0.o printf-stdarg-def.cpu0.o printf-stdarg.cpu0.o \
ch_hello.cpu0.o lib_cpu0.o -o a.out

epilogue;


</pre>
</div>
<p class="rubric">exlbt/verilog/Cpu0.hex</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">...</span>
<span class="cm">/*printf:*/</span>
<span class="cm">/*      b4:*/</span> <span class="mi">09</span> <span class="n">dd</span> <span class="n">ff</span> <span class="n">e0</span>                                  <span class="cm">/* addiu   $sp, $sp, -32*/</span>
<span class="p">...</span>
<span class="cm">/*main:*/</span>
<span class="cm">/*     9e0:*/</span> <span class="mi">09</span> <span class="n">dd</span> <span class="n">ff</span> <span class="n">e8</span>                                  <span class="cm">/* addiu   $sp, $sp, -24*/</span>
<span class="p">...</span>
<span class="cm">/*     9f0:*/</span> <span class="mf">0f</span> <span class="mi">20</span> <span class="mo">00</span> <span class="mo">00</span>                                  <span class="cm">/* lui     $2, 0*/</span>
<span class="cm">/*     9f4:*/</span> <span class="mi">0</span><span class="n">d</span> <span class="mi">22</span> <span class="mi">0</span><span class="n">b</span> <span class="mf">9f</span>                                  <span class="cm">/* ori     $2, $2, 2975*/</span>
<span class="p">...</span>
<span class="cm">/*     a0c:*/</span> <span class="mi">3</span><span class="n">b</span> <span class="n">ff</span> <span class="n">f6</span> <span class="n">a4</span>                                  <span class="cm">/* jsub    16774820*/</span>
<span class="p">...</span>
<span class="cm">/*Contents of section .rodata:*/</span>
<span class="cm">/*0b98 */</span><span class="mi">28</span> <span class="mi">6</span><span class="n">e</span> <span class="mi">75</span> <span class="mi">6</span><span class="n">c</span>  <span class="mi">6</span><span class="n">c</span> <span class="mi">29</span> <span class="mo">00</span> <span class="mi">48</span>  <span class="mi">65</span> <span class="mi">6</span><span class="n">c</span> <span class="mi">6</span><span class="n">c</span> <span class="mf">6f</span>  <span class="mi">20</span> <span class="mi">77</span> <span class="mf">6f</span> <span class="mi">72</span> <span class="cm">/*  (null).Hello wor*/</span>
<span class="cm">/*0ba8 */</span><span class="mi">6</span><span class="n">c</span> <span class="mi">64</span> <span class="mi">21</span> <span class="mo">00</span>  <span class="mi">25</span> <span class="mi">73</span> <span class="mi">0</span><span class="n">a</span> <span class="mo">00</span>   <span class="cm">/*  ld!.\%s..*/</span>
</pre></div>
</div>
<p>As you can see, applyRelocation() get four values for the Relocation Records
Solving. When meets R_CPU0_LO16, targetVAddress is the only one value needed for
this Relocation Solving in these four values. For this ch_hello.c example code,
the lld set the &#8220;Hello world!&#8221; string begin at 0x0b98+7=0x0b9f.
So, targetVAddress is 0x0b9f.
These two instructions &#8220;lui&#8221; and &#8220;ori&#8221; at address 0x9f0 and 0x9f4,
respectively, loading the address of &#8220;Hello world!&#8221; string to register $2.
The &#8220;lui&#8221; got the HI 16 bits while the
&#8220;ori&#8221; got the LO 16 bits of address of &#8220;Hello world!&#8221; string. This &#8220;lui&#8221;
Relocation Record, R_CPU0_HI16, is 0 since the HI 16 bits of 0xb9f is 0 while
the &#8220;ori&#8221; Relocation Record, R_CPU0_LO16, is 0xb9f.
The instruction &#8220;jsub&#8221; at 0xa0c is an instruction jump to printf().
This instruction is a PC relative address Relocation Record, R_CPU0_PC24,
while the R_CPU0_LO16 is an absolute address Relocation Record.
To solve this Relocation Record, it needs &#8220;location&#8221; in addition to
targetVAddress. In this case, the targetVAddress is 0xb4 where is the printf
subroutine start address and the location is 0xa0c since the
instruction &#8220;jsub&#8221; sit at this address.
The R_CPU0_PC24 is solved by (0xb4 - (0xa0c + 4) = 0xf6a4 for 16 bits with sign
extension) since after this &#8220;jsub&#8221; instruction executed the PC counter is
(0xa0c+4).
To +4 at current instruction because PC counter increased at instruction fetch
stage in Verilog design.</p>
<p>Remind, we explain the Relocation Records Solving according file cpu0.hex list
as above because the the Cpu0 machine boot at memory address 0x0 while the elf
text section or plt section as follows start at 0x140. The 0x0 is the header of
machine architecture information. The elf2hex code must keeps the address
relative distance between text and plt sections just like the Cpu0 elf2hex.h did.
The .rodata and other data sections are binding with absolute address, Cpu0
elf2hex must keeps them as the same address of elf.</p>
<p>For the following example code run, the book example code, exlbt.tar.gz,
untared in directory /Users/Jonathan/test/lbt/.
The Cpu0 backend code, lbdex.tar.gz, untared in
the same directory too. The lbdex.tar.gz can be get from the bottom of web,
<a class="reference external" href="http://jonathan2251.github.io/lbd/index.html">http://jonathan2251.github.io/lbd/index.html</a>.</p>
<div class="highlight-bash"><div class="highlight"><pre>1-160-136-173:input Jonathan<span class="nv">$ </span><span class="nb">pwd</span>
/Users/Jonathan/test/lbt/exlbt/input
1-160-136-173:input Jonathan<span class="nv">$ </span>ls ../..
... exlbt ... lbdex ...
/Users/Jonathan/test/lbt/exlbt/input
1-160-136-173:input Jonathan<span class="nv">$ </span>bash build-hello.sh cpu032I be
1-160-136-173:input Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
Debug/bin/llvm-objdump -s a.out
...                .
Contents of section .plt:
 0140 3600000c 36000004 36000004 36fffffc  6...6...6...6...
Contents of section .text:
 0150 09ddfff8 02ed0004 02cd0000 11cd0000  ................
...
Contents of section .rodata:
 0b98 286e756c 6c290048 656c6c6f 20776f72  <span class="o">(</span>null<span class="o">)</span>.Hello wor
 0ba8 6c642100 25730a00                    ld!.%s..
</pre></div>
</div>
<p>Next section will show you how to design your lld backend and register a pass
for Relocation Records Solve in details through Cpu0 backend code explantation.</p>
</div>
</div>
</div>
<div class="section" id="static-linker">
<h3><a class="toc-backref" href="#id48">Static linker</a><a class="headerlink" href="#static-linker" title="Permalink to this headline">¶</a></h3>
<p>Let&#8217;s run the static linker first and explain it next.</p>
<div class="section" id="run">
<h4><a class="toc-backref" href="#id49">Run</a><a class="headerlink" href="#run" title="Permalink to this headline">¶</a></h4>
<p>File printf-stdarg.c come from internet download which is GPL2 license. GPL2
is more restricted than LLVM license.
File printf-stdarg-1.c is the file for testing the printf() function which
implemented on PC OS platform. Let&#8217;s run printf-stdarg-2.cpp on Cpu0 and
compare it against the result of PC&#8217;s printf() as below.</p>
<p class="rubric">exlbt/input/printf-stdarg-1.c</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">  Copyright 2001, 2002 Georges Menie (www.menie.org)</span>
<span class="cm">  stdarg version contributed by Christian Ettinger</span>

<span class="cm">    This program is free software; you can redistribute it and/or modify</span>
<span class="cm">    it under the terms of the GNU Lesser General Public License as published by</span>
<span class="cm">    the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm">    (at your option) any later version.</span>

<span class="cm">    This program is distributed in the hope that it will be useful,</span>
<span class="cm">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm">    GNU Lesser General Public License for more details.</span>

<span class="cm">    You should have received a copy of the GNU Lesser General Public License</span>
<span class="cm">    along with this program; if not, write to the Free Software</span>
<span class="cm">    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="cm">*/</span>

<span class="cm">/*</span>
<span class="cm">  putchar is the only external dependency for this file,</span>
<span class="cm">  if you have a working putchar, leave it commented out.</span>
<span class="cm">  If not, uncomment the define below and</span>
<span class="cm">  replace outbyte(c) by your own function call.</span>

<span class="cm">#define putchar(c) outbyte(c)</span>
<span class="cm">*/</span>

<span class="c1">// gcc printf-stdarg-1.c</span>
<span class="c1">// ./a.out</span>

<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="cp">#define TEST_PRINTF</span>

<span class="cp">#ifdef TEST_PRINTF</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="s">&quot;Hello world!&quot;</span><span class="p">;</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bs</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="mi">8</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">mi</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">80</span><span class="p">];</span>

  <span class="n">mi</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">bs</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;printf test</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s is null pointer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">np</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d = 5</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d = - max int</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mi</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;char %c = &#39;a&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;hex %x = ff</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;hex %02x = 00</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;signed %d = unsigned %u = hex %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d %s(s)%&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;message&quot;</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d %s(s) with %%</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;message&quot;</span><span class="p">);</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;justif: </span><span class="se">\&quot;</span><span class="s">%-10s</span><span class="se">\&quot;\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;left&quot;</span><span class="p">);</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;justif: </span><span class="se">\&quot;</span><span class="s">%10s</span><span class="se">\&quot;\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;right&quot;</span><span class="p">);</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot; 3: %04d zero padded</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot; 3: %-4d left justif.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot; 3: %4d right justif.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;-3: %04d zero padded</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">);</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;-3: %-4d left justif.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">);</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;-3: %4d right justif.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">);</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * if you compile this file with</span>
<span class="cm"> *   gcc -Wall $(YOUR_C_OPTIONS) -DTEST_PRINTF -c printf.c</span>
<span class="cm"> * you will get a normal warning:</span>
<span class="cm"> *   printf.c:214: warning: spurious trailing `%&#39; in format</span>
<span class="cm"> * this line is testing an invalid % at the end of the format string.</span>
<span class="cm"> *</span>
<span class="cm"> * this should display (on 32bit int machine) :</span>
<span class="cm"> *</span>
<span class="cm"> * Hello world!</span>
<span class="cm"> * printf test</span>
<span class="cm"> * (null) is null pointer</span>
<span class="cm"> * 5 = 5</span>
<span class="cm"> * -2147483647 = - max int</span>
<span class="cm"> * char a = &#39;a&#39;</span>
<span class="cm"> * hex ff = ff</span>
<span class="cm"> * hex 00 = 00</span>
<span class="cm"> * signed -3 = unsigned 4294967293 = hex fffffffd</span>
<span class="cm"> * 0 message(s)</span>
<span class="cm"> * 0 message(s) with %</span>
<span class="cm"> * justif: &quot;left      &quot;</span>
<span class="cm"> * justif: &quot;     right&quot;</span>
<span class="cm"> *  3: 0003 zero padded</span>
<span class="cm"> *  3: 3    left justif.</span>
<span class="cm"> *  3:    3 right justif.</span>
<span class="cm"> * -3: -003 zero padded</span>
<span class="cm"> * -3: -3   left justif.</span>
<span class="cm"> * -3:   -3 right justif.</span>
<span class="cm"> */</span>

<span class="cp">#endif</span>
</pre></div>
</div>
<p class="rubric">exlbt/input/printf-stdarg-2.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &quot;debug.h&quot;</span>
<span class="cp">#include &quot;print.h&quot;</span>

<span class="cp">#define TEST_PRINTF</span>

<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kt">int</span> <span class="n">putchar</span><span class="p">(</span><span class="kt">int</span> <span class="n">c</span><span class="p">);</span> 

<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="p">{</span>
<span class="cp">#include &quot;printf-stdarg.c&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">exlbt/input/printf-stdarg-def.c</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &quot;print.h&quot;</span>

<span class="c1">// Definition putchar(int c) for printf-stdarg.c</span>
<span class="c1">// For memory IO</span>
<span class="kt">int</span> <span class="nf">putchar</span><span class="p">(</span><span class="kt">int</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">OUT_MEM</span><span class="p">;</span>
  <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">exlbt/input/printf-stdarg.c</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">  Copyright 2001, 2002 Georges Menie (www.menie.org)</span>
<span class="cm">  stdarg version contributed by Christian Ettinger</span>

<span class="cm">    This program is free software; you can redistribute it and/or modify</span>
<span class="cm">    it under the terms of the GNU Lesser General Public License as published by</span>
<span class="cm">    the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm">    (at your option) any later version.</span>

<span class="cm">    This program is distributed in the hope that it will be useful,</span>
<span class="cm">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm">    GNU Lesser General Public License for more details.</span>

<span class="cm">    You should have received a copy of the GNU Lesser General Public License</span>
<span class="cm">    along with this program; if not, write to the Free Software</span>
<span class="cm">    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="cm">*/</span>

<span class="cm">/*</span>
<span class="cm">  putchar is the only external dependency for this file,</span>
<span class="cm">  if you have a working putchar, leave it commented out.</span>
<span class="cm">  If not, uncomment the define below and</span>
<span class="cm">  replace outbyte(c) by your own function call.</span>

<span class="cm">#define putchar(c) outbyte(c)</span>
<span class="cm">*/</span>

<span class="cp">#include &lt;stdarg.h&gt;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">printchar</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="n">str</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">extern</span> <span class="kt">int</span> <span class="n">putchar</span><span class="p">(</span><span class="kt">int</span> <span class="n">c</span><span class="p">);</span>
  
  <span class="k">if</span> <span class="p">(</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">**</span><span class="n">str</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
    <span class="o">++</span><span class="p">(</span><span class="o">*</span><span class="n">str</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">putchar</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define PAD_RIGHT 1</span>
<span class="cp">#define PAD_ZERO 2</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">prints</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pad</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">register</span> <span class="kt">int</span> <span class="n">pc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">padchar</span> <span class="o">=</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">width</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">register</span> <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">register</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">string</span><span class="p">;</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span> <span class="o">++</span><span class="n">ptr</span><span class="p">)</span> <span class="o">++</span><span class="n">len</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="n">width</span><span class="p">)</span> <span class="n">width</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">else</span> <span class="n">width</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pad</span> <span class="o">&amp;</span> <span class="n">PAD_ZERO</span><span class="p">)</span> <span class="n">padchar</span> <span class="o">=</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pad</span> <span class="o">&amp;</span> <span class="n">PAD_RIGHT</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="n">width</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">width</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">printchar</span> <span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">padchar</span><span class="p">);</span>
      <span class="o">++</span><span class="n">pc</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="o">*</span><span class="n">string</span> <span class="p">;</span> <span class="o">++</span><span class="n">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printchar</span> <span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="o">*</span><span class="n">string</span><span class="p">);</span>
    <span class="o">++</span><span class="n">pc</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="n">width</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">width</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printchar</span> <span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">padchar</span><span class="p">);</span>
    <span class="o">++</span><span class="n">pc</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">pc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* the following should be enough for 32 bit int */</span>
<span class="cp">#define PRINT_BUF_LEN 12</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">printi</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="n">out</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pad</span><span class="p">,</span> <span class="kt">int</span> <span class="n">letbase</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="n">print_buf</span><span class="p">[</span><span class="n">PRINT_BUF_LEN</span><span class="p">];</span>
  <span class="k">register</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
  <span class="k">register</span> <span class="kt">int</span> <span class="n">t</span><span class="p">,</span> <span class="n">neg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">register</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">print_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
    <span class="n">print_buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">prints</span> <span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">print_buf</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">pad</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">sg</span> <span class="o">&amp;&amp;</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">10</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">neg</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="o">-</span><span class="n">i</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">s</span> <span class="o">=</span> <span class="n">print_buf</span> <span class="o">+</span> <span class="n">PRINT_BUF_LEN</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

  <span class="k">while</span> <span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">u</span> <span class="o">%</span> <span class="n">b</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">t</span> <span class="o">&gt;=</span> <span class="mi">10</span> <span class="p">)</span>
      <span class="n">t</span> <span class="o">+=</span> <span class="n">letbase</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span> <span class="o">-</span> <span class="mi">10</span><span class="p">;</span>
    <span class="o">*--</span><span class="n">s</span> <span class="o">=</span> <span class="n">t</span> <span class="o">+</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
    <span class="n">u</span> <span class="o">/=</span> <span class="n">b</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">neg</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">width</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pad</span> <span class="o">&amp;</span> <span class="n">PAD_ZERO</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">printchar</span> <span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="sc">&#39;-&#39;</span><span class="p">);</span>
      <span class="o">++</span><span class="n">pc</span><span class="p">;</span>
      <span class="o">--</span><span class="n">width</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
      <span class="o">*--</span><span class="n">s</span> <span class="o">=</span> <span class="sc">&#39;-&#39;</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">pc</span> <span class="o">+</span> <span class="n">prints</span> <span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">pad</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">print</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">format</span><span class="p">,</span> <span class="kt">va_list</span> <span class="n">args</span> <span class="p">)</span>
<span class="p">{</span>
  <span class="k">register</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="n">pad</span><span class="p">;</span>
  <span class="k">register</span> <span class="kt">int</span> <span class="n">pc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">scr</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

  <span class="k">for</span> <span class="p">(;</span> <span class="o">*</span><span class="n">format</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">++</span><span class="n">format</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">format</span> <span class="o">==</span> <span class="sc">&#39;%&#39;</span><span class="p">)</span> <span class="p">{</span>
      <span class="o">++</span><span class="n">format</span><span class="p">;</span>
      <span class="n">width</span> <span class="o">=</span> <span class="n">pad</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">format</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">format</span> <span class="o">==</span> <span class="sc">&#39;%&#39;</span><span class="p">)</span> <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">format</span> <span class="o">==</span> <span class="sc">&#39;-&#39;</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">++</span><span class="n">format</span><span class="p">;</span>
        <span class="n">pad</span> <span class="o">=</span> <span class="n">PAD_RIGHT</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">format</span> <span class="o">==</span> <span class="sc">&#39;0&#39;</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">++</span><span class="n">format</span><span class="p">;</span>
        <span class="n">pad</span> <span class="o">|=</span> <span class="n">PAD_ZERO</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="o">*</span><span class="n">format</span> <span class="o">&gt;=</span> <span class="sc">&#39;0&#39;</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">format</span> <span class="o">&lt;=</span> <span class="sc">&#39;9&#39;</span><span class="p">;</span> <span class="o">++</span><span class="n">format</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">width</span> <span class="o">*=</span> <span class="mi">10</span><span class="p">;</span>
        <span class="n">width</span> <span class="o">+=</span> <span class="o">*</span><span class="n">format</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span><span class="p">(</span> <span class="o">*</span><span class="n">format</span> <span class="o">==</span> <span class="sc">&#39;s&#39;</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">register</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">va_arg</span><span class="p">(</span> <span class="n">args</span><span class="p">,</span> <span class="kt">int</span> <span class="p">);</span>
        <span class="n">pc</span> <span class="o">+=</span> <span class="n">prints</span> <span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">s</span><span class="o">?</span><span class="n">s</span><span class="o">:</span><span class="s">&quot;(null)&quot;</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">pad</span><span class="p">);</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span><span class="p">(</span> <span class="o">*</span><span class="n">format</span> <span class="o">==</span> <span class="sc">&#39;d&#39;</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">pc</span> <span class="o">+=</span> <span class="n">printi</span> <span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">va_arg</span><span class="p">(</span> <span class="n">args</span><span class="p">,</span> <span class="kt">int</span> <span class="p">),</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">pad</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">);</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span><span class="p">(</span> <span class="o">*</span><span class="n">format</span> <span class="o">==</span> <span class="sc">&#39;x&#39;</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">pc</span> <span class="o">+=</span> <span class="n">printi</span> <span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">va_arg</span><span class="p">(</span> <span class="n">args</span><span class="p">,</span> <span class="kt">int</span> <span class="p">),</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">pad</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">);</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span><span class="p">(</span> <span class="o">*</span><span class="n">format</span> <span class="o">==</span> <span class="sc">&#39;X&#39;</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">pc</span> <span class="o">+=</span> <span class="n">printi</span> <span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">va_arg</span><span class="p">(</span> <span class="n">args</span><span class="p">,</span> <span class="kt">int</span> <span class="p">),</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">pad</span><span class="p">,</span> <span class="sc">&#39;A&#39;</span><span class="p">);</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span><span class="p">(</span> <span class="o">*</span><span class="n">format</span> <span class="o">==</span> <span class="sc">&#39;u&#39;</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">pc</span> <span class="o">+=</span> <span class="n">printi</span> <span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">va_arg</span><span class="p">(</span> <span class="n">args</span><span class="p">,</span> <span class="kt">int</span> <span class="p">),</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">pad</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">);</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span><span class="p">(</span> <span class="o">*</span><span class="n">format</span> <span class="o">==</span> <span class="sc">&#39;c&#39;</span> <span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* char are converted to int then pushed on the stack */</span>
        <span class="n">scr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="n">va_arg</span><span class="p">(</span> <span class="n">args</span><span class="p">,</span> <span class="kt">int</span> <span class="p">);</span>
        <span class="n">scr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
        <span class="n">pc</span> <span class="o">+=</span> <span class="n">prints</span> <span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">scr</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">pad</span><span class="p">);</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
    <span class="nl">out:</span>
      <span class="n">printchar</span> <span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="o">*</span><span class="n">format</span><span class="p">);</span>
      <span class="o">++</span><span class="n">pc</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">**</span><span class="n">out</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
  <span class="n">va_end</span><span class="p">(</span> <span class="n">args</span> <span class="p">);</span>
  <span class="k">return</span> <span class="n">pc</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">printf</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">format</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
        <span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>
        
        <span class="n">va_start</span><span class="p">(</span> <span class="n">args</span><span class="p">,</span> <span class="n">format</span> <span class="p">);</span>
        <span class="k">return</span> <span class="n">print</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="n">format</span><span class="p">,</span> <span class="n">args</span> <span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">sprintf</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">format</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
        <span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>
        
        <span class="n">va_start</span><span class="p">(</span> <span class="n">args</span><span class="p">,</span> <span class="n">format</span> <span class="p">);</span>
        <span class="k">return</span> <span class="n">print</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">out</span><span class="p">,</span> <span class="n">format</span><span class="p">,</span> <span class="n">args</span> <span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef TEST_PRINTF</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="s">&quot;Hello world!&quot;</span><span class="p">;</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bs</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="mi">8</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">mi</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">80</span><span class="p">];</span>

  <span class="n">mi</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">bs</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;printf test</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s is null pointer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">np</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d = 5</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d = - max int</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mi</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;char %c = &#39;a&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;hex %x = ff</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;hex %02x = 00</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;signed %d = unsigned %u = hex %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d %s(s)%&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;message&quot;</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d %s(s) with %%</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;message&quot;</span><span class="p">);</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;justif: </span><span class="se">\&quot;</span><span class="s">%-10s</span><span class="se">\&quot;\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;left&quot;</span><span class="p">);</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;justif: </span><span class="se">\&quot;</span><span class="s">%10s</span><span class="se">\&quot;\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;right&quot;</span><span class="p">);</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot; 3: %04d zero padded</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot; 3: %-4d left justif.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot; 3: %4d right justif.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;-3: %04d zero padded</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">);</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;-3: %-4d left justif.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">);</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;-3: %4d right justif.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">);</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * if you compile this file with</span>
<span class="cm"> *   gcc -Wall $(YOUR_C_OPTIONS) -DTEST_PRINTF -c printf.c</span>
<span class="cm"> * you will get a normal warning:</span>
<span class="cm"> *   printf.c:214: warning: spurious trailing `%&#39; in format</span>
<span class="cm"> * this line is testing an invalid % at the end of the format string.</span>
<span class="cm"> *</span>
<span class="cm"> * this should display (on 32bit int machine) :</span>
<span class="cm"> *</span>
<span class="cm"> * Hello world!</span>
<span class="cm"> * printf test</span>
<span class="cm"> * (null) is null pointer</span>
<span class="cm"> * 5 = 5</span>
<span class="cm"> * -2147483647 = - max int</span>
<span class="cm"> * char a = &#39;a&#39;</span>
<span class="cm"> * hex ff = ff</span>
<span class="cm"> * hex 00 = 00</span>
<span class="cm"> * signed -3 = unsigned 4294967293 = hex fffffffd</span>
<span class="cm"> * 0 message(s)</span>
<span class="cm"> * 0 message(s) with %</span>
<span class="cm"> * justif: &quot;left      &quot;</span>
<span class="cm"> * justif: &quot;     right&quot;</span>
<span class="cm"> *  3: 0003 zero padded</span>
<span class="cm"> *  3: 3    left justif.</span>
<span class="cm"> *  3:    3 right justif.</span>
<span class="cm"> * -3: -003 zero padded</span>
<span class="cm"> * -3: -3   left justif.</span>
<span class="cm"> * -3:   -3 right justif.</span>
<span class="cm"> */</span>

<span class="cp">#endif</span>
</pre></div>
</div>
<p class="rubric">exlbt/input/start.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &quot;dynamic_linker.h&quot;</span>
<span class="cp">#include &quot;start.h&quot;</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="nf">main</span><span class="p">();</span>

<span class="c1">// Real entry (first instruction) is from cpu0BootAtomContent of </span>
<span class="c1">// Cpu0RelocationPass.cpp jump to asm(&quot;start:&quot;) of start.cpp.</span>
<span class="kt">void</span> <span class="nf">start</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">asm</span><span class="p">(</span><span class="s">&quot;start:&quot;</span><span class="p">);</span>
  
  <span class="k">asm</span><span class="p">(</span><span class="s">&quot;lui $sp, 0x6&quot;</span><span class="p">);</span>
  <span class="k">asm</span><span class="p">(</span><span class="s">&quot;addiu $sp, $sp, 0xfffc&quot;</span><span class="p">);</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">gpaddr</span><span class="p">;</span>
  <span class="n">gpaddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">GPADDR</span><span class="p">;</span>
  <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;ld  $gp, %0&quot;</span>
                       <span class="o">:</span> <span class="c1">// no output register, specify output register to $gp</span>
                       <span class="o">:</span><span class="s">&quot;m&quot;</span><span class="p">(</span><span class="o">*</span><span class="n">gpaddr</span><span class="p">)</span>
                       <span class="p">);</span>
  <span class="n">initRegs</span><span class="p">();</span>
  <span class="n">main</span><span class="p">();</span>
  <span class="k">asm</span><span class="p">(</span><span class="s">&quot;addiu $lr, $ZERO, -1&quot;</span><span class="p">);</span>
  <span class="k">asm</span><span class="p">(</span><span class="s">&quot;ret $lr&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">exlbt/input/lib_cpu0.ll</p>
<div class="highlight-c++"><pre>; The @_start() exist to prevent lld linker error.
; Real entry (first instruction) is from cpu0BootAtomContent of 
; Cpu0RelocationPass.cpp jump to asm("start:") of start.cpp.
define void @_start() nounwind {
entry:
  ret void
}

define void @__start() nounwind {
entry:
  ret void
}

define void @__stack_chk_fail() nounwind {
entry:
  ret void
}

define void @__stack_chk_guard() nounwind {
entry:
  ret void
}

define void @_ZdlPv() nounwind {
entry:
  ret void
}

define void @__dso_handle() nounwind {
entry:
  ret void
}

define void @_ZNSt8ios_base4InitC1Ev() nounwind {
entry:
  ret void
}

define void @__cxa_atexit() nounwind {
entry:
  ret void
}

define void @_ZTVN10__cxxabiv120__si_class_type_infoE() nounwind {
entry:
  ret void
}

define void @_ZTVN10__cxxabiv117__class_type_infoE() nounwind {
entry:
  ret void
}

define void @_Znwm() nounwind {
entry:
  ret void
}

define void @__cxa_pure_virtual() nounwind {
entry:
  ret void
}

define void @_ZNSt8ios_base4InitD1Ev() nounwind {
entry:
  ret void
}

</pre>
</div>
<p class="rubric">exlbt/input/functions.sh</p>
<div class="highlight-c++"><pre>prologue() {
  LBDEXDIR=../../lbdex

  if [ $argNum == 0 ]; then
    echo "useage: bash $sh_name cpu_type endian"
    echo "  cpu_type: cpu032I or cpu032II"
    echo "  endian: be (big endian, default) or le (little endian)"
    echo "for example:"
    echo "  bash build-slinker.sh cpu032I be"
    exit 1;
  fi
  if [ $arg1 != cpu032I ] &amp;&amp; [ $arg1 != cpu032II ]; then
    echo "1st argument is cpu032I or cpu032II"
    exit 1
  fi

  INCDIR=../../lbdex/input
  OS=`uname -s`
  echo "OS =" ${OS}

  if [ "$OS" == "Linux" ]; then
    TOOLDIR=~/llvm/test/cmake_debug_build/bin
  else
    TOOLDIR=~/llvm/test/cmake_debug_build/Debug/bin
  fi

  CPU=$arg1
  echo "CPU =" "${CPU}"

  if [ "$arg2" != "" ] &amp;&amp; [ $arg2 != le ] &amp;&amp; [ $arg2 != be ]; then
    echo "2nd argument is be (big endian, default) or le (little endian)"
    exit 1
  fi
  if [ "$arg2" == "" ] || [ $arg2 == be ]; then
    endian=
  else
    endian=el
  fi
  echo "endian =" "${endian}"

  bash clean.sh
}

isLittleEndian() {
  echo "endian = " "$endian"
  if [ "$endian" == "LittleEndian" ] ; then
    le="true"
  elif [ "$endian" == "BigEndian" ] ; then
    le="false"
  else
    echo "!endian unknown"
    exit 1
  fi
}

elf2hex() {
  ${TOOLDIR}/llvm-objdump -elf2hex -le=${le} a.out &gt; ${LBDEXDIR}/verilog/cpu0.hex
  if [ ${le} == "true" ] ; then
    echo "1   /* 0: big endian, 1: little endian */" &gt; ${LBDEXDIR}/verilog/cpu0.config
  else
    echo "0   /* 0: big endian, 1: little endian */" &gt; ${LBDEXDIR}/verilog/cpu0.config
  fi
  cat ${LBDEXDIR}/verilog/cpu0.config
}

epilogue() {
  endian=`${TOOLDIR}/llvm-readobj -h a.out|grep "DataEncoding"|awk '{print $2}'`
  isLittleEndian;
  elf2hex;
}
</pre>
</div>
<p class="rubric">exlbt/input/build-printf-stdarg-2.sh</p>
<div class="highlight-c++"><pre>#!/usr/bin/env bash

source functions.sh

sh_name=build-printf-stdarg-2.sh
argNum=$#
arg1=$1
arg2=$2

prologue;

clang -target mips-unknown-linux-gnu -c start.cpp -emit-llvm -o start.bc
clang -target mips-unknown-linux-gnu -c debug.cpp -emit-llvm -o debug.bc
clang -target mips-unknown-linux-gnu -c printf-stdarg-def.c -emit-llvm \
-o printf-stdarg-def.bc
clang -target mips-unknown-linux-gnu -c printf-stdarg-2.cpp -emit-llvm -o \
printf-stdarg-2.bc
${TOOLDIR}/llc -march=cpu0${endian} -mcpu=${CPU} -relocation-model=static \
-filetype=obj start.bc -o start.cpu0.o
${TOOLDIR}/llc -march=cpu0${endian} -mcpu=${CPU} -relocation-model=static \
-filetype=obj debug.bc -o debug.cpu0.o
${TOOLDIR}/llc -march=cpu0${endian} -mcpu=${CPU} -relocation-model=static \
-filetype=obj printf-stdarg-def.bc -o printf-stdarg-def.cpu0.o
${TOOLDIR}/llc -march=cpu0${endian} -mcpu=${CPU} -relocation-model=static \
-filetype=obj printf-stdarg-2.bc -o printf-stdarg-2.cpu0.o
${TOOLDIR}/llc -march=cpu0${endian} -mcpu=${CPU} -relocation-model=static \
-filetype=obj lib_cpu0.ll -o lib_cpu0.o
${TOOLDIR}/lld -flavor gnu -target cpu0${endian}-unknown-linux-gnu \
start.cpu0.o debug.cpu0.o printf-stdarg-def.cpu0.o printf-stdarg-2.cpu0.o \
lib_cpu0.o -o a.out

epilogue;

</pre>
</div>
<p>The verilog/cpu0Is.v support cmp instruction and static linker as follows,</p>
<p class="rubric">lbdex/verilog/cpu0Is.v</p>
<div class="highlight-c++"><pre>// TRACE: Display the memory contents of the loaded program and data
//`define TRACE 

`include "cpu0.v"

</pre>
</div>
<p>The verilog/cpu0IIs.v support slt instruction and static linker as follows,</p>
<p class="rubric">lbdex/verilog/cpu0IIs.v</p>
<div class="highlight-c++"><pre>`define CPU0II
// TRACE: Display the memory contents of the loaded program and data
//`define TRACE 

`include "cpu0.v"

</pre>
</div>
<p>The build-printf-stdarg-2.sh is for my PC setting. Please change this script to
the directory of your llvm/lld setting. After that run static linker example
code as follows,</p>
<div class="highlight-bash"><div class="highlight"><pre>1-160-136-173:input Jonathan<span class="nv">$ </span><span class="nb">pwd</span>
/Users/Jonathan/test/lbt/exlbt/input
1-160-136-173:input Jonathan<span class="nv">$ </span>bash build-printf-stdarg-2.sh cpu032I be
In file included from <span class="nb">printf</span>-stdarg-2.cpp:11:
./printf-stdarg.c:206:15: warning: conversion from string literal to <span class="s1">&#39;char *&#39;</span>
is deprecated <span class="o">[</span>-Wdeprecated-writable-strings<span class="o">]</span>
  char *ptr <span class="o">=</span> <span class="s2">&quot;Hello world!&quot;</span>;
              ^
1 warning generated.

1-160-136-173:input Jonathan<span class="nv">$ </span><span class="nb">cd</span> ../../lbdex/verilog/
1-160-136-173:verilog Jonathan<span class="nv">$ </span><span class="nb">pwd</span>
/Users/Jonathan/test/lbt/lbdex/lbdex/verilog
1-160-136-173:verilog Jonathan<span class="nv">$ </span>bash clean.sh
1-160-136-173:verilog Jonathan<span class="nv">$ </span>iverilog -o cpu0II cpu0IIs.v
Hello world!
<span class="nb">printf test</span>
<span class="o">(</span>null<span class="o">)</span> is null pointer
<span class="nv">5</span> <span class="o">=</span> 5
-2147483647 <span class="o">=</span> - max int
char <span class="nv">a</span> <span class="o">=</span> <span class="s1">&#39;a&#39;</span>
hex <span class="nv">ff</span> <span class="o">=</span> ff
hex <span class="nv">00</span> <span class="o">=</span> 00
signed -3 <span class="o">=</span> unsigned <span class="nv">4294967293</span> <span class="o">=</span> hex fffffffd
0 message<span class="o">(</span>s<span class="o">)</span>
0 message<span class="o">(</span>s<span class="o">)</span> with <span class="se">\%</span>
justif: <span class="s2">&quot;left      &quot;</span>
justif: <span class="s2">&quot;     right&quot;</span>
 3: 0003 zero padded
 3: 3    left justif.
 3:    3 right justif.
-3: -003 zero padded
</pre></div>
</div>
<p>Let&#8217;s check the result with PC program printf-stdarg-1.c output as follows,</p>
<div class="highlight-bash"><div class="highlight"><pre>1-160-136-173:input Jonathan<span class="nv">$ </span>clang <span class="nb">printf</span>-stdarg-1.c
<span class="nb">printf</span>-stdarg-1.c:58:19: warning: incomplete format specifier <span class="o">[</span>-Wformat<span class="o">]</span>
  <span class="nb">printf</span><span class="o">(</span><span class="s2">&quot;%d %s(s)%&quot;</span>, 0, <span class="s2">&quot;message&quot;</span><span class="o">)</span>;
                  ^
1 warning generated.
1-160-136-173:input Jonathan<span class="nv">$ </span>./a.out
Hello world!
<span class="nb">printf test</span>
<span class="o">(</span>null<span class="o">)</span> is null pointer
<span class="nv">5</span> <span class="o">=</span> 5
-2147483647 <span class="o">=</span> - max int
char <span class="nv">a</span> <span class="o">=</span> <span class="s1">&#39;a&#39;</span>
hex <span class="nv">ff</span> <span class="o">=</span> ff
hex <span class="nv">00</span> <span class="o">=</span> 00
signed -3 <span class="o">=</span> unsigned <span class="nv">4294967293</span> <span class="o">=</span> hex fffffffd
0 message<span class="o">(</span>s<span class="o">)</span>
0 message<span class="o">(</span>s<span class="o">)</span> with <span class="se">\%</span>
justif: <span class="s2">&quot;left      &quot;</span>
justif: <span class="s2">&quot;     right&quot;</span>
 3: 0003 zero padded
 3: 3    left justif.
 3:    3 right justif.
-3: -003 zero padded
-3: -3   left justif.
-3:   -3 right justif.
</pre></div>
</div>
<p>They are same. You can verify the slt instructions is work fine too by change
variable cpu from cpu032I to cpu032II as follows,</p>
<p class="rubric">exlbt/input/build-printf-stdarg-2.sh</p>
<div class="highlight-bash"><div class="highlight"><pre>1-160-136-173:verilog Jonathan<span class="nv">$ </span><span class="nb">pwd</span>
/Users/Jonathan/test/lbt/lbdex/verilog
1-160-136-173:verilog Jonathan<span class="nv">$ </span><span class="nb">cd</span> ../../exlbt/input
1-160-136-173:input Jonathan<span class="nv">$ </span><span class="nb">pwd</span>
/Users/Jonathan/test/lbt/exlbt/input
1-160-136-173:input Jonathan<span class="nv">$ </span>bash build-printf-stdarg-2.sh cpu032II be
...
1-160-136-173:input Jonathan<span class="nv">$ </span><span class="nb">cd</span> ../lbdex/verilog/
1-160-136-173:verilog Jonathan<span class="nv">$ </span>./cpu0IIs
</pre></div>
</div>
<p>The verilog machine cpu0IIs include all instructions of cpu032I and add
slt, beq, ..., instructions.
Run build-printf-stdarg-2.sh with cpu=cpu032II will generate slt, beq and bne
instructions instead of cmp, jeq, ... instructions.</p>
<p>With the printf() of GPL source code, we can program more test code with it
to verify the previous llvm Cpu0 backend generated program. The following code
is for this purpose.</p>
<p class="rubric">exlbt/input/debug.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &quot;debug.h&quot;</span>

<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kt">int</span> <span class="n">printf</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">format</span><span class="p">,</span> <span class="p">...);</span>

<span class="c1">// With read variable form asm, such as sw in this example, the function, </span>
<span class="c1">// ISR_Handler() must entry from beginning. The ISR() enter from &quot;ISR:&quot; will</span>
<span class="c1">// has incorrect value for reload instruction in offset. </span>
<span class="c1">// For example, the correct one is: </span>
<span class="c1">//   &quot;addiu $sp, $sp, -12&quot;</span>
<span class="c1">//   &quot;mov $fp, $sp&quot;</span>
<span class="c1">// ISR:</span>
<span class="c1">//   &quot;ld $2, 32($fp)&quot;</span>
<span class="c1">// Go to ISR directly, then the $fp is 12+ than original, then it will get</span>
<span class="c1">//   &quot;ld $2, 20($fp)&quot; actually.</span>
<span class="kt">void</span> <span class="nf">ISR_Handler</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">SAVE_REGISTERS</span><span class="p">;</span>
  <span class="k">asm</span><span class="p">(</span><span class="s">&quot;lui $7, 0xffff&quot;</span><span class="p">);</span>
  <span class="k">asm</span><span class="p">(</span><span class="s">&quot;ori $7, $7, 0xfdff&quot;</span><span class="p">);</span>
  <span class="k">asm</span><span class="p">(</span><span class="s">&quot;and $sw, $sw, $7&quot;</span><span class="p">);</span> <span class="c1">// clear `IE</span>

  <span class="k">volatile</span> <span class="kt">int</span> <span class="n">sw</span><span class="p">;</span>
  <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&quot;addiu %0, $sw, 0&quot;</span>
                       <span class="o">:</span><span class="s">&quot;=r&quot;</span><span class="p">(</span><span class="n">sw</span><span class="p">)</span>
                       <span class="p">);</span>
  <span class="kt">int</span> <span class="n">interrupt</span> <span class="o">=</span> <span class="p">(</span><span class="n">sw</span> <span class="o">&amp;</span> <span class="n">INT</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">softint</span> <span class="o">=</span> <span class="p">(</span><span class="n">sw</span> <span class="o">&amp;</span> <span class="n">SOFTWARE_INT</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">overflow</span> <span class="o">=</span> <span class="p">(</span><span class="n">sw</span> <span class="o">&amp;</span> <span class="n">OVERFLOW</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">int1</span> <span class="o">=</span> <span class="p">(</span><span class="n">sw</span> <span class="o">&amp;</span> <span class="n">INT1</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">int2</span> <span class="o">=</span> <span class="p">(</span><span class="n">sw</span> <span class="o">&amp;</span> <span class="n">INT2</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">interrupt</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">softint</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">overflow</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Overflow exception</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="n">CLEAR_OVERFLOW</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Software interrupt</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="n">CLEAR_SOFTWARE_INT</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">int1</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Harware interrupt 0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
      <span class="k">asm</span><span class="p">(</span><span class="s">&quot;lui $7, 0xffff&quot;</span><span class="p">);</span>
      <span class="k">asm</span><span class="p">(</span><span class="s">&quot;ori $7, $7, 0x7fff&quot;</span><span class="p">);</span>
      <span class="k">asm</span><span class="p">(</span><span class="s">&quot;and $sw, $sw, $7&quot;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">int2</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Harware interrupt 1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
      <span class="k">asm</span><span class="p">(</span><span class="s">&quot;lui $7, 0xfffe&quot;</span><span class="p">);</span>
      <span class="k">asm</span><span class="p">(</span><span class="s">&quot;ori $7, $7, 0xffff&quot;</span><span class="p">);</span>
      <span class="k">asm</span><span class="p">(</span><span class="s">&quot;and $sw, $sw, $7&quot;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">asm</span><span class="p">(</span><span class="s">&quot;lui $7, 0xffff&quot;</span><span class="p">);</span>
    <span class="k">asm</span><span class="p">(</span><span class="s">&quot;ori $7, $7, 0xdfff&quot;</span><span class="p">);</span>
    <span class="k">asm</span><span class="p">(</span><span class="s">&quot;and $sw, $sw, $7&quot;</span><span class="p">);</span> <span class="c1">// clear `I</span>
  <span class="p">}</span>
  <span class="k">asm</span><span class="p">(</span><span class="s">&quot;ori $sw, $sw, 0x200&quot;</span><span class="p">);</span> <span class="c1">// int enable</span>
  <span class="n">RESTORE_REGISTERS</span><span class="p">;</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ISR</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">asm</span><span class="p">(</span><span class="s">&quot;ISR:&quot;</span><span class="p">);</span>
  <span class="k">asm</span><span class="p">(</span><span class="s">&quot;lui $at, 7&quot;</span><span class="p">);</span>
  <span class="k">asm</span><span class="p">(</span><span class="s">&quot;ori $at, $at, 0xff00&quot;</span><span class="p">);</span>
  <span class="k">asm</span><span class="p">(</span><span class="s">&quot;st $14, 48($at)&quot;</span><span class="p">);</span>
  <span class="n">ISR_Handler</span><span class="p">();</span>
  <span class="k">asm</span><span class="p">(</span><span class="s">&quot;lui $at, 7&quot;</span><span class="p">);</span>
  <span class="k">asm</span><span class="p">(</span><span class="s">&quot;ori $at, $at, 0xff00&quot;</span><span class="p">);</span>
  <span class="k">asm</span><span class="p">(</span><span class="s">&quot;ld $14, 48($at)&quot;</span><span class="p">);</span>
  <span class="k">asm</span><span class="p">(</span><span class="s">&quot;c0mov $pc, $epc&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">int_sim</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">asm</span><span class="p">(</span><span class="s">&quot;ori $sw, $sw, 0x200&quot;</span><span class="p">);</span> <span class="c1">// int enable</span>
  <span class="k">asm</span><span class="p">(</span><span class="s">&quot;ori $sw, $sw, 0x2000&quot;</span><span class="p">);</span> <span class="c1">// set interrupt</span>
  <span class="k">asm</span><span class="p">(</span><span class="s">&quot;ori $sw, $sw, 0x4000&quot;</span><span class="p">);</span> <span class="c1">// Software interrupt</span>
  <span class="k">asm</span><span class="p">(</span><span class="s">&quot;ori $sw, $sw, 0x200&quot;</span><span class="p">);</span> <span class="c1">// int enable</span>
  <span class="k">asm</span><span class="p">(</span><span class="s">&quot;ori $sw, $sw, 0x2000&quot;</span><span class="p">);</span> <span class="c1">// set interrupt</span>
  <span class="k">asm</span><span class="p">(</span><span class="s">&quot;ori $sw, $sw, 0x8000&quot;</span><span class="p">);</span> <span class="c1">// hardware interrupt 0</span>
  <span class="k">asm</span><span class="p">(</span><span class="s">&quot;ori $sw, $sw, 0x200&quot;</span><span class="p">);</span> <span class="c1">// int enable</span>
  <span class="k">asm</span><span class="p">(</span><span class="s">&quot;ori $sw, $sw, 0x2000&quot;</span><span class="p">);</span> <span class="c1">// set interrupt</span>
  <span class="k">asm</span><span class="p">(</span><span class="s">&quot;lui $at, 1&quot;</span><span class="p">);</span>
  <span class="k">asm</span><span class="p">(</span><span class="s">&quot;or $sw, $sw, $at&quot;</span><span class="p">);</span> <span class="c1">// hardware interrupt 1</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">exlbt/input/ch_lld_staticlink.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &quot;debug.h&quot;</span>
<span class="cp">#include &quot;print.h&quot;</span>

<span class="cp">#define PRINT_TEST</span>

<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kt">int</span> <span class="n">printf</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">format</span><span class="p">,</span> <span class="p">...);</span>
<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kt">int</span> <span class="n">sprintf</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">format</span><span class="p">,</span> <span class="p">...);</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">sBuffer</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="nf">test_overflow</span><span class="p">();</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="nf">test_add_overflow</span><span class="p">();</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="nf">test_sub_overflow</span><span class="p">();</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="nf">test_ctrl2</span><span class="p">();</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="nf">select_1</span><span class="p">();</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="nf">select_2</span><span class="p">();</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="nf">select_3</span><span class="p">();</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="nf">test_select_global_pic</span><span class="p">();</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="nf">test_tailcall</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="nf">test_alloc</span><span class="p">();</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="nf">test_staticlink</span><span class="p">();</span>
</pre></div>
</div>
<p class="rubric">exlbt/input/ch_lld_staticlink.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &quot;ch6_1.cpp&quot;</span>
<span class="cp">#include &quot;ch9_2_1.cpp&quot;</span>
<span class="cp">#include &quot;ch9_2_2.cpp&quot;</span>
<span class="cp">#include &quot;ch9_3_2.cpp&quot;</span>
<span class="cp">#include &quot;ch11_2.cpp&quot;</span>
<span class="cp">#include &quot;ch12_inherit.cpp&quot;</span>

<span class="kt">int</span> <span class="nf">verify_test_ctrl2</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

  <span class="n">sBuffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="mh">0x35</span><span class="p">;</span>
  <span class="n">sBuffer</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="mh">0x35</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_ctrl2</span><span class="p">();</span>
  <span class="n">sBuffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="mh">0x30</span><span class="p">;</span>
  <span class="n">sBuffer</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="mh">0x29</span><span class="p">;</span>
  <span class="n">b</span> <span class="o">=</span> <span class="n">test_ctrl2</span><span class="p">();</span>
  <span class="n">sBuffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="mh">0x35</span><span class="p">;</span>
  <span class="n">sBuffer</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="mh">0x35</span><span class="p">;</span>
  <span class="n">c</span> <span class="o">=</span> <span class="n">test_ctrl2</span><span class="p">();</span>
  <span class="n">sBuffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="mh">0x34</span><span class="p">;</span>
  <span class="n">d</span> <span class="o">=</span> <span class="n">test_ctrl2</span><span class="p">();</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;test_ctrl2(): a = %d, b = %d, c = %d, d = %d&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;, PASS</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="k">else</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;, FAIL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">test_staticlink</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">a</span> <span class="o">=</span> <span class="n">test_add_overflow</span><span class="p">();</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_sub_overflow</span><span class="p">();</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_global</span><span class="p">();</span>  <span class="c1">// gI = 100</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;global variable gI = %d&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="mi">100</span><span class="p">)</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;, PASS</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="k">else</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;, FAIL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">verify_test_ctrl2</span><span class="p">();</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">select_1</span><span class="p">();</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;select_1() = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span> <span class="c1">// a = 1</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">select_2</span><span class="p">();</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;select_2() = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span> <span class="c1">// a = 1</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">select_3</span><span class="p">();</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;select_3() = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span> <span class="c1">// a = 1</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_select_global_pic</span><span class="p">();</span> <span class="c1">// test global of pic llc -O1 option</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;test_select_global_pic() = %d&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span> <span class="c1">// a = 100</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="mi">100</span><span class="p">)</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;, PASS</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="k">else</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;, FAIL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_tailcall</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;test_tailcall(5) = %d&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span> <span class="c1">// a = 120</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="mi">120</span><span class="p">)</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;, PASS</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="k">else</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;, FAIL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_func_arg_struct</span><span class="p">();</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_contructor</span><span class="p">();</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_template</span><span class="p">();</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;test_template() = %d&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span> <span class="c1">// a = 15</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="mi">15</span><span class="p">)</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;, PASS</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="k">else</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;, FAIL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_alloc</span><span class="p">();</span>  <span class="c1">// 31</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;test_alloc() = %d&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="mi">31</span><span class="p">)</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;, PASS</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="k">else</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;, FAIL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_inlineasm</span><span class="p">();</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;test_inlineasm() = %d&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span> <span class="c1">// a = 53</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="mi">53</span><span class="p">)</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;, PASS</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="k">else</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;, FAIL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_cpp_polymorphism</span><span class="p">();</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;test_cpp_polymorphism() = %d&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span> <span class="c1">// a = 0</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;, PASS</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="k">else</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;, FAIL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">test_build</span><span class="p">();</span>

  <span class="n">int_sim</span><span class="p">();</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">exlbt/input/ch_slinker.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//#define TEST_SELECT</span>

<span class="cp">#include &quot;ch_nolld.h&quot;</span>
<span class="cp">#include &quot;ch_lld_staticlink.h&quot;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">bool</span> <span class="n">pass</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="n">pass</span> <span class="o">=</span> <span class="n">test_nolld</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">pass</span><span class="p">)</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;test_nolld(): PASS</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="k">else</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;test_nolld(): FAIL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">pass</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="n">pass</span> <span class="o">=</span> <span class="n">test_staticlink</span><span class="p">();</span>

  <span class="k">return</span> <span class="n">pass</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#include &quot;ch_nolld.cpp&quot;</span>
<span class="cp">#include &quot;ch_lld_staticlink.cpp&quot;</span>
</pre></div>
</div>
<p class="rubric">exlbt/input/build-slinker.sh</p>
<div class="highlight-c++"><pre>#!/usr/bin/env bash

source functions.sh

sh_name=build-slinker.sh
argNum=$#
arg1=$1
arg2=$2

prologue;

clang -target mips-unknown-linux-gnu -c start.cpp -emit-llvm -o start.bc
clang -target mips-unknown-linux-gnu -c debug.cpp -emit-llvm -o debug.bc
clang -target mips-unknown-linux-gnu -c printf-stdarg-def.c -emit-llvm \
-o printf-stdarg-def.bc
clang -target mips-unknown-linux-gnu -c printf-stdarg.c -emit-llvm \
-o printf-stdarg.bc
clang -target mips-unknown-linux-gnu -c ${LBDEXDIR}/input/ch4_1_2.cpp -emit-llvm -o ch4_1_2.bc
clang -O1 -target mips-unknown-linux-gnu -c ${LBDEXDIR}/input/ch8_1_5.cpp -emit-llvm -o ch8_1_5.bc
clang -O1 -target mips-unknown-linux-gnu -c ${LBDEXDIR}/input/ch8_3.cpp -emit-llvm -o ch8_3.bc
clang -O1 -target mips-unknown-linux-gnu -c ${LBDEXDIR}/input/ch8_5.cpp -emit-llvm -o ch8_5.bc
clang -O1 -target mips-unknown-linux-gnu -c ${LBDEXDIR}/input/ch9_2_3_tailcall.cpp -emit-llvm -o \
ch9_2_3_tailcall.bc
clang -c ${LBDEXDIR}/input/ch9_4.cpp -emit-llvm -o ch9_4.bc
clang -I${LBDEXDIR}/input/ -target mips-unknown-linux-gnu -c ch_slinker.cpp -emit-llvm \
-o ch_slinker.bc
${TOOLDIR}/llc -march=cpu0${endian} -mcpu=${CPU} -relocation-model=static \
-filetype=obj start.bc -o start.cpu0.o
${TOOLDIR}/llc -march=cpu0${endian} -mcpu=${CPU} -relocation-model=static \
-filetype=obj debug.bc -o debug.cpu0.o
${TOOLDIR}/llc -march=cpu0${endian} -mcpu=${CPU} -relocation-model=static \
-filetype=obj printf-stdarg-def.bc -o printf-stdarg-def.cpu0.o
${TOOLDIR}/llc -march=cpu0${endian} -mcpu=${CPU} -relocation-model=static \
-filetype=obj printf-stdarg.bc -o printf-stdarg.cpu0.o
${TOOLDIR}/llc -march=cpu0${endian} -mcpu=${CPU} -relocation-model=static \
-filetype=obj -cpu0-enable-overflow=true ch4_1_2.bc -o ch4_1_2.cpu0.o
${TOOLDIR}/llc -march=cpu0${endian} -mcpu=${CPU} -relocation-model=static \
-filetype=obj ch8_1_5.bc -o ch8_1_5.cpu0.o
${TOOLDIR}/llc -march=cpu0${endian} -mcpu=${CPU} -relocation-model=static \
-filetype=obj ch8_3.bc -o ch8_3.cpu0.o
${TOOLDIR}/llc -march=cpu0${endian} -mcpu=${CPU} -relocation-model=static \
-filetype=obj ch8_5.bc -o ch8_5.cpu0.o
${TOOLDIR}/llc -march=cpu0${endian} -mcpu=${CPU} -relocation-model=static \
-filetype=obj -enable-cpu0-tail-calls ch9_2_3_tailcall.bc -o \
ch9_2_3_tailcall.cpu0.o
${TOOLDIR}/llc -march=cpu0${endian} -mcpu=${CPU} -relocation-model=static \
-filetype=obj ch9_4.bc -o ch9_4.cpu0.o
${TOOLDIR}/llc -march=cpu0${endian} -mcpu=${CPU} -relocation-model=static \
-filetype=obj ch_slinker.bc -o ch_slinker.cpu0.o
${TOOLDIR}/llc -march=cpu0${endian} -mcpu=${CPU} -relocation-model=static \
-filetype=obj lib_cpu0.ll -o lib_cpu0.o
${TOOLDIR}/lld -flavor gnu -target cpu0${endian}-unknown-linux-gnu start.cpu0.o \
debug.cpu0.o printf-stdarg-def.cpu0.o printf-stdarg.cpu0.o ch4_1_2.cpu0.o \
ch8_1_5.cpu0.o ch8_3.cpu0.o ch8_5.cpu0.o ch9_2_3_tailcall.cpu0.o ch9_4.cpu0.o \
ch_slinker.cpu0.o lib_cpu0.o -o a.out

epilogue;

</pre>
</div>
<div class="highlight-bash"><div class="highlight"><pre>1-160-136-173:input Jonathan<span class="nv">$ </span><span class="nb">pwd</span>
/Users/Jonathan/test/lbt/exlbt/input
114-37-148-111:input Jonathan<span class="nv">$ </span>bash build-slinker.sh cpu032I le
...
In file included from ch_slinker.cpp:23:
./ch_lld_staticlink.cpp:8:15: warning: conversion from string literal to
<span class="s1">&#39;char *&#39;</span> is deprecated
      <span class="o">[</span>-Wdeprecated-writable-strings<span class="o">]</span>
  char *ptr <span class="o">=</span> <span class="s2">&quot;Hello world!&quot;</span>;
              ^
1 warning generated.
114-37-148-111:input Jonathan<span class="nv">$ </span><span class="nb">cd</span> ../../lbdex/verilog/
114-37-148-111:verilog Jonathan<span class="nv">$ </span>./cpu0IIs
WARNING: ./cpu0.v:369: <span class="nv">$readmemh</span><span class="o">(</span>cpu0.hex<span class="o">)</span>: Not enough words in the file <span class="k">for</span>
the requested range <span class="o">[</span>0:524287<span class="o">]</span>.
taskInterrupt<span class="o">(</span>001<span class="o">)</span>
74
253
3
1
14
3
-126
130
-32766
32770
393307
16777222
51
2
2147483647
-2147483648
7
15
test_nolld<span class="o">()</span>: PASS
taskInterrupt<span class="o">(</span>011<span class="o">)</span>
Overflow exception
taskInterrupt<span class="o">(</span>011<span class="o">)</span>
Overflow exception
<span class="nv">test_overflow</span> <span class="o">=</span> 0, PASS
global variable <span class="nv">gI</span> <span class="o">=</span> 100, PASS
test_ctrl2<span class="o">()</span>: <span class="nv">a</span> <span class="o">=</span> 1, <span class="nv">b</span> <span class="o">=</span> 0, <span class="nv">c</span> <span class="o">=</span> 1, <span class="nv">d</span> <span class="o">=</span> 0, PASS
select_1<span class="o">()</span> <span class="o">=</span> 1
select_2<span class="o">()</span> <span class="o">=</span> 1
select_3<span class="o">()</span> <span class="o">=</span> 1
test_select_global_pic<span class="o">()</span> <span class="o">=</span> 100, PASS
test_tailcall<span class="o">(</span>5<span class="o">)</span> <span class="o">=</span> 120, PASS
<span class="nv">date1</span> <span class="o">=</span> 2012 10 12 1 2 3, PASS
<span class="nv">date2</span> <span class="o">=</span> 2012 10 12 1 2 3, PASS
<span class="nv">time2</span> <span class="o">=</span> 1 10 12, PASS
<span class="nv">time3</span> <span class="o">=</span> 1 10 12, PASS
<span class="nv">date1</span> <span class="o">=</span> 2013 1 26 12 21 10, PASS
<span class="nv">date2</span> <span class="o">=</span> 2013 1 26 12 21 10, PASS
test_template<span class="o">()</span> <span class="o">=</span> 15, PASS
test_alloc<span class="o">()</span> <span class="o">=</span> 31, PASS
test_inlineasm<span class="o">()</span> <span class="o">=</span> 53, PASS
20
10
5
test_cpp_polymorphism<span class="o">()</span> <span class="o">=</span> 0, PASS
taskInterrupt<span class="o">(</span>011<span class="o">)</span>
Software interrupt
taskInterrupt<span class="o">(</span>011<span class="o">)</span>
Harware interrupt 0
taskInterrupt<span class="o">(</span>011<span class="o">)</span>
Harware interrupt 1
total cpu <span class="nv">cycles</span> <span class="o">=</span> 252660
RET to PC &lt; 0, finished!
</pre></div>
</div>
<p>As above, by taking the open source code advantage, Cpu0 got the more stable
printf() program.
Once Cpu0 backend can translate the printf() function of the open source C
printf() program into machine instructions, the llvm Cpu0 backend can be
verified with printf().
With the quality code of open source printf() program, the Cpu0 toolchain is
extended from compiler backend to C std library support. (Notice that some GPL
open source code are not quality code, but some are.)</p>
<p>The &#8220;Overflow exception is printed twice meaning the ISR() of debug.cpp is
called twice from ch4_1_2.cpp.
The printed &#8220;taskInterrupt(001)&#8221; and &#8220;taskInterrupt(011)&#8221; just are trace
message from cpu0.v code.</p>
</div>
<div class="section" id="cpu0-lld-structure">
<h4><a class="toc-backref" href="#id50">Cpu0 lld structure</a><a class="headerlink" href="#cpu0-lld-structure" title="Permalink to this headline">¶</a></h4>
<div class="figure align-center" id="lld-f1">
<a class="reference internal image-reference" href="_images/12.png"><img alt="_images/12.png" src="_images/12.png" /></a>
<p class="caption">Figure 5: Cpu0 lld class relationship</p>
</div>
<div class="figure align-center" id="lld-f2">
<a class="reference internal image-reference" href="_images/2.png"><img alt="_images/2.png" src="_images/2.png" /></a>
<p class="caption">Figure 6: Cpu0 lld ELFLinkingContext and DefaultLayout member functions</p>
</div>
<p>The Cpu0LinkingContext include the context information for those input obj
files and output execution file you want to link.
When do linking, the following code will create Cpu0LinkingContext.</p>
<p class="rubric">exlbt/lld/ELFLinkingContext.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">ELFLinkingContext</span> <span class="o">:</span> <span class="k">public</span> <span class="n">LinkingContext</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="p">...</span>
  <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ELFLinkingContext</span><span class="o">&gt;</span> <span class="n">create</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">Triple</span><span class="p">);</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">exlbt/lld/ELFLinkingContext.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ELFLinkingContext</span><span class="o">&gt;</span>
<span class="n">ELFLinkingContext</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">Triple</span> <span class="n">triple</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">triple</span><span class="p">.</span><span class="n">getArch</span><span class="p">())</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="k">case</span> <span class="n">llvm</span>:<span class="o">:</span><span class="n">Triple</span><span class="o">::</span><span class="n">cpu0</span><span class="o">:</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ELFLinkingContext</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="k">new</span> <span class="n">lld</span><span class="o">::</span><span class="n">elf</span><span class="o">::</span><span class="n">Cpu0LinkingContext</span><span class="p">(</span><span class="n">triple</span><span class="p">));</span>
  <span class="nl">default:</span>
    <span class="k">return</span> <span class="n">nullptr</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>While Cpu0LinkingContext is created by lld ELF driver as above, the following
code in Cpu0LinkingContext constructor will create Cpu0TargetHandler and passing
the Cpu0LinkingContext object pointer to Cpu0TargeHandler.</p>
<p class="rubric">exlbt/lld/Cpu0/Cpu0LinkingContext.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Cpu0LinkingContext</span> <span class="n">LLVM_FINAL</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ELFLinkingContext</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Cpu0LinkingContext</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">Triple</span> <span class="n">triple</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">ELFLinkingContext</span><span class="p">(</span><span class="n">triple</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">TargetHandlerBase</span><span class="o">&gt;</span><span class="p">(</span>
                                  <span class="k">new</span> <span class="n">Cpu0TargetHandler</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">)))</span> <span class="p">{}</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Finally, the Cpu0TargeHandler constructor will create other related objects
and set up the relation reference object pointers as <a class="pageref" href="#lld-f1">Figure  5</a>
depicted by the following code.</p>
<p class="rubric">exlbt/lld/Cpu0/Cpu0TargetHandler.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Cpu0TargetHandler</span><span class="o">::</span><span class="n">Cpu0TargetHandler</span><span class="p">(</span><span class="n">Cpu0LinkingContext</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">DefaultTargetHandler</span><span class="p">(</span><span class="n">context</span><span class="p">),</span> <span class="n">_gotFile</span><span class="p">(</span><span class="k">new</span> <span class="n">GOTFile</span><span class="p">(</span><span class="n">context</span><span class="p">)),</span>
      <span class="n">_relocationHandler</span><span class="p">(</span><span class="n">context</span><span class="p">),</span> <span class="n">_targetLayout</span><span class="p">(</span><span class="n">context</span><span class="p">)</span> <span class="p">{}</span>
</pre></div>
</div>
<p>According chapter ELF, the linker stands for resolve the relocation records.
The following code give the chance to let lld system call our relocation
function at proper time.</p>
<p class="rubric">exlbt/lld/Cpu0/Cpu0RelocationPass.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Pass</span><span class="o">&gt;</span>
<span class="n">lld</span><span class="o">::</span><span class="n">elf</span><span class="o">::</span><span class="n">createCpu0RelocationPass</span><span class="p">(</span><span class="k">const</span> <span class="n">Cpu0LinkingContext</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">ctx</span><span class="p">.</span><span class="n">getOutputELFType</span><span class="p">())</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">llvm</span>:<span class="o">:</span><span class="n">ELF</span><span class="o">::</span><span class="n">ET_EXEC</span><span class="o">:</span>
  <span class="c1">// when the output file is execution file: e.g. a.out</span>
<span class="cp">#ifdef DLINKER</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="p">.</span><span class="n">isDynamic</span><span class="p">())</span>
    <span class="c1">// when the a.out refer to shared object *.so</span>
      <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Pass</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">DynamicRelocationPass</span><span class="p">(</span><span class="n">ctx</span><span class="p">));</span>
    <span class="k">else</span>
<span class="cp">#endif </span><span class="c1">// DLINKER</span>
      <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Pass</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">StaticRelocationPass</span><span class="p">(</span><span class="n">ctx</span><span class="p">));</span>
<span class="cp">#ifdef DLINKER</span>
  <span class="k">case</span> <span class="n">llvm</span>:<span class="o">:</span><span class="n">ELF</span><span class="o">::</span><span class="n">ET_DYN</span><span class="o">:</span>
  <span class="c1">// when the output file is shared object: e.g. foobar.so</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Pass</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">DynamicRelocationPass</span><span class="p">(</span><span class="n">ctx</span><span class="p">));</span>
<span class="cp">#endif </span><span class="c1">// DLINKER</span>
  <span class="k">case</span> <span class="n">llvm</span>:<span class="o">:</span><span class="n">ELF</span><span class="o">::</span><span class="n">ET_REL</span><span class="o">:</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Pass</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="nl">default:</span>
    <span class="n">llvm_unreachable</span><span class="p">(</span><span class="s">&quot;Unhandled output file type&quot;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The &#8220;#ifdef DLINKER&#8221; part is for dynamic linker which will be used in next
section.
For static linker, a StaticRelocationPass object is created and return.</p>
<p>Now the following code of Cpu0TargetRelocationHandler::applyRelocation()
will be called through
Cpu0TargetHandler by lld ELF driver when it meets each relocation record.</p>
<p class="rubric">exlbt/lld/Cpu0/Cpu0RelocationHandler.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">ErrorOr</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">Cpu0TargetRelocationHandler</span><span class="o">::</span><span class="n">applyRelocation</span><span class="p">(</span>
    <span class="n">ELFWriter</span> <span class="o">&amp;</span><span class="n">writer</span><span class="p">,</span> <span class="n">llvm</span><span class="o">::</span><span class="n">FileOutputBuffer</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="n">lld</span><span class="o">::</span><span class="n">AtomLayout</span> <span class="o">&amp;</span><span class="n">atom</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">Reference</span> <span class="o">&amp;</span><span class="n">ref</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>

  <span class="k">switch</span> <span class="p">(</span><span class="n">ref</span><span class="p">.</span><span class="n">kind</span><span class="p">())</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">R_CPU0_NONE</span>:
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">R_CPU0_HI16</span>:
    <span class="n">relocHI16</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">relocVAddress</span><span class="p">,</span> <span class="n">targetVAddress</span><span class="p">,</span> <span class="n">ref</span><span class="p">.</span><span class="n">addend</span><span class="p">());</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">R_CPU0_LO16</span>:
    <span class="n">relocLO16</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">relocVAddress</span><span class="p">,</span> <span class="n">targetVAddress</span><span class="p">,</span> <span class="n">ref</span><span class="p">.</span><span class="n">addend</span><span class="p">());</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="p">...</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">error_code</span><span class="o">::</span><span class="n">success</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">exlbt/lld/Cpu0/Cpu0TargetHandler.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Cpu0TargetHandler</span> <span class="n">LLVM_FINAL</span>
    <span class="o">:</span> <span class="k">public</span> <span class="n">DefaultTargetHandler</span><span class="o">&lt;</span><span class="n">Cpu0ELFType</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="p">..</span>
  <span class="k">virtual</span> <span class="k">const</span> <span class="n">Cpu0TargetRelocationHandler</span> <span class="o">&amp;</span><span class="n">getRelocationHandler</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">_relocationHandler</span><span class="p">;</span>
  <span class="p">}</span>
</pre></div>
</div>
<p>Summary as <a class="pageref" href="#lld-f4">Figure  7</a>.</p>
<div class="figure align-center" id="lld-f4">
<a class="reference internal image-reference" href="_images/4.png"><img alt="_images/4.png" src="_images/4.png" /></a>
<p class="caption">Figure 7: Cpu0 lld related objects created sequence</p>
</div>
<p>Remind, static std::unique_ptr&lt;ELFLinkingContext&gt;
ELFLinkingContext::create(llvm::Triple) is called without an object of
class ELFLinkingContext instance (because the static keyword).
The Cpu0LinkingContext constructor will create it&#8217;s ELFLinkingContext part.
The std::unique_ptr came from c++11 standard.
The unique_ptr objects automatically delete the object they manage (using a
deleter) as soon as themselves are destroyed. Just like the Singlelten
pattern in Design Pattern book or Smart Pointers in Effective C++ book. <a class="footnote-reference" href="#id22" id="id4">[4]</a></p>
<div class="figure align-center" id="lld-f5">
<a class="reference internal image-reference" href="_images/5.png"><img alt="_images/5.png" src="_images/5.png" /></a>
<p class="caption">Figure 8: Cpu0LinkingContext get Cpu0TargetHandler through &amp;getTargetHandler()</p>
</div>
<p>As <a class="pageref" href="#lld-f1">Figure  5</a> depicted, the Cpu0TargetHandler include the members or
pointers which can access to other object. The way to access Cpu0TargetHandler
object from Cpu0LinkingContext or Cpu0RelocationHandler rely on
LinkingContext::getTargetHandler() function. As <a class="pageref" href="#lld-f5">Figure  8</a> depicted,
the unique_ptr point to Cpu0TargetHandler will be saved in LinkingContext
contructor function.</p>
<p>List the c++11 unique_ptr::get() and move() which used in <a class="pageref" href="#lld-f5">Figure  8</a>
as follows.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>std::unique_ptr::get() <a class="footnote-reference" href="#id23" id="id5">[5]</a></p>
<p>pointer get() const noexcept;</p>
<p class="last">Get pointer
Returns the stored pointer.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>std::move() <a class="footnote-reference" href="#id24" id="id6">[6]</a></p>
<dl class="last docutils">
<dt>for example:</dt>
<dd><p class="first">std::string bar = &#8220;bar-string&#8221;;
std::move(bar);</p>
<p class="last">bar is null after std::move(bar);</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="section" id="dynamic-linker">
<h3><a class="toc-backref" href="#id51">Dynamic linker</a><a class="headerlink" href="#dynamic-linker" title="Permalink to this headline">¶</a></h3>
<p>In addition to the lld code with #ifdef DLINKER. The following code in Verilog
exists to support dynamic linker.</p>
<p class="rubric">lbdex/verilog/dynlinker.v</p>
<div class="highlight-c++"><pre>`define DLINKER_INFO_ADDR  'h70000
`define GPADDR    'h7FFF0

`ifdef DLINKER
  task setDynLinkerInfo; begin
// below code set memory as follows,
//                                                            (4 bytes) 
//                                                      ---------------------------------------
// DLINKER_INFO_ADDR ----------&gt;                        | numDynEntry                         |
//                                                      ---------------------------------------
// DLINKER_INFO_ADDR+4 --------&gt;                        | index of dynsym (0st row)           |
//   above is the 1st word of section .dynsym of libfoobar.cpu0.so. 
// DLINKER_INFO_ADDR+8 --------&gt;                        | index of dynsym (1st row)           |
//                                                      | ...                                 |
// DLINKER_INFO_ADDR+(numDynEntry-1)*4 ---------------&gt; | index of dynsym (the last row)      |
//                                                      ---------------------------------------
// DLINKER_INFO_ADDR+numDynEntry*4 -------------------&gt; | 1st function (la()) offset in lib   |
// DLINKER_INFO_ADDR+numDynEntry*4+4 -----------------&gt; | 1st function (la()) name (48 bytes) |
//                                                      | ...                                 |
// DLINKER_INFO_ADDR+numDynEntry+(numDynEntry-1)*4 ---&gt; | last function (bar()) offset in lib |
// DLINKER_INFO_ADDR+numDynEntry+(numDynEntry-1)*4+4 -&gt; | last function (bar()) name          |
//                                                      ---------------------------------------
// DLINKER_INFO_ADDR+4+numDynEntry*4+numDynEntry*52 --&gt; | .dynstr of lib                      |
//                                                      |   ...                               |
//                                                      ---------------------------------------
  // caculate number of dynamic entries
    numDynEntry = 0;
    j = 0;
    for (i=0; i &lt; 384 &amp;&amp; j == 0; i=i+52) begin
       if (so_func_offset[i] == `MEMEMPTY &amp;&amp; so_func_offset[i+1] == `MEMEMPTY &amp;&amp; 
           so_func_offset[i+2] == `MEMEMPTY &amp;&amp; so_func_offset[i+3] == `MEMEMPTY) begin
         numDynEntry = i/52;
         j = 1;
       `ifdef DEBUG_DLINKER
         $display("numDynEntry = %8x", numDynEntry);
       `endif
       end
    end
  // save number of dynamic entries to memory address `DLINKER_INFO_ADDR
    m[`DLINKER_INFO_ADDR] = numDynEntry[31:24];
    m[`DLINKER_INFO_ADDR+1] = numDynEntry[23:16];
    m[`DLINKER_INFO_ADDR+2] = numDynEntry[15:8];
    m[`DLINKER_INFO_ADDR+3] = numDynEntry[7:0];
  // copy section .dynsym of ELF to memory address `DLINKER_INFO_ADDR+4
    i = `DLINKER_INFO_ADDR+4;
    for (j=0; j &lt; (4*numDynEntry); j=j+4) begin
      m[i] = dsym[j];
      m[i+1] = dsym[j+1];
      m[i+2] = dsym[j+2];
      m[i+3] = dsym[j+3];
      i = i + 4;
    end
  // copy the offset values of section .text of shared library .so of ELF to 
  // memory address `DLINKER_INFO_ADDR+4+numDynEntry*4
    i = `DLINKER_INFO_ADDR+4+numDynEntry*4;
    l = 0;
    for (j=0; j &lt; numDynEntry; j=j+1) begin
      for (k=0; k &lt; 52; k=k+1) begin
        m[i] = so_func_offset[l];
        i = i + 1;
        l = l + 1;
      end
    end
  `ifdef DEBUG_DLINKER
    i = `DLINKER_INFO_ADDR+4+numDynEntry*4;
    for (j=0; j &lt; (8*numDynEntry); j=j+8) begin
       $display("%8x: %8x", i, {m[i], m[i+1], m[i+2], m[i+3]});
      i = i + 8;
    end
  `endif
  // copy section .dynstr of ELF to memory address 
  // `DLINKER_INFO_ADDR+4+numDynEntry*4+numDynEntry*52
    i=`DLINKER_INFO_ADDR+4+numDynEntry*4+numDynEntry*52;
    for (j=0; dstr[j] != `MEMEMPTY; j=j+1) begin
      m[i] = dstr[j];
      i = i + 1;
    end
  `ifdef DEBUG_DLINKER
    $display("In setDynLinkerInfo()");
    for (i=`DLINKER_INFO_ADDR; i &lt; `MEMSIZE; i=i+4) begin
       if (m[i] != `MEMEMPTY || m[i+1] != `MEMEMPTY || 
         m[i+2] != `MEMEMPTY || m[i+3] != `MEMEMPTY)
         $display("%8x: %8x", i, {m[i], m[i+1], m[i+2], m[i+3]});
    end
    $display("global address %8x", {m[`GPADDR], m[`GPADDR+1], 
             m[`GPADDR+2], m[`GPADDR+3]});
    $display("gp = %8x", gp);
  `endif
// below code set memory as follows,
//                                    -----------------------------------
// gp ------------------------------&gt; | all 0                           | (16 bytes)
// gp+16 ---------------------------&gt; | 0                          |
// gp+16+1*4 -----------------------&gt; | 1st plt entry address      | (4 bytes)
//                                    | ...                        |
// gp+16+(numDynEntry-1)*4 ---------&gt; | the last plt entry address |
//                                    -----------------------------------
// gpPlt ---------------------------&gt; | all 0                           | (16 bytes)
// gpPlt+16+0*8'h10 ----------------&gt; | 32'h10: pointer to plt0         |
// gpPlt+16+1*8'h10 ----------------&gt; | 1st plt entry                   |
// gpPlt+16+2*8'h10 ----------------&gt; | 2nd plt entry                   |
//                                    | ...                             |
// gpPlt+16+(numDynEntry-1)*8'h10 --&gt; | the last plt entry              |
//                                    -----------------------------------
// note: gp point to the _GLOBAL_OFFSET_TABLE_, 
//       numDynEntry = actual number of functions + 1.
//   gp+1*4..gp+numDynEntry*4 set to 8'h10 plt0 which will jump to dynamic 
//   linker.
//   After dynamic linker load function to memory, it will set gp+index*4 to 
//   function memory address. For example, if the function index is 2, then the 
//   gp+2*4 is set to the memory address of this loaded function. 
//   Then the the caller call 
//   "ld $t9, 2*4($gp)" and "ret $t9" will jump to this loaded function directly.

    gpPlt = gp+16+numDynEntry*4;
    // set (gpPlt-16..gpPlt-1) to 0
    for (j=16; j &gt;= 1; j=j-1)
      m[gpPlt+j] = 8'h00;
    // put plt in (gpPlt..gpPlt+numDynEntry*8'h10+1)
    for (i=1; i &lt; numDynEntry; i=i+1) begin
      // (gp+'8h10..gp+numDynEntry*'8h10+15) set to plt entry
      // addiu	$t9, $zero, dynsym_idx
      m[gpPlt+i*8'h10] = 8'h09;
      m[gpPlt+i*8'h10+1] = 8'h60;
      m[gpPlt+i*8'h10+2] = i[15:8];
      m[gpPlt+i*8'h10+3] = i[7:0];
      // st	$t9, 0($gp)
      m[gpPlt+i*8'h10+4] = 8'h02;
      m[gpPlt+i*8'h10+5] = 8'h6b;
      m[gpPlt+i*8'h10+6] = 0;
      m[gpPlt+i*8'h10+7] = 0;
      // ld	$t9, ('16h0010)($gp)
      m[gpPlt+i*8'h10+8] = 8'h01;
      m[gpPlt+i*8'h10+9] = 8'h6b;
      m[gpPlt+i*8'h10+10] = 0;
      m[gpPlt+i*8'h10+11] = 8'h10;
      // ret	$t9
      m[gpPlt+i*8'h10+12] = 8'h3c;
      m[gpPlt+i*8'h10+13] = 8'h60;
      m[gpPlt+i*8'h10+14] = 0;
      m[gpPlt+i*8'h10+15] = 0;
    end

  // .got.plt offset(0x00.0x03) has been set to 0 in elf already.
  // Set .got.plt offset(8'h10..numDynEntry*'8h10) point to plt entry as above.
  `ifdef DEBUG_DLINKER
         $display("numDynEntry = %8x", numDynEntry);
  `endif
//      j32=32'h1fc0; // m[32'h1fc]="something" will hang. Very tricky
    m[gp+16] = 8'h0;
    m[gp+16+1] = 8'h0;
    i=pltAddr[0]+16;
    m[gp+16+2] = i[15:8];   // .plt section addr + 16
    m[gp+16+3] = i[7:0];

    j32=gpPlt+16;
    for (i=1; i &lt; numDynEntry; i=i+1) begin
      m[gp+16+i*4] = j32[31:24];
      m[gp+16+i*4+1] = j32[23:16];
      m[gp+16+i*4+2] = j32[15:8];
      m[gp+16+i*4+3] = j32[7:0];
      j32=j32+16;
    end
  `ifdef DEBUG_DLINKER
    // show (gp..gp+numDynEntry*4-1)
    for (i=0; i &lt; numDynEntry; i=i+1) begin
      $display("%8x: %8x", gp+16+i*4, {m[gp+16+i*4], m[gp+16+i*4+1], 
               m[gp+16+i*4+2], m[gp+16+i*4+3]});
    end
    // show (gpPlt..gpPlt+(numDynEntry+1)*8'h10-1)
    for (i=0; i &lt; numDynEntry; i=i+1) begin
      for (j=0; j &lt; 16; j=j+4)
        $display("%8x: %8x", gpPlt+i*8'h10+j, 
                 {m[gpPlt+i*8'h10+j], 
                  m[gpPlt+i*8'h10+j+1], 
                  m[gpPlt+i*8'h10+j+2], 
                  m[gpPlt+i*8'h10+j+3]});
    end
  `endif
  end endtask
`endif

`ifdef DLINKER
  task loadToFlash; begin
  // erase memory
    for (i=0; i &lt; `MEMSIZE; i=i+1) begin
       flash[i] = `MEMEMPTY;
    end
    $readmemh("dlconfig/libso.hex", flash);
  `ifdef DEBUG_DLINKER
    for (i=0; i &lt; `MEMSIZE &amp;&amp; (flash[i] != `MEMEMPTY || 
         flash[i+1] != `MEMEMPTY || flash[i+2] != `MEMEMPTY || 
         flash[i+3] != `MEMEMPTY); i=i+4) begin
       $display("%8x: %8x", i, {flash[i], flash[i+1], flash[i+2], flash[i+3]});
    end
  `endif
  end endtask
`endif

`ifdef DLINKER
  task createDynInfo; begin
    $readmemh("dlconfig/global_offset", globalAddr);
    m[`GPADDR]   = globalAddr[0];
    m[`GPADDR+1] = globalAddr[1];
    m[`GPADDR+2] = globalAddr[2];
    m[`GPADDR+3] = globalAddr[3];
    gp[31:24] = globalAddr[0];
    gp[23:16] = globalAddr[1];
    gp[15:8] = globalAddr[2];
    gp[7:0] = globalAddr[3];
    $readmemh("dlconfig/plt_offset", pltAddr);
  `ifdef DEBUG_DLINKER
    $display("global address %8x", {m[`GPADDR], m[`GPADDR+1], 
             m[`GPADDR+2], m[`GPADDR+3]});
    $display("gp = %8x", gp);
    $display("pltAddr = %8x", pltAddr[0]);
  `endif
`endif
`ifdef DLINKER
    for (i=0; i &lt; 192; i=i+1) begin
       dsym[i] = `MEMEMPTY;
    end
    for (i=0; i &lt; 96; i=i+1) begin
       dstr[i] = `MEMEMPTY;
    end
    for (i=0; i &lt;384; i=i+1) begin
       so_func_offset[i] = `MEMEMPTY;
    end
    $readmemh("dlconfig/dynsym", dsym);
    $readmemh("dlconfig/dynstr", dstr);
    $readmemh("dlconfig/so_func_offset", so_func_offset);
    setDynLinkerInfo();
  end endtask
`endif

</pre>
</div>
<p class="rubric">lbdex/verilog/flashio.v</p>
<div class="highlight-c++"><pre>`define FLASHADDR 'hA0000

`ifdef DLINKER
    end else if (abus &gt;= `FLASHADDR &amp;&amp; abus &lt;= `FLASHADDR+`MEMSIZE-4) begin
      fabus = abus-`FLASHADDR;
      if (en == 1 &amp;&amp; rw == 0) begin // r_w==0:write
        data = dbus_in;
        case (m_size)
        `BYTE:  {flash[fabus]} = dbus_in[7:0];
        `INT16: {flash[fabus], flash[fabus+1] } = dbus_in[15:0];
        `INT24: {flash[fabus], flash[fabus+1], flash[fabus+2]} = dbus_in[24:0];
        `INT32: {flash[fabus], flash[fabus+1], flash[fabus+2], flash[fabus+3]} 
                = dbus_in;
        endcase
      end else if (en == 1 &amp;&amp; rw == 1) begin// r_w==1:read
        case (m_size)
        `BYTE:  data = {8'h00  , 8'h00,   8'h00,   flash[fabus]};
        `INT16: data = {8'h00  , 8'h00,   flash[fabus], flash[fabus+1]};
        `INT24: data = {8'h00  , flash[fabus], flash[fabus+1], flash[fabus+2]};
        `INT32: data = {flash[fabus], flash[fabus+1], flash[fabus+2], 
                       flash[fabus+3]};
        endcase
      end else
        data = 32'hZZZZZZZZ;
`endif

</pre>
</div>
<p class="rubric">lbdex/verilog/cpu0Id.v</p>
<div class="highlight-c++"><pre>`define DLINKER  // Dynamic Linker Support
//`define DEBUG_DLINKER   // Dynamic Linker Debug
// TRACE: Display the memory contents of the loaded program and data
//`define TRACE 

`include "cpu0.v"

</pre>
</div>
<p class="rubric">lbdex/verilog/cpu0IId.v</p>
<div class="highlight-c++"><pre>`define CPU0II
`define DLINKER  // Dynamic Linker Support
//`define DEBUG_DLINKER   // Dynamic Linker Debug
// TRACE: Display the memory contents of the loaded program and data
//`define TRACE 

`include "cpu0.v"

</pre>
</div>
<p>The following code ch_dynamiclinker.cpp and foobar.cpp is the example for
dynamic linker demostration. File dynamic_linker.cpp is what our implementaion
to execute the dynamic linker function on Cpu0 Verilog machine.</p>
<p class="rubric">exlbt/input/debug.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#ifndef _DEBUG_H_</span>
<span class="cp">#define _DEBUG_H_</span>

<span class="cp">#define STOP \</span>
<span class="cp">  asm(&quot;lui $t9, 0xffff&quot;); \</span>
<span class="cp">  asm(&quot;addiu $t9, $zero, 0xffff&quot;); \</span>
<span class="cp">  asm(&quot;ret $t9&quot;);</span>

<span class="cp">#define ENABLE_TRACE \</span>
<span class="cp">  asm(&quot;ori $sw, $sw, 0x0020&quot;);</span>

<span class="cp">#define DISABLE_TRACE \</span>
<span class="cp">  asm(&quot;lui $at, 0xffff&quot;);       \</span>
<span class="cp">  asm(&quot;ori $at, $at, 0xffdf&quot;);  \</span>
<span class="cp">  asm(&quot;and $sw, $sw, $at&quot;); </span><span class="c1">// clear `D</span>

<span class="cp">#define SET_OVERFLOW \</span>
<span class="cp">  asm(&quot;ori $sw, $sw, 0x008&quot;);</span>

<span class="cp">#define CLEAR_OVERFLOW \</span>
<span class="cp">  asm(&quot;lui $7, 0xffff&quot;);        \</span>
<span class="cp">  asm(&quot;ori $7, $7, 0xfff7&quot;);    \</span>
<span class="cp">  asm(&quot;and $sw, $sw, $7&quot;); </span><span class="c1">// clear `V</span>

<span class="cp">#define SET_SOFTWARE_INT \</span>
<span class="cp">  asm(&quot;ori $sw, $sw, 0x4000&quot;);</span>

<span class="cp">#define CLEAR_SOFTWARE_INT \</span>
<span class="cp">  asm(&quot;lui $7, 0xffff&quot;);        \</span>
<span class="cp">  asm(&quot;ori $7, $7, 0xbfff&quot;);    \</span>
<span class="cp">  asm(&quot;and $sw, $sw, $7&quot;);</span>

<span class="cp">#define SAVE_REGISTERS          \</span>
<span class="cp">  asm(&quot;lui $at, 7&quot;);            \</span>
<span class="cp">  asm(&quot;ori $at, $at, 0xff00&quot;);  \</span>
<span class="cp">  asm(&quot;st $2,   0($at)&quot;);       \</span>
<span class="cp">  asm(&quot;st $3,   4($at)&quot;);       \</span>
<span class="cp">  asm(&quot;st $4,   8($at)&quot;);       \</span>
<span class="cp">  asm(&quot;st $5,  12($at)&quot;);       \</span>
<span class="cp">  asm(&quot;st $t9, 16($at)&quot;);       \</span>
<span class="cp">  asm(&quot;st $7,  20($at)&quot;);       \</span>
<span class="cp">  asm(&quot;st $8,  24($at)&quot;);       \</span>
<span class="cp">  asm(&quot;st $9,  28($at)&quot;);       \</span>
<span class="cp">  asm(&quot;st $10, 32($at)&quot;);       \</span>
<span class="cp">  asm(&quot;st $gp, 36($at)&quot;);       \</span>
<span class="cp">  asm(&quot;st $12, 40($at)&quot;);       \</span>
<span class="cp">  asm(&quot;st $13, 44($at)&quot;);</span>

<span class="cp">#define RESTORE_REGISTERS       \</span>
<span class="cp">  asm(&quot;lui $at,  7&quot;);           \</span>
<span class="cp">  asm(&quot;ori $at,  $at, 0xff00&quot;); \</span>
<span class="cp">  asm(&quot;ld  $2,   0($at)&quot;);      \</span>
<span class="cp">  asm(&quot;ld  $3,   4($at)&quot;);      \</span>
<span class="cp">  asm(&quot;ld  $4,   8($at)&quot;);      \</span>
<span class="cp">  asm(&quot;ld  $5,  12($at)&quot;);      \</span>
<span class="cp">  asm(&quot;ld  $t9, 16($at)&quot;);      \</span>
<span class="cp">  asm(&quot;ld  $7,  20($at)&quot;);      \</span>
<span class="cp">  asm(&quot;ld  $8,  24($at)&quot;);      \</span>
<span class="cp">  asm(&quot;ld  $9,  28($at)&quot;);      \</span>
<span class="cp">  asm(&quot;ld  $10, 32($at)&quot;);      \</span>
<span class="cp">  asm(&quot;ld  $gp, 36($at)&quot;);      \</span>
<span class="cp">  asm(&quot;ld  $12, 40($at)&quot;);      \</span>
<span class="cp">  asm(&quot;ld  $13, 44($at)&quot;);</span>

<span class="cp">#define OVERFLOW     0x8</span>
<span class="cp">#define INT          0x2000</span>
<span class="cp">#define SOFTWARE_INT 0x4000</span>
<span class="cp">#define INT1         0x8000</span>
<span class="cp">#define INT2         0x10000</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="nf">int_sim</span><span class="p">();</span>

<span class="cp">#endif</span>
</pre></div>
</div>
<p class="rubric">exlbt/input/dynamic_linker.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#ifndef _DYNAMIC_LINKER_H_</span>
<span class="cp">#define _DYNAMIC_LINKER_H_</span>

<span class="cp">#define DYNLINKER_INFO_ADDR  0x70000</span>
<span class="cp">#define DYNENT_SIZE          4</span>
<span class="cp">#define DYNPROGSTART         0x40000</span>
<span class="cp">#define FLASHADDR            0xA0000</span>
<span class="cp">#define GPADDR               0x7FFF0</span>

<span class="cp">#include &quot;debug.h&quot;</span>

<span class="k">struct</span> <span class="n">ProgAddr</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">memAddr</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="nf">dynamic_linker_init</span><span class="p">();</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="nf">dynamic_linker</span><span class="p">();</span>

<span class="cp">#endif</span>
</pre></div>
</div>
<p class="rubric">exlbt/input/dynamic_linker.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &quot;dynamic_linker.h&quot;</span>

<span class="c1">//#define DEBUG_DLINKER</span>
<span class="cp">#define PLT0ADDR 0x10</span>
<span class="cp">#define REGADDR  0x7ff00</span>

<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kt">int</span> <span class="n">printf</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">format</span><span class="p">,</span> <span class="p">...);</span>

<span class="kt">int</span> <span class="n">got_plt_fill</span><span class="p">[</span><span class="mh">0x80</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
<span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
<span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
<span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
<span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
<span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
<span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
<span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
<span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">progCounter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// program counter, init to 0 in main()</span>

<span class="n">ProgAddr</span> <span class="n">prog</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>

<span class="kt">void</span> <span class="nf">dynamic_linker</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">SAVE_REGISTERS</span><span class="p">;</span>
<span class="c1">//  static ProgAddr prog[10]; // has side effect (ProgAddr cannot be written in </span>
<span class="c1">// Virtual Box on iMac).</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">nextFreeAddr</span><span class="p">;</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="o">*</span><span class="n">dest</span><span class="p">,</span> <span class="o">*</span><span class="n">end</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">numDynEntry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">dynsym_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">dynsym</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">dynstr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">libOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">nextFunLibOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">volatile</span> <span class="kt">int</span> <span class="n">memAddr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">numDynEntry</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="kt">int</span><span class="o">*</span><span class="p">)(</span><span class="n">DYNLINKER_INFO_ADDR</span><span class="p">));</span>
  <span class="kt">int</span> <span class="n">gp</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">GPADDR</span><span class="p">;</span>
<span class="cp">#ifdef DEBUG_DLINKER</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;gp = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">gp</span><span class="p">);</span>
<span class="cp">#endif</span>
  <span class="n">dynsym_idx</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">gp</span><span class="p">;</span>
<span class="cp">#ifdef DEBUG_DLINKER</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;numDynEntry = %d, dynsym_idx = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">numDynEntry</span><span class="p">,</span> <span class="n">dynsym_idx</span><span class="p">);</span>
<span class="cp">#endif</span>
  <span class="n">dynsym</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)((</span><span class="n">DYNLINKER_INFO_ADDR</span><span class="o">+</span><span class="mi">4</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">dynsym_idx</span><span class="o">*</span><span class="n">DYNENT_SIZE</span><span class="p">));</span>
  <span class="n">dynstr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)(</span><span class="n">DYNLINKER_INFO_ADDR</span><span class="o">+</span><span class="mi">4</span><span class="o">+</span><span class="n">numDynEntry</span><span class="o">*</span><span class="mi">4</span><span class="o">+</span><span class="n">numDynEntry</span><span class="o">*</span><span class="mi">52</span><span class="o">+</span><span class="n">dynsym</span><span class="p">);</span>
  <span class="n">libOffset</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="kt">int</span><span class="o">*</span><span class="p">)(</span><span class="n">DYNLINKER_INFO_ADDR</span><span class="o">+</span><span class="mi">4</span><span class="o">+</span><span class="n">numDynEntry</span><span class="o">*</span><span class="mi">4</span><span class="o">+</span><span class="p">(</span><span class="n">dynsym_idx</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">52</span><span class="p">));</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">dynsym_idx</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numDynEntry</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">nextFunLibOffset</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="kt">int</span><span class="o">*</span><span class="p">)(</span><span class="n">DYNLINKER_INFO_ADDR</span><span class="o">+</span><span class="mi">4</span><span class="o">+</span><span class="n">numDynEntry</span><span class="o">*</span><span class="mi">4</span><span class="o">+</span><span class="n">i</span><span class="o">*</span><span class="mi">52</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">libOffset</span> <span class="o">!=</span> <span class="n">nextFunLibOffset</span><span class="p">)</span>
      <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
<span class="cp">#ifdef DEBUG_DLINKER</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;address of dstr = %x, dynsym = %d, dstr = %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> 
         <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">dynstr</span><span class="p">,</span> <span class="n">dynsym</span><span class="p">,</span> <span class="n">dynstr</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;libOffset = %d, nextFunLibOffset = %d, progCounter = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> 
         <span class="n">libOffset</span><span class="p">,</span> <span class="n">nextFunLibOffset</span><span class="p">,</span> <span class="n">progCounter</span><span class="p">);</span>
<span class="cp">#endif</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">progCounter</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
     <span class="n">nextFreeAddr</span> <span class="o">=</span> <span class="n">DYNPROGSTART</span><span class="p">;</span>
  <span class="k">else</span>
     <span class="n">nextFreeAddr</span> <span class="o">=</span> <span class="n">prog</span><span class="p">[</span><span class="n">progCounter</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">memAddr</span><span class="o">+</span><span class="n">prog</span><span class="p">[</span><span class="n">progCounter</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">size</span><span class="p">;</span>
  <span class="n">prog</span><span class="p">[</span><span class="n">progCounter</span><span class="p">].</span><span class="n">memAddr</span> <span class="o">=</span> <span class="n">nextFreeAddr</span><span class="p">;</span>
  <span class="n">prog</span><span class="p">[</span><span class="n">progCounter</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">nextFunLibOffset</span> <span class="o">-</span> <span class="n">libOffset</span><span class="p">);</span>

<span class="cp">#ifdef DEBUG_DLINKER</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;prog[progCounter].memAddr = %d, prog[progCounter].size = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> 
         <span class="n">prog</span><span class="p">[</span><span class="n">progCounter</span><span class="p">].</span><span class="n">memAddr</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="n">prog</span><span class="p">[</span><span class="n">progCounter</span><span class="p">].</span><span class="n">size</span><span class="p">));</span>
<span class="cp">#endif</span>
  <span class="c1">// Load program from (FLASHADDR+libOffset..FLASHADDR+nextFunLibOffset-1) to</span>
  <span class="c1">// (nextFreeAddr..nextFreeAddr+prog[progCounter].size-1)</span>
  <span class="n">src</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)(</span><span class="n">FLASHADDR</span><span class="o">+</span><span class="n">libOffset</span><span class="p">);</span>
  <span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)(</span><span class="n">src</span><span class="o">+</span><span class="n">prog</span><span class="p">[</span><span class="n">progCounter</span><span class="p">].</span><span class="n">size</span><span class="o">/</span><span class="mi">4</span><span class="p">);</span>
<span class="cp">#ifdef DEBUG_DLINKER</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;end = %x, src = %x, nextFreeAddr = %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> 
         <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">end</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">src</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">nextFreeAddr</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;*src = %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="o">*</span><span class="n">src</span><span class="p">));</span>
<span class="cp">#endif</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;loading %s...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dynstr</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">dest</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)(</span><span class="n">prog</span><span class="p">[</span><span class="n">progCounter</span><span class="p">].</span><span class="n">memAddr</span><span class="p">);</span> <span class="n">src</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">src</span><span class="o">++</span><span class="p">,</span> <span class="n">dest</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="o">*</span><span class="n">src</span><span class="p">;</span>
<span class="cp">#ifdef DEBUG_DLINKER</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;*dest = %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="o">*</span><span class="n">dest</span><span class="p">));</span>
<span class="cp">#endif</span>
  <span class="p">}</span>
  <span class="n">progCounter</span><span class="o">++</span><span class="p">;</span>

<span class="cp">#ifdef DEBUG_DLINKER</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;progCounter-1 = %x, prog[progCounter-1].memAddr = %x, \</span>
<span class="s">         *prog[progCounter-1].memAddr = %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> 
         <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="n">progCounter</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="n">prog</span><span class="p">[</span><span class="n">progCounter</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">memAddr</span><span class="p">),</span> 
         <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">*</span><span class="p">)(</span><span class="n">prog</span><span class="p">[</span><span class="n">progCounter</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">memAddr</span><span class="p">));</span>
<span class="cp">#endif</span>
  <span class="c1">// Change .got.plt for &quot;ld	$t9, idx($gp)&quot;</span>
  <span class="o">*</span><span class="p">((</span><span class="kt">int</span><span class="o">*</span><span class="p">)(</span><span class="n">gp</span><span class="o">+</span><span class="mh">0x10</span><span class="o">+</span><span class="n">dynsym_idx</span><span class="o">*</span><span class="mh">0x04</span><span class="p">))</span> <span class="o">=</span> <span class="n">prog</span><span class="p">[</span><span class="n">progCounter</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">memAddr</span><span class="p">;</span>
  <span class="o">*</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)(</span><span class="mh">0x7FFE0</span><span class="p">)</span> <span class="o">=</span> <span class="n">prog</span><span class="p">[</span><span class="n">progCounter</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">memAddr</span><span class="p">;</span>
<span class="cp">#ifdef DEBUG_DLINKER</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;*((int*)(gp+0x10+dynsym_idx*0x10)) = %x, *(int*)(0x7FFE0) = %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> 
         <span class="o">*</span><span class="p">((</span><span class="kt">int</span><span class="o">*</span><span class="p">)(</span><span class="n">gp</span><span class="o">+</span><span class="mh">0x10</span><span class="o">+</span><span class="n">dynsym_idx</span><span class="o">*</span><span class="mh">0x10</span><span class="p">)),</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="o">*</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)(</span><span class="mh">0x7FFE0</span><span class="p">)));</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;*((int*)(gp+0x04)) = %x, *((int*)(gp+0x08)) = %x, *((int*)(gp+0x0c)) = %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> 
         <span class="o">*</span><span class="p">((</span><span class="kt">int</span><span class="o">*</span><span class="p">)(</span><span class="n">gp</span><span class="o">+</span><span class="mh">0x04</span><span class="p">)),</span> <span class="o">*</span><span class="p">((</span><span class="kt">int</span><span class="o">*</span><span class="p">)(</span><span class="n">gp</span><span class="o">+</span><span class="mh">0x08</span><span class="p">)),</span> <span class="o">*</span><span class="p">((</span><span class="kt">int</span><span class="o">*</span><span class="p">)(</span><span class="n">gp</span><span class="o">+</span><span class="mh">0x0c</span><span class="p">)));</span>
<span class="cp">#endif</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;run %s...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dynstr</span><span class="p">);</span>
  <span class="n">RESTORE_REGISTERS</span><span class="p">;</span>

  <span class="c1">// restore $lr. The next instruction of foo() of main.cpp for the main.cpp</span>
  <span class="c1">// call foo() first time example.</span>
  <span class="c1">// The $lr, $fp and $sp saved in cpu0Plt0AtomContent of Cpu0LinkingContext.cpp.</span>
  <span class="k">asm</span><span class="p">(</span><span class="s">&quot;ld $lr, 4($gp)&quot;</span><span class="p">);</span> <span class="c1">// restore $lr</span>
<span class="cp">#ifdef DEBUG_DLINKER</span>
  <span class="n">ENABLE_TRACE</span><span class="p">;</span>
<span class="cp">#endif</span>
  <span class="k">asm</span><span class="p">(</span><span class="s">&quot;ld $fp, 8($gp)&quot;</span><span class="p">);</span> <span class="c1">// restore $fp</span>
  <span class="k">asm</span><span class="p">(</span><span class="s">&quot;ld $sp, 12($gp)&quot;</span><span class="p">);</span> <span class="c1">// restore $sp</span>
<span class="cp">#ifdef DEBUG_DLINKER</span>
  <span class="n">DISABLE_TRACE</span><span class="p">;</span>
<span class="cp">#endif</span>
  <span class="c1">// jmp to the dynamic linked function. It&#39;s foo() for the </span>
  <span class="c1">// caller, ch_dynamic_linker.cpp, call foo() </span>
  <span class="c1">// first time example.</span>
  <span class="k">asm</span><span class="p">(</span><span class="s">&quot;lui $t9, 0x7&quot;</span><span class="p">);</span>
  <span class="k">asm</span><span class="p">(</span><span class="s">&quot;ori $t9, $t9, 0xFFE0&quot;</span><span class="p">);</span>
  <span class="k">asm</span><span class="p">(</span><span class="s">&quot;ld $t9, 0($t9)&quot;</span><span class="p">);</span>
  <span class="k">asm</span><span class="p">(</span><span class="s">&quot;ret $t9&quot;</span><span class="p">);</span>

  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">exlbt/input/ch_dynamiclinker.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &quot;dynamic_linker.h&quot;</span>
<span class="cp">#include &quot;print.h&quot;</span>

<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kt">int</span> <span class="n">printf</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">format</span><span class="p">,</span> <span class="p">...);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="nf">la</span><span class="p">(</span><span class="kt">int</span> <span class="n">x1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x2</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">x1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x2</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="nf">bar</span><span class="p">();</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="c1">//  ENABLE_TRACE;</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#if 1</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;foo(1, 2) = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#if 1</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">bar</span><span class="p">();</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;bar() = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">  a = foo(1, 2);</span>
<span class="c">  printf(&quot;foo(1, 2) = %d\n&quot;, a);</span>
<span class="cp">#endif</span>
  
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">exlbt/input/foobar.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &quot;dynamic_linker.h&quot;</span>

<span class="kt">int</span> <span class="nf">la</span><span class="p">(</span><span class="kt">int</span> <span class="n">x1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x2</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">x2</span><span class="p">;</span>
  
  <span class="k">return</span> <span class="n">sum</span><span class="p">;</span> 
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">x1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x2</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">x2</span><span class="p">;</span>
  
  <span class="k">return</span> <span class="n">sum</span><span class="p">;</span> 
<span class="p">}</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">int factorial(int x)</span>
<span class="c">{</span>
<span class="c">  if (x &gt; 0)</span>
<span class="c">    return x*factorial(x-1);</span>
<span class="c">  else</span>
<span class="c">    return 1;</span>
<span class="c">}</span>
<span class="cp">#endif</span>

<span class="kt">int</span> <span class="nf">bar</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
<span class="c1">//  ENABLE_TRACE;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">foo</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
  <span class="n">a</span> <span class="o">+=</span> <span class="n">la</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="c1">// 4+7=11</span>
<span class="c1">//  a += factorial(4); // 11+24=35</span>

  <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">exlbt/input/build-dlinker.sh</p>
<div class="highlight-c++"><pre>#!/usr/bin/env bash

source functions.sh

sh_name=build-dlinker.sh
argNum=$#
arg1=$1
arg2=

prologue;

rm -rf dlconfig
mkdir dlconfig

clang -target mips-unknown-linux-gnu -c start.cpp -emit-llvm -o start.bc
clang -target mips-unknown-linux-gnu -c debug.cpp -emit-llvm -o debug.bc
clang -target mips-unknown-linux-gnu -c dynamic_linker.cpp -emit-llvm \
-o dynamic_linker.cpu0.bc
clang -target mips-unknown-linux-gnu -c printf-stdarg-def.c -emit-llvm \
-o printf-stdarg-def.bc
clang -target mips-unknown-linux-gnu -c printf-stdarg.c -emit-llvm \
-o printf-stdarg.bc
clang -target mips-unknown-linux-gnu -c foobar.cpp -emit-llvm -o foobar.cpu0.bc
${TOOLDIR}/llc -march=cpu0 -mcpu=${CPU} -relocation-model=static -filetype=obj \
-cpu0-reserve-gp=true dynamic_linker.cpu0.bc -o dynamic_linker.cpu0.o
${TOOLDIR}/llc -march=cpu0 -mcpu=${CPU} -relocation-model=static -filetype=obj \
printf-stdarg-def.bc -o printf-stdarg-def.cpu0.o
${TOOLDIR}/llc -march=cpu0 -mcpu=${CPU} -relocation-model=static -filetype=obj \
-cpu0-reserve-gp=true printf-stdarg.bc -o printf-stdarg.cpu0.o
${TOOLDIR}/llc -march=cpu0 -mcpu=${CPU} -relocation-model=pic -filetype=obj \
-cpu0-reserve-gp=true -cpu0-no-cpload=true foobar.cpu0.bc -o foobar.cpu0.o
${TOOLDIR}/llc -march=cpu0 -mcpu=${CPU} -relocation-model=static -filetype=obj \
lib_cpu0.ll -o lib_cpu0.o
${TOOLDIR}/lld -flavor gnu -target cpu0-unknown-linux-gnu -shared -o \
libfoobar.cpu0.so foobar.cpu0.o
${TOOLDIR}/llc -march=cpu0 -mcpu=${CPU} -relocation-model=static -filetype=obj \
-cpu0-reserve-gp=true start.bc -o start.cpu0.o
${TOOLDIR}/llc -march=cpu0 -mcpu=${CPU} -relocation-model=static \
-filetype=obj debug.bc -o debug.cpu0.o
clang -target mips-unknown-linux-gnu -c ch_dynamiclinker.cpp -emit-llvm \
-o ch_dynamiclinker.cpu0.bc
${TOOLDIR}/llc -march=cpu0 -mcpu=${CPU} -relocation-model=static -filetype=obj \
-cpu0-reserve-gp=true ch_dynamiclinker.cpu0.bc -o ch_dynamiclinker.cpu0.o
${TOOLDIR}/lld -flavor gnu -target cpu0-unknown-linux-gnu start.cpu0.o \
printf-stdarg-def.cpu0.o printf-stdarg.cpu0.o dynamic_linker.cpu0.o \
ch_dynamiclinker.cpu0.o libfoobar.cpu0.so lib_cpu0.o debug.cpu0.o
${TOOLDIR}/llvm-objdump -elf2hex -le=false -cpu0dumpso libfoobar.cpu0.so \
&gt; dlconfig/libso.hex
${TOOLDIR}/llvm-objdump -elf2hex -le=false -cpu0linkso a.out &gt; cpu0.hex
cp -rf dlconfig cpu0.hex ../../lbdex/verilog/.
echo "0   /* 0: big endian, 1: little endian */" &gt; ../../lbdex/verilog/cpu0.config
cat ../../lbdex/verilog/cpu0.config

</pre>
</div>
<div class="section" id="id7">
<h4><a class="toc-backref" href="#id52">Run</a><a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h4>
<div class="highlight-bash"><div class="highlight"><pre>1-160-136-173 input Jonathan<span class="nv">$ </span><span class="nb">pwd</span>
/Users/Jonathan/test/lbt/exlbt/input
1-160-136-173:input Jonathan<span class="nv">$ </span>bash build-dlinker.sh cpu032II
1-160-136-173:input Jonathan<span class="nv">$ </span><span class="nb">cd</span> ../../lbdex/verilog/
1-160-136-173:verilog Jonathan<span class="nv">$ </span><span class="nb">pwd</span>
/Users/Jonathan/test/lbt/lbdex/verilog
1-160-136-173:verilog Jonathan<span class="nv">$ </span>iverilog -o cpu0IId cpu0IId.v
1-160-136-173:verilog Jonathan<span class="nv">$ </span>ls
clean.sh  cpu0IId  cpu0Id.v  cpu0IId.v  cpu0IIs.v  cpu0Is.v  cpu0.v  dynlinker.v
flashio.v
1-160-136-173:verilog Jonathan<span class="nv">$ </span>./cpu0IId
WARNING: ./cpu0.v:371: <span class="nv">$readmemh</span><span class="o">(</span>cpu0.hex<span class="o">)</span>: Not enough words in the file <span class="k">for</span>
the requested range <span class="o">[</span>0:524287<span class="o">]</span>.
WARNING: ./dynlinker.v:185: <span class="nv">$readmemh</span><span class="o">(</span>libso.hex<span class="o">)</span>: Not enough words in the
file <span class="k">for </span>the requested range <span class="o">[</span>0:524287<span class="o">]</span>.
WARNING: ./dynlinker.v:223: <span class="nv">$readmemh</span><span class="o">(</span>dynsym<span class="o">)</span>: Not enough words in the file
<span class="k">for </span>the requested range <span class="o">[</span>0:191<span class="o">]</span>.
WARNING: ./dynlinker.v:224: <span class="nv">$readmemh</span><span class="o">(</span>dynstr<span class="o">)</span>: Not enough words in the file
<span class="k">for </span>the requested range <span class="o">[</span>0:95<span class="o">]</span>.
WARNING: ./dynlinker.v:225: <span class="nv">$readmemh</span><span class="o">(</span>so_func_offset<span class="o">)</span>: Not enough words in
the file <span class="k">for </span>the requested range <span class="o">[</span>0:383<span class="o">]</span>.
<span class="nv">numDynEntry</span> <span class="o">=</span> 00000005
taskInterrupt<span class="o">(</span>001<span class="o">)</span>
loading _Z3fooii...
run _Z3fooii...
foo<span class="o">(</span>1, 2<span class="o">)</span> <span class="o">=</span> 3
loading _Z3barv...
run _Z3barv...
loading _Z2laii...
run _Z2laii...
bar<span class="o">()</span> <span class="o">=</span> 11
total cpu <span class="nv">cycles</span> <span class="o">=</span> 50530
RET to PC &lt; 0, finished!
</pre></div>
</div>
<p>The &#8220;#ifdef DEBUG_DLINKER&#8221; part of code in dynamic_linker.cpp is for debugging
purpose (since we coding it and take time to debug). After skip these debug
code, the dynamic_linker.cpp is short and not difficult to read.</p>
<p>The run result is under expectation. The main() call foo() function first.
Function foo() is loaded by dynamic linker (dynamic_linker.cpp) from flash
address FLASHADDR (defined in dynamic_linker.h) to memory.
The flashio.v implement the simulation read from flash address.
After loaded foo() body from flash, dynamic_linker.cpp jump to this loaded
address by &#8220;ret $t9&#8221; instruction.</p>
<p>Same as static linker, you can generate slt instruction instead of cmp by
change from cpu=cpu0I to cpu0=cpu0II in build-dlinker.sh and run it again to
get the same result.
Finally, since the dynamic linker is a demo implemenation, it supports big
endian only.</p>
</div>
<div class="section" id="how-to-work">
<h4><a class="toc-backref" href="#id53">How to work</a><a class="headerlink" href="#how-to-work" title="Permalink to this headline">¶</a></h4>
<p>After run build-dlinker.sh, the following files are created.</p>
<p class="rubric">lbdex/verilog/cpu0.hex</p>
<div class="highlight-bash"><div class="highlight"><pre>/*Disassembly of section .plt:*/
/*.PLT0:*/
/*       0:*/ 36 00 00 3c                                  /* jmp     60*/
/*       4:*/ 36 00 00 04                                  /* jmp     4*/
/*       8:*/ 36 00 00 04                                  /* jmp     4*/
/*       c:*/ 36 ff ff <span class="nb">fc</span>                                  /* jmp     -4*/

/*.PLT0:*/
/*      10:*/ 02 eb 00 04                                  /* st      <span class="nv">$lr</span>, 4<span class="o">(</span><span class="nv">$gp</span><span class="o">)</span>*/
/*      14:*/ 02 cb 00 08                                  /* st      <span class="nv">$fp</span>, 8<span class="o">(</span><span class="nv">$gp</span><span class="o">)</span>*/
/*      18:*/ 02 db 00 0c                                  /* st      <span class="nv">$sp</span>, 12<span class="o">(</span><span class="nv">$gp</span><span class="o">)</span>*/
/*      1c:*/ 36 00 09 b8                                  /* jmp     2488*/

/*__plt__Z3barv:*/
/*      20:*/ 01 6b 00 24                                  /* ld      <span class="nv">$t9</span>, 36<span class="o">(</span><span class="nv">$gp</span><span class="o">)</span>
/*      24:*/ 3c 60 00 00                                  /* ret     <span class="nv">$t9</span>*/
/*      28:*/ 00 00 00 00                                  /* nop*/
/*      2c:*/ 00 00 00 00                                  /* nop*/

/*__plt__Z3fooii:*/
/*      30:*/ 01 6b 00 1c                                  /* ld      <span class="nv">$t9</span>, 28<span class="o">(</span><span class="nv">$gp</span><span class="o">)</span>
/*      34:*/ 3c 60 00 00                                  /* ret     <span class="nv">$t9</span>*/
/*      38:*/ 00 00 00 00                                  /* nop*/
/*      3c:*/ 00 00 00 00                                  /* nop*/
...

/*main:*/
...
/*     d68:*/ 3b ff f2 b4                                  /* jsub    16773812*/ // call foo<span class="o">()</span>
...
/*     d80:*/ 3b ff f3 28                                  /* jsub    16773928*/ // call <span class="nb">printf</span><span class="o">()</span>
/*     d84:*/ 3b ff f2 a8                                  /* jsub    16773800*/ // call bar<span class="o">()</span>
...
/*     d9c:*/ 3b ff f3 0c                                  /* jsub    16773900*/ // call <span class="nb">printf</span><span class="o">()</span>
...
/*     db8:*/ 3c e0 00 00                                  /* ret     <span class="nv">$lr</span>*/
...
/*Contents of section .data:*/
/*20a8 */00 00 00 01  00 00 00 01  00 00 00 01  00 00 00 01 /*  ................*/
...
</pre></div>
</div>
<p class="rubric">lbdex/verilog/dynstr</p>
<div class="highlight-bash"><div class="highlight"><pre>00 5f 5f 74 6c 73 5f 67 65 74 5f 61 64 64 72 00 5f 5a 32 6c 61 69 69 00 5f 5a
35 70 6f 77 65 72 69 00 5f 5a 33 66 6f 6f 69 69 00 5f 5a 33 62 61 72 76 00 5f
47 4c 4f 42 41 4c 5f 4f 46 46 53 45 54 5f 54 41 42 4c 45 5f 00 5f 44 59 4e 41
4d 49 43 00
</pre></div>
</div>
<p class="rubric">exlbt/verilog/dynsym</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="mo">00</span> <span class="mo">00</span> <span class="mo">00</span> <span class="mo">00</span> <span class="mo">00</span> <span class="mo">00</span> <span class="mo">00</span> <span class="mo">01</span> <span class="mo">00</span> <span class="mo">00</span> <span class="mo">00</span> <span class="mi">10</span> <span class="mo">00</span> <span class="mo">00</span> <span class="mo">00</span> <span class="mi">18</span> <span class="mo">00</span> <span class="mo">00</span> <span class="mo">00</span> <span class="mi">22</span> <span class="mo">00</span> <span class="mo">00</span> <span class="mo">00</span> <span class="mi">2</span><span class="n">b</span> <span class="mo">00</span> <span class="mo">00</span>
<span class="mo">00</span> <span class="mi">33</span> <span class="mo">00</span> <span class="mo">00</span> <span class="mo">00</span> <span class="mi">49</span>
</pre></div>
</div>
<p class="rubric">lbdex/verilog/global_offset</p>
<div class="highlight-bash"><div class="highlight"><pre>00 00 20 68
</pre></div>
</div>
<p class="rubric">exlbt/input/num_dyn_entry</p>
<div class="highlight-bash"><div class="highlight"><pre>6
</pre></div>
</div>
<p class="rubric">exlbt/input/libfoobar.cpu0.so</p>
<div class="highlight-bash"><div class="highlight"><pre>1-160-136-173:input Jonathan<span class="nv">$ </span>~/llvm/test/cmake_debug_build/Debug/bin/
llvm-objdump -s libfoobar.cpu0.so

libfoobar.cpu0.so:    file format ELF32-CPU0

Contents of section :
...
Contents of section .dynsym:
 00e4 00000000 00000000 00000000 00000000  ................
 00f4 00000001 0000019c 00000000 12000004  ................
 0104 00000010 0000019c 0000003c 12000004  ...........&lt;....
 0114 00000018 000001d8 00000038 12000004  ...........8....
 0124 00000021 00000210 00000070 12000004  ...!.......p....
 0134 00000029 00001040 00000000 10000006  ...<span class="o">)</span>...@........
 0144 0000003f 00001040 00000000 11000005  ...?...@........
Contents of section .dynstr:
 0154 005f5f74 6c735f67 65745f61 64647200  .__tls_get_addr.
 0164 5f5a326c 61696900 5f5a3366 6f6f6969  _Z2laii._Z3fooii
 0174 005f5a33 62617276 005f474c 4f42414c  ._Z3barv._GLOBAL
 0184 5f4f4646 5345545f 5441424c 455f005f  _OFFSET_TABLE_._
 0194 44594e41 4d494300                    DYNAMIC.
</pre></div>
</div>
<p class="rubric">exlbt/input/a.out</p>
<div class="highlight-bash"><div class="highlight"><pre>1-160-136-173:input Jonathan<span class="nv">$ </span>~/llvm/test/cmake_debug_build/Debug/bin/
llvm-objdump -s a.out

a.out:        file format ELF32-CPU0

Contents of section :
...
Contents of section .dynsym:
 013c 00000000 00000000 00000000 00000000  ................
 014c 00000001 00000000 00000000 12000000  ................
 015c 0000000a 00000000 00000000 12000000  ................
Contents of section .dynstr:
 016c 005f5a33 666f6f69 69005f5a 33626172  ._Z3fooii._Z3bar
 017c 76006c69 62666f6f 6261722e 63707530  v.libfoobar.cpu0
 018c 2e736f00                             .so.
...
Contents of section .got.plt:
 2068 00000000 00000000 00000000 00000000  ................
 2078 00000000 00000000 00000000 00000000  ................
 2088 000001d0 00000000 00000000 00000000  ................
 2098 000001e0 00000000 00000000 00000000  ................
Contents of section .data:
 20a8 00000001 00000001 00000001 00000001  ................
</pre></div>
</div>
<p>File dynstr is section .dynstr of libfoobar.cpu0.so. File dynsym is the first
4 bytes of every entry of .dynsym. File global_offset contains the start address
of section .got.plt.</p>
<p>The code of dynlinker.v will set the memory as follows after program is loaded.
(gp value below is 2068 came from file global_offset).</p>
<p class="rubric">memory contents</p>
<div class="highlight-bash"><pre>//                                    -----------------------------------
// gp ------------------------------&gt; | all 0                           | (16 bytes)
// gp+16 ---------------------------&gt; | 0                          |
// gp+16+1*4 -----------------------&gt; | 1st plt entry address      | (4 bytes)
//                                    | ...                        |
// gp+16+(numDynEntry-1)*4 ---------&gt; | the last plt entry address |
//                                    -----------------------------------
// gpPlt ---------------------------&gt; | all 0                           | (16 bytes)
// gpPlt+16+0*8'h10 ----------------&gt; | 32'h10: pointer to plt0         |
// gpPlt+16+1*8'h10 ----------------&gt; | 1st plt entry                   |
// gpPlt+16+2*8'h10 ----------------&gt; | 2nd plt entry                   |
//                                    | ...                             |
// gpPlt+16+(numDynEntry-1)*8'h10 --&gt; | the last plt entry              |
//                                    -----------------------------------</pre>
</div>
<p>For example code of ch_dynamiclinker.cpp and foobar.cpp, gp is 2068, numDynEntry is
the contents of file num_dyn_entry which is 6. Every plt entry above (memory
address gp+16+1*8&#8217;h10..gp+16+(numDynEntry-1)*8&#8217;h10) is initialized to &#8220;addiu $t9,
$zero, 4($gp); st $t9, 0($gp); ld $t9, 16($gp); ret $t9&#8221; as follows,</p>
<p class="rubric">memory contents</p>
<div class="highlight-bash"><pre>//                                    -----------------------------------
// gp ------------------------------&gt; | all 0                           | (16 bytes)
// gp+16 ---------------------------&gt; | 0                          |
// gp+16+1*4 -----------------------&gt; | 1st plt entry address      | (4 bytes)
//                                    | ...                        |
// gp+16+(numDynEntry-1)*4 ---------&gt; | the last plt entry address |
//                                    -----------------------------------
// gpPlt ---------------------------&gt; | all 0                           | (16 bytes)
// gpPlt+16+0*8'h10 ----------------&gt; | 32'h10: pointer to plt0         |
// gpPlt+16+1*8'h10 ----------------&gt; | addiu $t9, $zero, 4             |
//                                    | st  $t9, 0($gp)                 |
//                                    | ld  $t9, 16($gp)                |
//                                    | ret $t9                         |
// gpPlt+16+2*8'h10 ----------------&gt; | addiu $t9, $zero, 4             |
//                                    | st  $t9, 0($gp)                 |
//                                    | ld  $t9, 16($gp)                |
//                                    | ret $t9                         |
// ...                                | ...                             |
// gpPlt+16+(6-1)*8'h10 ------------&gt; | addiu $t9, $zero, 4             |
//                                    | st  $t9, 0($gp)                 |
//                                    | ld  $t9, 16($gp)                |
//                                    | ret $t9                         |
//                                    -----------------------------------</pre>
</div>
<p><a class="pageref" href="#lld-f6">Figure  9</a> is the memory contents after the example program is loaded.</p>
<div class="figure align-center" id="lld-f6">
<a class="reference internal image-reference" href="_images/6.png"><img alt="_images/6.png" src="_images/6.png" /></a>
<p class="caption">Figure 9: Memory contents after the program is loaded</p>
</div>
<div class="figure align-center" id="lld-f7">
<a class="reference internal image-reference" href="_images/7.png"><img alt="_images/7.png" src="_images/7.png" /></a>
<p class="caption">Figure 10: Control flow transfer from calling foo() instruction of main() to dynamic linker</p>
</div>
<p><a class="pageref" href="#lld-f7">Figure  10</a> is the Control flow transfer from call foo() of main() to
dynamic linker. After the first time of ch_dynamiclinker.cpp call foo(), it
jump to __plt_Z3fooii plt entry.
In __plt_Z3fooii, &#8220;ld $t9, 1c($gp)&#8221; and &#8220;ret $t9&#8221; will jump to &#8220;Plt foo:&#8221;.
Since foo is the 3rd plt entry in &#8220;Plt foo:&#8221;, it save 3 to 0($gp) memory
address then jump to PLT0.
The purpose of PLT0 is to save $lr, $fp, $sp and jump to dynamic linker.
Now, the control flow transfers to dynamic linker.
Dynamic linker will get the loaded function name and function offset of shared
library by the value of 0($gp) which is 3 now (set in &#8220;Plt foo:&#8221;). The value
3 tells dynamic linker loading foo() (3rd string in .dynstr) from offset of
shared library, 0x3c (3rd value of Function offset area in Figure).
Now, dynamic linker can load foo() function from flash to memory, set the
address gp+3*4 to 0x40000 where the address 0x40000 is the memory address of
foo() function loaded to, and then prepare jump to the foo() memory address.
Remind we say the prepare jump to foo(). Because before jump to foo(), dynamic
linker needs to restore the $lr, $fp, $sp to the
value of just before caller calling foo() (they are saved in 4, 8, 12 of $gp
offset in PLT0, so them can be restored from that address).</p>
<div class="figure align-center" id="lld-f8">
<a class="reference internal image-reference" href="_images/8.png"><img alt="_images/8.png" src="_images/8.png" /></a>
<p class="caption">Figure 11: Transfer from dynamic linker to foo() and back to main()</p>
</div>
<p>As <a class="pageref" href="#lld-f8">Figure  11</a> depicted, control flow from dynamic linker to foo() and
back to caller main() when it meets the instruction &#8220;ret $lr&#8221; in foo().</p>
<div class="figure align-center" id="lld-f9">
<a class="reference internal image-reference" href="_images/9.png"><img alt="_images/9.png" src="_images/9.png" /></a>
<p class="caption">Figure 12: Control flow transfer from calling bar() instruction of main() to dynamic linker</p>
</div>
<div class="figure align-center" id="lld-f10">
<a class="reference internal image-reference" href="_images/10.png"><img alt="_images/10.png" src="_images/10.png" /></a>
<p class="caption">Figure 13: Dynamic linker load bar() from flash to memory</p>
</div>
<p>Now the program run at the next instruction of call foo() in main() as
<a class="pageref" href="#lld-f9">Figure  12</a> depicted. When it runs
to address 0xd8 &#8220;jsub __plt__Z3barv&#8221;, the control flow will transfer from
main through __plt_Z3barv, &#8220;Plt bar:&#8221; and PLT0 to dynamic linker as
<a class="pageref" href="#lld-f9">Figure  12</a> depicted. Then load and run bar() from flash to memory
just like the calling __plt__Z3fooii as <a class="pageref" href="#lld-f10">Figure  13</a> depicted.
The difference is bar() will call foo() first and call la() next.
The call foo() in bar() will jump to foo() directly as <a class="pageref" href="#lld-f9">Figure  12</a>
because the content of gp+28 is the address of 0x40000 which
set in dynamic linker when the first time of foo() function is called.</p>
<p>Finally when bar() call la() function it will jump to &#8220;Plt la:&#8221; since the
content of $gp+24 point to &#8220;Plt la:&#8221;.
The &#8220;Plt la:&#8221; code will call dynamic linker
to load la() function, run la() and back to bar() as <a class="pageref" href="#lld-f11">Figure  14</a>.</p>
<div class="figure align-center" id="lld-f11">
<a class="reference internal image-reference" href="_images/111.png"><img alt="_images/111.png" src="_images/111.png" /></a>
<p class="caption">Figure 14: Call la through &#8220;Plt la:&#8221; in bar()</p>
</div>
<p>The dynamic linker implementation usually is not specified in ABI. It needs the
co-work between linker and dynamic linker/loader. It uses the pointers (the area
from gp+16+1*4 to gp+16+(numDynEntry-1)*4). When the code is loaded, this
corresponding pointer in this area points to the loaded memory. Otherwise, it
points to dynamic linker. The Plt or __plt_Z3fooii, __pltZ3barv are coding in
our cpu0PltAtomContent[] of Cpu0RelocationPass.cpp. It is called linkage editor
implementation.</p>
</div>
</div>
</div>
<div class="section" id="summary">
<h2><a class="toc-backref" href="#id54">Summary</a><a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h2>
<div class="section" id="create-a-new-backend-base-on-llvm">
<h3><a class="toc-backref" href="#id55">Create a new backend base on LLVM</a><a class="headerlink" href="#create-a-new-backend-base-on-llvm" title="Permalink to this headline">¶</a></h3>
<p>Thanks the llvm open source project.
To write a linker and ELF to Hex tools for a new CPU architecture is easy and
reliable.
Combined with the llvm Cpu0 backend code and Verilog language code programmed
in previouse chapters, we design a software
toolchain to compile C/C++ code, link and run it on Verilog Cpu0 simulator
without any real hardware investment.
If you buy the FPGA development hardware, we believe these
code can run on FPGA CPU even though we didn&#8217;t do it.
Extend system program toolchain to support a new CPU instruction set can be
finished just like we have shown you at this point.
School knowledges of system program, compiler, linker, loader, computer
architecture and CPU design has been translated into a real work and see how it
is running. Now, these school books knowledge is not limited on paper.
We design it, program it, and run it on real world.</p>
<p>The total code size of llvm Cpu0 backend compiler, Cpu0 lld linker, llvm-objdump
with elf2hex Cpu0 support and Cpu0 Verilog Language is around 10 thousands lines
of source code include comments.
The total code size of clang, llvm and lld has 1000 thousands lines exclude the
test and documents parts. It is only 1 % of the llvm size.
More over, the llvm Cpu0 backend and lld Cpu0 backend are 70% of same with llvm
Mips and lld X86_64.
Based on this truth, we believe llvm is a well defined structure in compiler
architecture.</p>
</div>
<div class="section" id="contribute-back-to-open-source-through-working-and-learning">
<h3><a class="toc-backref" href="#id56">Contribute back to Open Source through working and learning</a><a class="headerlink" href="#contribute-back-to-open-source-through-working-and-learning" title="Permalink to this headline">¶</a></h3>
<p>Finally, 10 thousands lines of source code in Cpu0 backend is very small in UI
program. But it&#8217;s quite complex in system program which based on llvm.
We spent 600 pages of pdf to explain these code. Open source code give
programmers best opportunity to understand the code and enhance/extend the
code function. But it can be better, we believe the documentation is the next
most important thing to improve the open source code development.
The Open Source Organization recognized this point and set
Open Source Document Project years ago <a class="footnote-reference" href="#id25" id="id8">[7]</a> <a class="footnote-reference" href="#id26" id="id9">[8]</a> <a class="footnote-reference" href="#id27" id="id10">[9]</a> <a class="footnote-reference" href="#id28" id="id11">[10]</a> <a class="footnote-reference" href="#id29" id="id12">[11]</a>.
Open Source grows up and becomes a giant software infrastructure with the forces
of company <a class="footnote-reference" href="#id30" id="id13">[12]</a>  <a class="footnote-reference" href="#id31" id="id14">[13]</a>, school research team and countless talent engineers
passion.
It terminated the situation of everyone trying to re-invent wheels during 10
years ago.
Extend your software from the re-usable source code is the right way.
Of course you should consider an open source license if you are working
with business.
Actually anyone can contribute back to open source through the learning process.
This book is written through the process of learning llvm backend and contribute
back to llvm open source project.
We think this book cannot exists in traditional paper book form since only
few number of readers interested in study llvm backend even though
there are many paper published books in concept of compiler. So, this book
is published via electric media form and try to match the Open Document License
Expection <a class="footnote-reference" href="#id32" id="id15">[14]</a>.
There are distance between the concept and the realistic program implemenation.
Keep note through learning a large complicate software such as this llvm backend
is not enough.
We all learned the knowledge through books during school and after school.
So, if you cannot find a good way to produce documents, you can consider to
write documents like this book. This book document uses sphinx tool
just like the llvm development team. Sphinx uses restructured text format here
<a class="footnote-reference" href="#id33" id="id16">[15]</a> <a class="footnote-reference" href="#id34" id="id17">[16]</a> <a class="footnote-reference" href="#id35" id="id18">[17]</a>.
Appendix A of lbd book tell you how to install sphinx tool.
Documentation work will help yourself to re-examine your software and make your
program better in structure, reliability and more important &#8220;Extend your code
to somewhere you didn&#8217;t expect&#8221;.</p>
<table class="docutils footnote" frame="void" id="id19" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><a class="reference external" href="http://lld.llvm.org/">http://lld.llvm.org/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id20" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td><a class="reference external" href="http://lld.llvm.org/getting_started.html#on-unix-like-systems">http://lld.llvm.org/getting_started.html#on-unix-like-systems</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id21" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td><a class="reference external" href="http://llvm.org/releases/download.html#3.5">http://llvm.org/releases/download.html#3.5</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id22" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td><a class="reference external" href="http://www.cplusplus.com/reference/memory/unique_ptr/">http://www.cplusplus.com/reference/memory/unique_ptr/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id23" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[5]</a></td><td><a class="reference external" href="http://www.cplusplus.com/reference/memory/unique_ptr/get/">http://www.cplusplus.com/reference/memory/unique_ptr/get/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id24" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[6]</a></td><td><a class="reference external" href="http://www.cplusplus.com/reference/utility/move/">http://www.cplusplus.com/reference/utility/move/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id25" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[7]</a></td><td><a class="reference external" href="http://en.wikipedia.org/wiki/BSD_Documentation_License">http://en.wikipedia.org/wiki/BSD_Documentation_License</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id26" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[8]</a></td><td><a class="reference external" href="http://www.freebsd.org/docproj/">http://www.freebsd.org/docproj/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id27" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[9]</a></td><td><a class="reference external" href="http://www.freebsd.org/copyright/freebsd-doc-license.html">http://www.freebsd.org/copyright/freebsd-doc-license.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id28" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id11">[10]</a></td><td><a class="reference external" href="http://en.wikipedia.org/wiki/GNU_Free_Documentation_License">http://en.wikipedia.org/wiki/GNU_Free_Documentation_License</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id29" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id12">[11]</a></td><td><a class="reference external" href="http://www.gnu.org/copyleft/fdl.html">http://www.gnu.org/copyleft/fdl.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id30" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id13">[12]</a></td><td><a class="reference external" href="http://www.apple.com/opensource/">http://www.apple.com/opensource/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id31" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id14">[13]</a></td><td><a class="reference external" href="https://www.ibm.com/developerworks/opensource/">https://www.ibm.com/developerworks/opensource/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id32" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id15">[14]</a></td><td><a class="reference external" href="http://www.gnu.org/philosophy/free-doc.en.html">http://www.gnu.org/philosophy/free-doc.en.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id33" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id16">[15]</a></td><td><a class="reference external" href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id34" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id17">[16]</a></td><td><a class="reference external" href="http://docutils.sourceforge.net/docs/ref/rst/directives.html">http://docutils.sourceforge.net/docs/ref/rst/directives.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id35" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id18">[17]</a></td><td><a class="reference external" href="http://docutils.sourceforge.net/rst.html">http://docutils.sourceforge.net/rst.html</a></td></tr>
</tbody>
</table>
</div>
</div>
</div>


      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="about.html">About</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="opt.html">Optimization</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer">
        &copy; Copyright 2013, LLVM.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.
    </div>
  </body>
</html>