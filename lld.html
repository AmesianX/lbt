<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Cpu0 ELF linker &mdash; Tutorial: Creating an LLVM Toolchain for the Cpu0 Architecture</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '3.7.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="top" title="Tutorial: Creating an LLVM Toolchain for the Cpu0 Architecture" href="index.html" />
    <link rel="next" title="Optimization" href="opt.html" />
    <link rel="prev" title="About" href="about.html" /> 
  </head>
  <body role="document">
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>Tutorial: Creating an LLVM Toolchain for the Cpu0 Architecture</span></a></h1>
        <h2 class="heading"><span>Cpu0 ELF linker</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="about.html">About</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="opt.html">Optimization</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="cpu0-elf-linker">
<span id="sec-lld"></span><h1>Cpu0 ELF linker<a class="headerlink" href="#cpu0-elf-linker" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#elf-to-hex" id="id33">ELF to Hex</a></li>
<li><a class="reference internal" href="#create-cpu0-backend-under-lld" id="id34">Create Cpu0 backend under LLD</a><ul>
<li><a class="reference internal" href="#setup-cpu0-backend-under-lld" id="id35">Setup Cpu0 backend under lld</a></li>
<li><a class="reference internal" href="#cpu0-backend-souce-code" id="id36">Cpu0 backend souce code</a></li>
<li><a class="reference internal" href="#lld-introduction" id="id37">LLD introduction</a><ul>
<li><a class="reference internal" href="#how-lld-do-the-linker-job" id="id38">How LLD do the linker job</a></li>
<li><a class="reference internal" href="#linking-steps" id="id39">Linking Steps</a><ul>
<li><a class="reference internal" href="#command-line-processing" id="id40">Command line processing</a></li>
<li><a class="reference internal" href="#parsing-input-files" id="id41">Parsing input files</a></li>
<li><a class="reference internal" href="#resolving" id="id42">Resolving</a></li>
<li><a class="reference internal" href="#passes-optimizations" id="id43">Passes/Optimizations</a></li>
<li><a class="reference internal" href="#generate-output-file" id="id44">Generate Output File</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#static-linker" id="id45">Static linker</a><ul>
<li><a class="reference internal" href="#run" id="id46">Run</a></li>
<li><a class="reference internal" href="#cpu0-lld-structure" id="id47">Cpu0 lld structure</a></li>
</ul>
</li>
<li><a class="reference internal" href="#dynamic-linker" id="id48">Dynamic linker</a><ul>
<li><a class="reference internal" href="#id6" id="id49">Run</a></li>
<li><a class="reference internal" href="#how-to-work" id="id50">How to work</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#summary" id="id51">Summary</a><ul>
<li><a class="reference internal" href="#create-a-new-backend-base-on-llvm" id="id52">Create a new backend base on LLVM</a></li>
<li><a class="reference internal" href="#contribute-back-to-open-source-through-working-and-learning" id="id53">Contribute back to Open Source through working and learning</a></li>
</ul>
</li>
</ul>
</div>
<p>LLD changes quickly and the figures of this chapter is not up to date.
Like llvm, lld linker include a couple of target in ELF format handling.
The term Cpu0 backend used in this chapter can refer to the ELF format handling
for Cpu0 target machine under lld, llvm compiler backend, or both. But
supposing readers will easy knowing what it refer to.</p>
<div class="figure align-center" id="id19">
<span id="lld-f-workflow"></span><a class="reference internal image-reference" href="_images/1.png"><img alt="_images/1.png" src="_images/1.png" style="width: 899.0px; height: 261.0px;" /></a>
<p class="caption"><span class="caption-number">Fig. 2 </span><span class="caption-text">Code generation and execution flow</span></p>
</div>
<p>As depicted in <a class="reference internal" href="#lld-f-workflow"><span class="std std-numref">Fig. 2</span></a> of chapter About. Beside llvm backend,
we implement ELF linker and elf2hex to run on Cpu0 verilog simulator.
This chapter extends lld to support Cpu0 backend as well as elf2hex to replace
Cpu0 loader.
After link with lld,
the program with global variables can be allocated in ELF file format layout.
Meaning the relocation records of global variables is resolved. In addition,
elf2hex is implemented for supporting generate Hex file from ELF.
With these two tools supported, the global variables exists in
section .data and .rodata can be accessed and transfered to Hex file which feeds
to Verilog Cpu0 machine and run on your PC/Laptop.</p>
<p>As the previouse chapters mentioned, Cpu0 has two relocation models for static
link and dynamic link, respectively, which controlled by option
<code class="docutils literal"><span class="pre">-relocation-model</span></code> in <code class="docutils literal"><span class="pre">llc</span></code>.
This chapter supports the static link fully, and part of dynamic link for
demostration purpose. Since dynamic link needs the OS involement and the
Cpu0 is run on Verilog bare metal simulator, the dynamic linker program
is added and the Cpu0 Verilog code is extended to demostrate these Cpu0 PIC mode
instructions are work correctly in dynamice link.
However, these part of Cpu0 Verilog codes are not needed in a real machine with
OS support, and the Cpu0 lld&#8217;s and elf2hex&#8217;s dynamic linker function is not full
implemented.
They are programmed by a specific shared library name since the shared library
locating needs the OS&#8217;s help (files management is part of OS&#8217;s job).
Without OS, these things cannot be solved and dynamic link is impossible to
finish.
Anyway, for the dynamic link demostration, we can implement dynamic linker
program and adapt lld, elf2hex, and Cpu0 Verilog code to support a specific
shared library and verify the dynamic link result.
In reality, the Micro CPUs without OS or tiny OS inside only support static
link for C language.</p>
<p>About lld please refer LLD web site here <a class="footnote-reference" href="#lldweb" id="id1">[1]</a> and LLD install requirement
on Linux here <a class="footnote-reference" href="#lld-install" id="id2">[2]</a>.
Currently, lld can be built by: gcc and clang 3.5 compiler on Ubuntu, and gcc
on Fedora, as I have tried.
On iMac, lld can be built by clang with the Xcode version as the next sub
section.
If you run with Virtual Machine (VM), please keep your phisical memory size
setting over 1GB to avoid insufficient memory link error.</p>
<div class="section" id="elf-to-hex">
<h2><a class="toc-backref" href="#id33">ELF to Hex</a><a class="headerlink" href="#elf-to-hex" title="Permalink to this headline">¶</a></h2>
<p>Copy exlbt/elf2hex to llvm/test/src/tools/ to supporting ELF to
Hex for Cpu0 backend as follows,</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">1-160-136-173:tools Jonathan$</span> <span class="nb">pwd</span>
<span class="go">/Users/Jonathan/llvm/test/src/tools</span>
<span class="gp">1-160-136-173:tools Jonathan$</span> cp -rf ~/test/exlbt/elf2hex .
</pre></div>
</div>
<p class="rubric">exlbt/elf2hex/CMakeLists.txt</p>
<div class="highlight-default"><div class="highlight"><pre><span></span># elf2hex.cpp needs backend related functions, like 
# LLVMInitializeCpu0TargetInfo and LLVMInitializeCpu0Disassembler ... etc.
# Set LLVM_LINK_COMPONENTS to ${LLVM_TARGETS_TO_BUILD} then it can link them
# during the link stage.
set(LLVM_LINK_COMPONENTS
  ${LLVM_TARGETS_TO_BUILD}
  )

add_llvm_tool(elf2hex
  elf2hex.cpp
  )
</pre></div>
</div>
<p class="rubric">exlbt/elf2hex/LLVMBuild.txt</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">;</span><span class="o">===-</span> <span class="o">./</span><span class="n">tools</span><span class="o">/</span><span class="n">llvm</span><span class="o">-</span><span class="n">objdump</span><span class="o">/</span><span class="n">LLVMBuild</span><span class="o">.</span><span class="n">txt</span> <span class="o">-----------------------*-</span> <span class="n">Conf</span> <span class="o">-*--===</span><span class="p">;</span>
<span class="p">;</span>
<span class="p">;</span>                     <span class="n">The</span> <span class="n">LLVM</span> <span class="n">Compiler</span> <span class="n">Infrastructure</span>
<span class="p">;</span>
<span class="p">;</span> <span class="n">This</span> <span class="n">file</span> <span class="ow">is</span> <span class="n">distributed</span> <span class="n">under</span> <span class="n">the</span> <span class="n">University</span> <span class="n">of</span> <span class="n">Illinois</span> <span class="n">Open</span> <span class="n">Source</span>
<span class="p">;</span> <span class="n">License</span><span class="o">.</span> <span class="n">See</span> <span class="n">LICENSE</span><span class="o">.</span><span class="n">TXT</span> <span class="k">for</span> <span class="n">details</span><span class="o">.</span>
<span class="p">;</span>
<span class="p">;</span><span class="o">===------------------------------------------------------------------------===</span><span class="p">;</span>
<span class="p">;</span>
<span class="p">;</span> <span class="n">This</span> <span class="ow">is</span> <span class="n">an</span> <span class="n">LLVMBuild</span> <span class="n">description</span> <span class="n">file</span> <span class="k">for</span> <span class="n">the</span> <span class="n">components</span> <span class="ow">in</span> <span class="n">this</span> <span class="n">subdirectory</span><span class="o">.</span>
<span class="p">;</span>
<span class="p">;</span> <span class="n">For</span> <span class="n">more</span> <span class="n">information</span> <span class="n">on</span> <span class="n">the</span> <span class="n">LLVMBuild</span> <span class="n">system</span><span class="p">,</span> <span class="n">please</span> <span class="n">see</span><span class="p">:</span>
<span class="p">;</span>
<span class="p">;</span>   <span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="n">llvm</span><span class="o">.</span><span class="n">org</span><span class="o">/</span><span class="n">docs</span><span class="o">/</span><span class="n">LLVMBuild</span><span class="o">.</span><span class="n">html</span>
<span class="p">;</span>
<span class="p">;</span><span class="o">===------------------------------------------------------------------------===</span><span class="p">;</span>

<span class="p">[</span><span class="n">component_0</span><span class="p">]</span>
<span class="nb">type</span> <span class="o">=</span> <span class="n">Tool</span>
<span class="n">name</span> <span class="o">=</span> <span class="n">elf2hex</span>
<span class="n">parent</span> <span class="o">=</span> <span class="n">Tools</span>
</pre></div>
</div>
<p class="rubric">exlbt/elf2hex/elf2hex.h</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span>
<span class="o">//</span>                     <span class="n">The</span> <span class="n">LLVM</span> <span class="n">Compiler</span> <span class="n">Infrastructure</span>
<span class="o">//</span>
<span class="o">//</span> <span class="n">This</span> <span class="n">file</span> <span class="ow">is</span> <span class="n">distributed</span> <span class="n">under</span> <span class="n">the</span> <span class="n">University</span> <span class="n">of</span> <span class="n">Illinois</span> <span class="n">Open</span> <span class="n">Source</span>
<span class="o">//</span> <span class="n">License</span><span class="o">.</span> <span class="n">See</span> <span class="n">LICENSE</span><span class="o">.</span><span class="n">TXT</span> <span class="k">for</span> <span class="n">details</span><span class="o">.</span>
<span class="o">//</span>
<span class="o">//===----------------------------------------------------------------------===//</span>

<span class="c1">#ifndef LLVM_TOOLS_ELF2HEX_ELF2HEX_H</span>
<span class="c1">#define LLVM_TOOLS_ELF2HEX_ELF2HEX_H</span>

<span class="c1">#include &quot;llvm/ADT/StringRef.h&quot;</span>
<span class="c1">#include &quot;llvm/Support/CommandLine.h&quot;</span>
<span class="c1">#include &quot;llvm/Support/DataTypes.h&quot;</span>

<span class="c1">#include &lt;stdio.h&gt;</span>
<span class="c1">#include &quot;llvm/Support/raw_ostream.h&quot;</span>

<span class="c1">#define BOOT_SIZE 16</span>

<span class="c1">#define DLINK</span>
<span class="o">//</span><span class="c1">#define ELF2HEX_DEBUG</span>

<span class="n">namespace</span> <span class="n">llvm</span> <span class="p">{</span>
<span class="n">namespace</span> <span class="nb">object</span> <span class="p">{</span>
  <span class="k">class</span> <span class="nc">COFFObjectFile</span><span class="p">;</span>
  <span class="k">class</span> <span class="nc">MachOObjectFile</span><span class="p">;</span>
  <span class="k">class</span> <span class="nc">ObjectFile</span><span class="p">;</span>
  <span class="k">class</span> <span class="nc">RelocationRef</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">extern</span> <span class="n">cl</span><span class="p">::</span><span class="n">opt</span><span class="o">&lt;</span><span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">TripleName</span><span class="p">;</span>
<span class="n">extern</span> <span class="n">cl</span><span class="p">::</span><span class="n">opt</span><span class="o">&lt;</span><span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">ArchName</span><span class="p">;</span>
<span class="n">extern</span> <span class="n">cl</span><span class="p">::</span><span class="nb">list</span><span class="o">&lt;</span><span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">MAttrs</span><span class="p">;</span>
<span class="n">extern</span> <span class="n">cl</span><span class="p">::</span><span class="n">opt</span><span class="o">&lt;</span><span class="nb">bool</span><span class="o">&gt;</span> <span class="n">NoShowRawInsn</span><span class="p">;</span>

<span class="o">//</span> <span class="n">Various</span> <span class="n">helper</span> <span class="n">functions</span><span class="o">.</span>
<span class="nb">bool</span> <span class="n">error</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">error_code</span> <span class="n">ec</span><span class="p">);</span>
<span class="nb">bool</span> <span class="n">RelocAddressLess</span><span class="p">(</span><span class="nb">object</span><span class="p">::</span><span class="n">RelocationRef</span> <span class="n">a</span><span class="p">,</span> <span class="nb">object</span><span class="p">::</span><span class="n">RelocationRef</span> <span class="n">b</span><span class="p">);</span>


<span class="p">}</span> <span class="o">//</span> <span class="n">end</span> <span class="n">namespace</span> <span class="n">llvm</span>

<span class="c1">#endif</span>
</pre></div>
</div>
<p class="rubric">exlbt/elf2hex/elf2hex-dlinker.h</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>#ifdef DLINK

class Cpu0DynFunIndex {
private:
  char soStrtab[20][100];
  int soStrtabSize = 0;

  char exePltName[20][100];
  int exePltNameSize = 0;

  int findPltName(const char* pltName);
public:
  void createPltName(const ObjectFile *o);
  void createStrtab();
  uint16_t correctDynFunIndex(const char* pltName);
};

int Cpu0DynFunIndex::findPltName(const char* pltName) {
  for (int i = 0; i &lt; exePltNameSize; i++)
    if (strcmp(pltName, exePltName[i]) == 0)
      return i;
  return -1;
}

void Cpu0DynFunIndex::createPltName(const ObjectFile *Obj) {
  std::error_code ec;
  std::string Error;

  for (const SectionRef &amp;Section : Obj-&gt;sections()) {
    if (error(ec)) return;
    StringRef Name;
    StringRef Contents;
    uint64_t BaseAddr;
    bool BSS;
    if (error(Section.getName(Name))) continue;
    if (error(Section.getContents(Contents))) continue;
    BaseAddr = Section.getAddress();
    BSS = Section.isBSS();

    if (Name == &quot;.strtab&quot;) {
      int num_dyn_entry = 0;
      FILE *fd_num_dyn_entry;
      fd_num_dyn_entry = fopen(&quot;dlconfig/num_dyn_entry&quot;, &quot;r&quot;);
      if (fd_num_dyn_entry != NULL) {
        fscanf(fd_num_dyn_entry, &quot;%d&quot;, &amp;num_dyn_entry);
      }
      fclose(fd_num_dyn_entry);

      for (std::size_t addr = 2+strlen(&quot;.PLT0&quot;), end = Contents.size(); 
           addr &lt; end; ) {
        if (Contents.substr(addr, strlen(&quot;__plt_&quot;)) != &quot;__plt_&quot;)
          break;
        strcpy(exePltName[exePltNameSize], Contents.data()+addr);
        addr = addr + strlen(exePltName[exePltNameSize]) + 1;
        exePltNameSize++;
      }
      break;
    }
  }
}

void Cpu0DynFunIndex::createStrtab() {
  FILE *fd_dynstrAscii;

  fd_dynstrAscii = fopen(&quot;dlconfig/dynstrAscii&quot;, &quot;r&quot;);
  if (fd_dynstrAscii == NULL)
    fclose(fd_dynstrAscii);
  assert(fd_dynstrAscii != NULL &amp;&amp; &quot;fd_dynstr == NULL&quot;);
  int i = 0;
  // function                  result on EOF or error                    
  // --------                  ----------------------
  // fgets()                   NULL
  // fscanf()                  number of succesful conversions
  //                             less than expected
  // fgetc()                   EOF
  // fread()                   number of elements read
  //                             less than expected
  int j = 0;
  for (i=0; 1; i++) {
    j=fscanf(fd_dynstrAscii, &quot;%s&quot;, soStrtab[i]);
    if (j != 1)
      break;
  }
  soStrtabSize = i;
  fclose(fd_dynstrAscii);
}

uint16_t Cpu0DynFunIndex::correctDynFunIndex(const char* pltName) {
  int i = findPltName(pltName);
  if (i != -1) {
    int j = 0;
    for (j=0; j &lt; soStrtabSize; j++)
      if (strcmp(soStrtab[j], (const char*)exePltName[i]+strlen(&quot;__plt_&quot;)) == 0)
        break;
    if (j == soStrtabSize) {
      outs() &lt;&lt; &quot;cannot find &quot; &lt;&lt; exePltName[i] &lt;&lt; &quot;\n&quot;;
      exit(1);
    }
    j++;
    return (uint16_t)(j &amp; 0xffff);
  }
  return (uint16_t)0;
}

Cpu0DynFunIndex cpu0DynFunIndex;

static void DisassembleSoInHexFormat(const ObjectFile *Obj
/*, bool InlineRelocs*/  , std::unique_ptr&lt;MCDisassembler&gt;&amp; DisAsm, 
  std::unique_ptr&lt;MCInstPrinter&gt;&amp; IP, uint64_t&amp; lastDumpAddr,
  std::unique_ptr&lt;const MCSubtargetInfo&gt;&amp; STI) {
  std::string Error;
  uint64_t soLastPrintAddr = 0;
  FILE *fd_so_func_offset;
  int num_dyn_entry = 0;
  
  fd_so_func_offset = fopen(&quot;dlconfig/so_func_offset&quot;, &quot;w&quot;);
  if (fd_so_func_offset == NULL)
    fclose(fd_so_func_offset);
  assert(fd_so_func_offset != NULL &amp;&amp; &quot;fd_so_func_offset == NULL&quot;);

#ifdef ELF2HEX_DEBUG
  errs() &lt;&lt; format(&quot;!lastDumpAddr %8&quot; PRIx64 &quot;\n&quot;, lastDumpAddr);
#endif
  std::error_code ec;
  for (const SectionRef &amp;Section : Obj-&gt;sections()) {
    if (error(ec)) break;
    StringRef Name;
    StringRef Contents;
    uint64_t BaseAddr;
    if (error(Section.getName(Name))) continue;
    if (error(Section.getContents(Contents))) continue;
    BaseAddr = Section.getAddress();
  #ifdef ELF2HEX_DEBUG
    errs() &lt;&lt; &quot;Name &quot; &lt;&lt; Name &lt;&lt; format(&quot;  BaseAddr %8&quot; PRIx64 &quot;\n&quot;, BaseAddr);
    errs() &lt;&lt; format(&quot;!!lastDumpAddr %8&quot; PRIx64 &quot;\n&quot;, lastDumpAddr);
  #endif
    bool text;
    text = Section.isText();
    if (!text) {
      continue;
    }
    // It&#39;s .text section
    uint64_t SectionAddr;
    SectionAddr = Section.getAddress();

    // Make a list of all the symbols in this section.
    std::vector&lt;std::pair&lt;uint64_t, StringRef&gt; &gt; Symbols;
    for (const SymbolRef &amp;Symbol : Obj-&gt;symbols()) {
      if (Section.containsSymbol(Symbol)) {
        ErrorOr&lt;uint64_t&gt; AddressOrErr = Symbol.getAddress();
        if (error(AddressOrErr.getError()))
          break;
        uint64_t Address = *AddressOrErr;
        Address -= SectionAddr;

        ErrorOr&lt;StringRef&gt; Name = Symbol.getName();
        if (error(Name.getError()))
          break;
        Symbols.push_back(std::make_pair(Address, *Name));
      }
    }

    // Sort the symbols by address, just in case they didn&#39;t come in that way.
    array_pod_sort(Symbols.begin(), Symbols.end());

    // Make a list of all the relocations for this section.
    std::vector&lt;RelocationRef&gt; Rels;

    // Sort relocations by address.
    std::sort(Rels.begin(), Rels.end(), RelocAddressLess);

    StringRef SegmentName = &quot;&quot;;
    if (const MachOObjectFile *MachO =
        dyn_cast&lt;const MachOObjectFile&gt;(Obj)) {
      DataRefImpl DR = Section.getRawDataRefImpl();
      SegmentName = MachO-&gt;getSectionFinalSegmentName(DR);
    }
    StringRef name;
    if (error(Section.getName(name))) break;
    if (name == &quot;.plt&quot;) continue;
    outs() &lt;&lt; &quot;/*&quot; &lt;&lt; &quot;Disassembly of section &quot;;
    if (!SegmentName.empty())
      outs() &lt;&lt; SegmentName &lt;&lt; &quot;,&quot;;
    outs() &lt;&lt; name &lt;&lt; &#39;:&#39; &lt;&lt; &quot;*/&quot;;

    // If the section has no symbols just insert a dummy one and disassemble
    // the whole section.
    if (Symbols.empty())
      Symbols.push_back(std::make_pair(0, name));

    SmallString&lt;40&gt; Comments;
    raw_svector_ostream CommentStream(Comments);

    StringRef BytesStr;
    if (error(Section.getContents(BytesStr))) break;
    ArrayRef&lt;uint8_t&gt; Bytes(reinterpret_cast&lt;const uint8_t *&gt;(BytesStr.data()),
                            BytesStr.size());
    uint64_t Size;
    uint64_t Index;
    uint64_t SectSize;
    SectSize = Section.getSize();

    std::vector&lt;RelocationRef&gt;::const_iterator rel_cur = Rels.begin();
    std::vector&lt;RelocationRef&gt;::const_iterator rel_end = Rels.end();
    // Disassemble symbol by symbol.
    for (unsigned si = 0, se = Symbols.size(); si != se; ++si) {
      uint64_t Start = Symbols[si].first;
      uint64_t End;
      // The end is either the size of the section or the beginning of the next
      // symbol.
      if (si == se - 1)
        End = SectSize;
      // Make sure this symbol takes up space.
      else if (Symbols[si + 1].first != Start)
        End = Symbols[si + 1].first - 1;
      else {
        // This symbol has the same address as the next symbol. Skip it.
        fprintf(fd_so_func_offset, &quot;%02x &quot;, 
                (uint8_t)(Symbols[si].first &gt;&gt; 24));
        fprintf(fd_so_func_offset, &quot;%02x &quot;, 
                (uint8_t)((Symbols[si].first &gt;&gt; 16) &amp; 0xFF));
        fprintf(fd_so_func_offset, &quot;%02x &quot;, 
                (uint8_t)((Symbols[si].first &gt;&gt; 8) &amp; 0xFF));
        fprintf(fd_so_func_offset, &quot;%02x    &quot;, 
                (uint8_t)((Symbols[si].first) &amp; 0xFF));
        std::string str = Symbols[si].second.str();
        std::size_t idx = 0;
        std::size_t strSize = 0;
        for (idx = 0, strSize = str.size(); idx &lt; strSize; idx++) {
          fprintf(fd_so_func_offset, &quot;%c%c &quot;, 
                  hexdigit((str[idx] &gt;&gt; 4) &amp; 0xF, true),
                  hexdigit(str[idx] &amp; 0xF, true));
        }
        for (idx = strSize; idx &lt; 48; idx++) {
          fprintf(fd_so_func_offset, &quot;%02x &quot;, 0);
        }
        fprintf(fd_so_func_offset, &quot;/* %s */\n&quot;, Symbols[si].second.begin());
        num_dyn_entry++;

        outs() &lt;&lt; &#39;\n&#39; &lt;&lt; &quot;/*&quot; &lt;&lt; Symbols[si].second &lt;&lt; &quot;:*/\n&quot;;
        continue;
      }

      soLastPrintAddr = Symbols[si].first;
      fprintf(fd_so_func_offset, &quot;%02x &quot;, (uint8_t)(Symbols[si].first &gt;&gt; 24));
      fprintf(fd_so_func_offset, &quot;%02x &quot;, 
              (uint8_t)((Symbols[si].first &gt;&gt; 16) &amp; 0xFF));
      fprintf(fd_so_func_offset, &quot;%02x &quot;, 
              (uint8_t)((Symbols[si].first &gt;&gt; 8) &amp; 0xFF));
      fprintf(fd_so_func_offset, &quot;%02x    &quot;, 
              (uint8_t)((Symbols[si].first) &amp; 0xFF));
      std::string str = Symbols[si].second.str();
      std::size_t idx = 0;
      std::size_t strSize = 0;
      for (idx = 0, strSize = str.size(); idx &lt; strSize; idx++) {
        fprintf(fd_so_func_offset, &quot;%c%c &quot;, 
                hexdigit((str[idx] &gt;&gt; 4) &amp; 0xF, true), 
                hexdigit(str[idx] &amp; 0xF, true));
      }
      for (idx = strSize; idx &lt; 48; idx++) {
        fprintf(fd_so_func_offset, &quot;%02x &quot;, 0);
      }
      fprintf(fd_so_func_offset, &quot;/* %s */\n&quot;, Symbols[si].second.begin());
      num_dyn_entry++;

      outs() &lt;&lt; &#39;\n&#39; &lt;&lt; &quot;/*&quot; &lt;&lt; Symbols[si].second &lt;&lt; &quot;:*/\n&quot;;
#ifndef NDEBUG
        raw_ostream &amp;DebugOut = DebugFlag ? dbgs() : nulls();
#else
        raw_ostream &amp;DebugOut = nulls();
#endif

      for (Index = Start; Index &lt; End; Index += Size) {
        MCInst Inst;
        if (DisAsm-&gt;getInstruction(Inst, Size, Bytes.slice(Index),
                                   SectionAddr + Index, DebugOut,
                                   CommentStream)) {
          outs() &lt;&lt; format(&quot;/*%8&quot; PRIx64 &quot;:*/&quot;, Index);
          if (!NoShowRawInsn) {
            outs() &lt;&lt; &quot;\t&quot;;
            dumpBytes(Bytes.slice(Index, Size), outs());
          }
          outs() &lt;&lt; &quot;/*&quot;;
          IP-&gt;printInst(&amp;Inst, outs(), &quot;&quot;, *STI);
          outs() &lt;&lt; CommentStream.str();
          outs() &lt;&lt; &quot;*/&quot;;
          Comments.clear();
          outs() &lt;&lt; &quot;\n&quot;;
        } else {
          errs() &lt;&lt; ToolName &lt;&lt; &quot;: warning: invalid instruction encoding\n&quot;;
          if (Size == 0)
            Size = 1; // skip illegible bytes
        }

      #ifdef ELF2HEX_DEBUG
        outs() &lt;&lt; &quot;Size = &quot; &lt;&lt; Size &lt;&lt;  &quot; Index = &quot; &lt;&lt; Index &lt;&lt; &quot; lastDumpAddr = &quot;
               &lt;&lt; lastDumpAddr &lt;&lt; &quot;\n&quot;; // debug
      #endif
        // Print relocation for instruction.
        while (rel_cur != rel_end) {
          bool hidden = getHidden(*rel_cur);
          uint64_t addr = rel_cur-&gt;getOffset();
          SmallString&lt;16&gt; name;
          SmallString&lt;32&gt; val;

          // If this relocation is hidden, skip it.
          if (hidden) goto skip_print_rel;

          // Stop when rel_cur&#39;s address is past the current instruction.
          if (addr &gt;= Index + Size) break;
          rel_cur-&gt;getTypeName(name);
          if (error(getRelocationValueString(*rel_cur, val)))
            goto skip_print_rel;

          outs() &lt;&lt; format(&quot;\t\t\t/*%8&quot; PRIx64 &quot;: &quot;, SectionAddr + addr) &lt;&lt; name
                 &lt;&lt; &quot;\t&quot; &lt;&lt; val &lt;&lt; &quot;*/\n&quot;;

        skip_print_rel:
          ++rel_cur;
        }
      }
      soLastPrintAddr = End;
      lastDumpAddr += Index;
    #ifdef ELF2HEX_DEBUG
      errs() &lt;&lt; format(&quot;SectionAddr + Index = %8&quot; PRIx64 &quot;\n&quot;, SectionAddr + Index);
      errs() &lt;&lt; format(&quot;lastDumpAddr %8&quot; PRIx64 &quot;\n&quot;, lastDumpAddr);
    #endif
    }
  }
// Dump share obj or lib
// Fix the issue that __tls_get_addr appear as file offset 0.
// Old lld version the __tls_get_addr appear at the last function name.
  std::pair&lt;uint64_t, StringRef&gt; dummy(soLastPrintAddr, &quot;dummy&quot;);
  fprintf(fd_so_func_offset, &quot;%02x &quot;, (uint8_t)(dummy.first &gt;&gt; 24));
  fprintf(fd_so_func_offset, &quot;%02x &quot;, (uint8_t)((dummy.first &gt;&gt; 16) &amp; 0xFF));
  fprintf(fd_so_func_offset, &quot;%02x &quot;, (uint8_t)((dummy.first &gt;&gt; 8) &amp; 0xFF));
  fprintf(fd_so_func_offset, &quot;%02x    &quot;, (uint8_t)((dummy.first) &amp; 0xFF));
  std::string str = dummy.second.str();
  std::size_t idx = 0;
  std::size_t strSize = 0;
  for (idx = 0, strSize = str.size(); idx &lt; strSize; idx++) {
    fprintf(fd_so_func_offset, &quot;%c%c &quot;, hexdigit((str[idx] &gt;&gt; 4) &amp; 0xF, true)
            , hexdigit(str[idx] &amp; 0xF, true));
  }
  for (idx = strSize; idx &lt; 48; idx++) {
    fprintf(fd_so_func_offset, &quot;%02x &quot;, 0);
  }
  fprintf(fd_so_func_offset, &quot;/* %s */\n&quot;, dummy.second.begin());
  num_dyn_entry++;
  outs() &lt;&lt; &#39;\n&#39; &lt;&lt; &quot;/*&quot; &lt;&lt; dummy.second &lt;&lt; &quot;:*/\n&quot;;
  FILE *fd_num_dyn_entry;
  fd_num_dyn_entry = fopen(&quot;dlconfig/num_dyn_entry&quot;, &quot;w&quot;);
  if (fd_num_dyn_entry != NULL) {
    fprintf(fd_num_dyn_entry, &quot;%d\n&quot;, num_dyn_entry);
  }
  fclose(fd_num_dyn_entry);
}

static void PrintSoDataSections(const ObjectFile *o, uint64_t&amp; lastDumpAddr, 
                                bool isLittleEndian) {
  std::error_code ec;

  for (const SectionRef &amp;Section : o-&gt;sections()) {
    if (error(ec)) return;
    StringRef Name;
    StringRef Contents;
    uint64_t BaseAddr;
    bool BSS;
    if (error(Section.getName(Name))) continue;
    if (error(Section.getContents(Contents))) continue;
    BaseAddr = Section.getAddress();
    BSS = Section.isBSS();
    if (Name == &quot;.dynsym&quot;) {
      int num_dyn_entry = 0;
      FILE *fd_num_dyn_entry;
      fd_num_dyn_entry = fopen(&quot;dlconfig/num_dyn_entry&quot;, &quot;r&quot;);
      if (fd_num_dyn_entry != NULL) {
        fscanf(fd_num_dyn_entry, &quot;%d&quot;, &amp;num_dyn_entry);
      }
      fclose(fd_num_dyn_entry);
      raw_fd_ostream fd_dynsym(&quot;dlconfig/dynsym&quot;, ec, sys::fs::F_Text);
      int count = 0;
      for (std::size_t addr = 0, end = Contents.size(); addr &lt; end; addr += 16) {
        if (isLittleEndian) {
          fd_dynsym &lt;&lt; hexdigit((Contents[addr+3] &gt;&gt; 4) &amp; 0xF, true)
                     &lt;&lt; hexdigit(Contents[addr+3] &amp; 0xF, true) &lt;&lt; &quot; &quot;;
          fd_dynsym &lt;&lt; hexdigit((Contents[addr+2] &gt;&gt; 4) &amp; 0xF, true)
                     &lt;&lt; hexdigit(Contents[addr+2] &amp; 0xF, true) &lt;&lt; &quot; &quot;;
          fd_dynsym &lt;&lt; hexdigit((Contents[addr+1] &gt;&gt; 4) &amp; 0xF, true)
                     &lt;&lt; hexdigit(Contents[addr+1] &amp; 0xF, true) &lt;&lt; &quot; &quot;;
          fd_dynsym &lt;&lt; hexdigit((Contents[addr] &gt;&gt; 4) &amp; 0xF, true)
                     &lt;&lt; hexdigit(Contents[addr] &amp; 0xF, true) &lt;&lt; &quot; &quot;;
        }
        else {
          fd_dynsym &lt;&lt; hexdigit((Contents[addr] &gt;&gt; 4) &amp; 0xF, true)
                     &lt;&lt; hexdigit(Contents[addr] &amp; 0xF, true) &lt;&lt; &quot; &quot;;
          fd_dynsym &lt;&lt; hexdigit((Contents[addr+1] &gt;&gt; 4) &amp; 0xF, true)
                     &lt;&lt; hexdigit(Contents[addr+1] &amp; 0xF, true) &lt;&lt; &quot; &quot;;
          fd_dynsym &lt;&lt; hexdigit((Contents[addr+2] &gt;&gt; 4) &amp; 0xF, true)
                     &lt;&lt; hexdigit(Contents[addr+2] &amp; 0xF, true) &lt;&lt; &quot; &quot;;
          fd_dynsym &lt;&lt; hexdigit((Contents[addr+3] &gt;&gt; 4) &amp; 0xF, true)
                     &lt;&lt; hexdigit(Contents[addr+3] &amp; 0xF, true) &lt;&lt; &quot; &quot;;
        }
        count++;
      }
      for (int i = count; i &lt; num_dyn_entry; i++) {
        fd_dynsym &lt;&lt; &quot;00 00 00 00 &quot;;
      }
    }
    else if (Name == &quot;.dynstr&quot;) {
      raw_fd_ostream fd_dynstr(&quot;dlconfig/dynstr&quot;, ec, sys::fs::F_Text);
      raw_fd_ostream fd_dynstrAscii(&quot;dlconfig/dynstrAscii&quot;, ec, 
                                    sys::fs::F_Text);
      for (std::size_t addr = 0, end = Contents.size(); addr &lt; end; addr++) {
        fd_dynstr &lt;&lt; hexdigit((Contents[addr] &gt;&gt; 4) &amp; 0xF, true)
                   &lt;&lt; hexdigit(Contents[addr] &amp; 0xF, true) &lt;&lt; &quot; &quot;;
        if (addr == 0)
          continue;
        if (Contents[addr] == &#39;\0&#39;)
          fd_dynstrAscii &lt;&lt; &quot;\n&quot;;
        else
          fd_dynstrAscii &lt;&lt; Contents[addr];
      }
    }
  }
}

#endif // DLINK
</pre></div>
</div>
<p class="rubric">exlbt/elf2hex/elf2hex.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>//===-- llvm-objdump.cpp - Object file dumping utility for llvm -----------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This program is a utility that works like binutils &quot;objdump&quot;, that is, it
// dumps out a plethora of information about an object file depending on the
// flags.
//
// The flags and output of this program should be near identical to those of
// binutils objdump.
//
//===----------------------------------------------------------------------===//

#include &quot;elf2hex.h&quot;
#include &quot;llvm/ADT/Optional.h&quot;
#include &quot;llvm/ADT/STLExtras.h&quot;
#include &quot;llvm/ADT/StringExtras.h&quot;
#include &quot;llvm/ADT/Triple.h&quot;
#include &quot;llvm/CodeGen/FaultMaps.h&quot;
#include &quot;llvm/MC/MCAsmInfo.h&quot;
#include &quot;llvm/MC/MCContext.h&quot;
#include &quot;llvm/MC/MCDisassembler.h&quot;
#include &quot;llvm/MC/MCInst.h&quot;
#include &quot;llvm/MC/MCInstPrinter.h&quot;
#include &quot;llvm/MC/MCInstrAnalysis.h&quot;
#include &quot;llvm/MC/MCInstrInfo.h&quot;
#include &quot;llvm/MC/MCObjectFileInfo.h&quot;
#include &quot;llvm/MC/MCRegisterInfo.h&quot;
#include &quot;llvm/MC/MCRelocationInfo.h&quot;
#include &quot;llvm/MC/MCSubtargetInfo.h&quot;
#include &quot;llvm/Object/Archive.h&quot;
#include &quot;llvm/Object/ELFObjectFile.h&quot;
#include &quot;llvm/Object/COFF.h&quot;
#include &quot;llvm/Object/MachO.h&quot;
#include &quot;llvm/Object/ObjectFile.h&quot;
#include &quot;llvm/Support/Casting.h&quot;
#include &quot;llvm/Support/CommandLine.h&quot;
#include &quot;llvm/Support/Debug.h&quot;
#include &quot;llvm/Support/Errc.h&quot;
#include &quot;llvm/Support/FileSystem.h&quot;
#include &quot;llvm/Support/Format.h&quot;
#include &quot;llvm/Support/GraphWriter.h&quot;
#include &quot;llvm/Support/Host.h&quot;
#include &quot;llvm/Support/ManagedStatic.h&quot;
#include &quot;llvm/Support/MemoryBuffer.h&quot;
#include &quot;llvm/Support/PrettyStackTrace.h&quot;
#include &quot;llvm/Support/Signals.h&quot;
#include &quot;llvm/Support/SourceMgr.h&quot;
#include &quot;llvm/Support/TargetRegistry.h&quot;
#include &quot;llvm/Support/TargetSelect.h&quot;
#include &quot;llvm/Support/raw_ostream.h&quot;
#include &lt;algorithm&gt;
#include &lt;cctype&gt;
#include &lt;cstring&gt;
#include &lt;system_error&gt;

using namespace llvm;
using namespace object;

static cl::list&lt;std::string&gt;
InputFilenames(cl::Positional, cl::desc(&quot;&lt;input object files&gt;&quot;),cl::ZeroOrMore);

cl::opt&lt;std::string&gt;
llvm::TripleName(&quot;triple&quot;, cl::desc(&quot;Target triple to disassemble for, &quot;
                                    &quot;see -version for available targets&quot;));

cl::opt&lt;std::string&gt;
llvm::ArchName(&quot;arch-name&quot;, cl::desc(&quot;Target arch to disassemble for, &quot;
                                &quot;see -version for available targets&quot;));

cl::list&lt;std::string&gt;
llvm::MAttrs(&quot;mattr&quot;,
  cl::CommaSeparated,
  cl::desc(&quot;Target specific attributes&quot;),
  cl::value_desc(&quot;a1,+a2,-a3,...&quot;));

cl::opt&lt;bool&gt;
llvm::NoShowRawInsn(&quot;no-show-raw-insn&quot;, cl::desc(&quot;When disassembling &quot;
                                                 &quot;instructions, do not print &quot;
                                                 &quot;the instruction bytes.&quot;));

static StringRef ToolName;
static int ReturnValue = EXIT_SUCCESS;

bool llvm::error(std::error_code EC) {
  if (!EC)
    return false;

  outs() &lt;&lt; ToolName &lt;&lt; &quot;: error reading file: &quot; &lt;&lt; EC.message() &lt;&lt; &quot;.\n&quot;;
  outs().flush();
  ReturnValue = EXIT_FAILURE;
  return true;
}

static void report_error(StringRef File, std::error_code EC) {
  assert(EC);
  errs() &lt;&lt; ToolName &lt;&lt; &quot;: &#39;&quot; &lt;&lt; File &lt;&lt; &quot;&#39;: &quot; &lt;&lt; EC.message() &lt;&lt; &quot;.\n&quot;;
  ReturnValue = EXIT_FAILURE;
}

static const Target *getTarget(const ObjectFile *Obj = nullptr) {
  // Figure out the target triple.
  llvm::Triple TheTriple(&quot;unknown-unknown-unknown&quot;);
  if (TripleName.empty()) {
    if (Obj) {
      TheTriple.setArch(Triple::ArchType(Obj-&gt;getArch()));
      // TheTriple defaults to ELF, and COFF doesn&#39;t have an environment:
      // the best we can do here is indicate that it is mach-o.
      if (Obj-&gt;isMachO())
        TheTriple.setObjectFormat(Triple::MachO);

      if (Obj-&gt;isCOFF()) {
        const auto COFFObj = dyn_cast&lt;COFFObjectFile&gt;(Obj);
        if (COFFObj-&gt;getArch() == Triple::thumb)
          TheTriple.setTriple(&quot;thumbv7-windows&quot;);
      }
    }
  } else
    TheTriple.setTriple(Triple::normalize(TripleName));

  // Get the target specific parser.
  std::string Error;
  const Target *TheTarget = TargetRegistry::lookupTarget(ArchName, TheTriple,
                                                         Error);
  if (!TheTarget) {
    errs() &lt;&lt; ToolName &lt;&lt; &quot;: &quot; &lt;&lt; Error;
    return nullptr;
  }

  // Update the triple name and return the found target.
  TripleName = TheTriple.getTriple();
  return TheTarget;
}

bool llvm::RelocAddressLess(RelocationRef a, RelocationRef b) {
  return a.getOffset() &lt; b.getOffset();
}

template &lt;class ELFT&gt;
static std::error_code getRelocationValueString(const ELFObjectFile&lt;ELFT&gt; *Obj,
                                                DataRefImpl Rel,
                                                SmallVectorImpl&lt;char&gt; &amp;Result) {
  typedef typename ELFObjectFile&lt;ELFT&gt;::Elf_Sym Elf_Sym;
  typedef typename ELFObjectFile&lt;ELFT&gt;::Elf_Shdr Elf_Shdr;
  typedef typename ELFObjectFile&lt;ELFT&gt;::Elf_Rel Elf_Rel;
  typedef typename ELFObjectFile&lt;ELFT&gt;::Elf_Rela Elf_Rela;

  const ELFFile&lt;ELFT&gt; &amp;EF = *Obj-&gt;getELFFile();

  ErrorOr&lt;const Elf_Shdr *&gt; SecOrErr = EF.getSection(Rel.d.a);
  if (std::error_code EC = SecOrErr.getError())
    return EC;
  const Elf_Shdr *Sec = *SecOrErr;
  ErrorOr&lt;const Elf_Shdr *&gt; SymTabOrErr = EF.getSection(Sec-&gt;sh_link);
  if (std::error_code EC = SymTabOrErr.getError())
    return EC;
  const Elf_Shdr *SymTab = *SymTabOrErr;
  assert(SymTab-&gt;sh_type == ELF::SHT_SYMTAB ||
         SymTab-&gt;sh_type == ELF::SHT_DYNSYM);
  ErrorOr&lt;const Elf_Shdr *&gt; StrTabSec = EF.getSection(SymTab-&gt;sh_link);
  if (std::error_code EC = StrTabSec.getError())
    return EC;
  ErrorOr&lt;StringRef&gt; StrTabOrErr = EF.getStringTable(*StrTabSec);
  if (std::error_code EC = StrTabOrErr.getError())
    return EC;
  StringRef StrTab = *StrTabOrErr;
  uint8_t type;
  StringRef res;
  int64_t addend = 0;
  uint16_t symbol_index = 0;
  switch (Sec-&gt;sh_type) {
  default:
    return object_error::parse_failed;
  case ELF::SHT_REL: {
    const Elf_Rel *ERel = Obj-&gt;getRel(Rel);
    type = ERel-&gt;getType(EF.isMips64EL());
    symbol_index = ERel-&gt;getSymbol(EF.isMips64EL());
    // TODO: Read implicit addend from section data.
    break;
  }
  case ELF::SHT_RELA: {
    const Elf_Rela *ERela = Obj-&gt;getRela(Rel);
    type = ERela-&gt;getType(EF.isMips64EL());
    symbol_index = ERela-&gt;getSymbol(EF.isMips64EL());
    addend = ERela-&gt;r_addend;
    break;
  }
  }
  const Elf_Sym *symb =
      EF.template getEntry&lt;Elf_Sym&gt;(Sec-&gt;sh_link, symbol_index);
  StringRef Target;
  ErrorOr&lt;const Elf_Shdr *&gt; SymSec = EF.getSection(symb);
  if (std::error_code EC = SymSec.getError())
    return EC;
  if (symb-&gt;getType() == ELF::STT_SECTION) {
    ErrorOr&lt;StringRef&gt; SecName = EF.getSectionName(*SymSec);
    if (std::error_code EC = SecName.getError())
      return EC;
    Target = *SecName;
  } else {
    ErrorOr&lt;StringRef&gt; SymName = symb-&gt;getName(StrTab);
    if (!SymName)
      return SymName.getError();
    Target = *SymName;
  }
  switch (EF.getHeader()-&gt;e_machine) {
  case ELF::EM_X86_64:
    switch (type) {
    case ELF::R_X86_64_PC8:
    case ELF::R_X86_64_PC16:
    case ELF::R_X86_64_PC32: {
      std::string fmtbuf;
      raw_string_ostream fmt(fmtbuf);
      fmt &lt;&lt; Target &lt;&lt; (addend &lt; 0 ? &quot;&quot; : &quot;+&quot;) &lt;&lt; addend &lt;&lt; &quot;-P&quot;;
      fmt.flush();
      Result.append(fmtbuf.begin(), fmtbuf.end());
    } break;
    case ELF::R_X86_64_8:
    case ELF::R_X86_64_16:
    case ELF::R_X86_64_32:
    case ELF::R_X86_64_32S:
    case ELF::R_X86_64_64: {
      std::string fmtbuf;
      raw_string_ostream fmt(fmtbuf);
      fmt &lt;&lt; Target &lt;&lt; (addend &lt; 0 ? &quot;&quot; : &quot;+&quot;) &lt;&lt; addend;
      fmt.flush();
      Result.append(fmtbuf.begin(), fmtbuf.end());
    } break;
    default:
      res = &quot;Unknown&quot;;
    }
    break;
  case ELF::EM_AARCH64: {
    std::string fmtbuf;
    raw_string_ostream fmt(fmtbuf);
    fmt &lt;&lt; Target;
    if (addend != 0)
      fmt &lt;&lt; (addend &lt; 0 ? &quot;&quot; : &quot;+&quot;) &lt;&lt; addend;
    fmt.flush();
    Result.append(fmtbuf.begin(), fmtbuf.end());
    break;
  }
  case ELF::EM_386:
  case ELF::EM_ARM:
  case ELF::EM_HEXAGON:
  case ELF::EM_MIPS:
  case ELF::EM_CPU0: // llvm-obj -t -r
    res = Target;
    break;
  default:
    res = &quot;Unknown&quot;;
  }
  if (Result.empty())
    Result.append(res.begin(), res.end());
  return std::error_code();
}

static std::error_code getRelocationValueString(const ELFObjectFileBase *Obj,
                                                const RelocationRef &amp;RelRef,
                                                SmallVectorImpl&lt;char&gt; &amp;Result) {
  DataRefImpl Rel = RelRef.getRawDataRefImpl();
  if (auto *ELF32LE = dyn_cast&lt;ELF32LEObjectFile&gt;(Obj))
    return getRelocationValueString(ELF32LE, Rel, Result);
  if (auto *ELF64LE = dyn_cast&lt;ELF64LEObjectFile&gt;(Obj))
    return getRelocationValueString(ELF64LE, Rel, Result);
  if (auto *ELF32BE = dyn_cast&lt;ELF32BEObjectFile&gt;(Obj))
    return getRelocationValueString(ELF32BE, Rel, Result);
  auto *ELF64BE = cast&lt;ELF64BEObjectFile&gt;(Obj);
  return getRelocationValueString(ELF64BE, Rel, Result);
}

static std::error_code getRelocationValueString(const COFFObjectFile *Obj,
                                                const RelocationRef &amp;Rel,
                                                SmallVectorImpl&lt;char&gt; &amp;Result) {
  symbol_iterator SymI = Rel.getSymbol();
  ErrorOr&lt;StringRef&gt; SymNameOrErr = SymI-&gt;getName();
  if (std::error_code EC = SymNameOrErr.getError())
    return EC;
  StringRef SymName = *SymNameOrErr;
  Result.append(SymName.begin(), SymName.end());
  return std::error_code();
}

static void printRelocationTargetName(const MachOObjectFile *O,
                                      const MachO::any_relocation_info &amp;RE,
                                      raw_string_ostream &amp;fmt) {
  bool IsScattered = O-&gt;isRelocationScattered(RE);

  // Target of a scattered relocation is an address.  In the interest of
  // generating pretty output, scan through the symbol table looking for a
  // symbol that aligns with that address.  If we find one, print it.
  // Otherwise, we just print the hex address of the target.
  if (IsScattered) {
    uint32_t Val = O-&gt;getPlainRelocationSymbolNum(RE);

    for (const SymbolRef &amp;Symbol : O-&gt;symbols()) {
      std::error_code ec;
      ErrorOr&lt;uint64_t&gt; Addr = Symbol.getAddress();
      if ((ec = Addr.getError()))
        report_fatal_error(ec.message());
      if (*Addr != Val)
        continue;
      ErrorOr&lt;StringRef&gt; Name = Symbol.getName();
      if (std::error_code EC = Name.getError())
        report_fatal_error(EC.message());
      fmt &lt;&lt; *Name;
      return;
    }

    // If we couldn&#39;t find a symbol that this relocation refers to, try
    // to find a section beginning instead.
    for (const SectionRef &amp;Section : O-&gt;sections()) {
      std::error_code ec;

      StringRef Name;
      uint64_t Addr = Section.getAddress();
      if (Addr != Val)
        continue;
      if ((ec = Section.getName(Name)))
        report_fatal_error(ec.message());
      fmt &lt;&lt; Name;
      return;
    }

    fmt &lt;&lt; format(&quot;0x%x&quot;, Val);
    return;
  }

  StringRef S;
  bool isExtern = O-&gt;getPlainRelocationExternal(RE);
  uint64_t Val = O-&gt;getPlainRelocationSymbolNum(RE);

  if (isExtern) {
    symbol_iterator SI = O-&gt;symbol_begin();
    advance(SI, Val);
    ErrorOr&lt;StringRef&gt; SOrErr = SI-&gt;getName();
    if (!error(SOrErr.getError()))
      S = *SOrErr;
  } else {
    section_iterator SI = O-&gt;section_begin();
    // Adjust for the fact that sections are 1-indexed.
    advance(SI, Val - 1);
    SI-&gt;getName(S);
  }

  fmt &lt;&lt; S;
}

static std::error_code getRelocationValueString(const MachOObjectFile *Obj,
                                                const RelocationRef &amp;RelRef,
                                                SmallVectorImpl&lt;char&gt; &amp;Result) {
  DataRefImpl Rel = RelRef.getRawDataRefImpl();
  MachO::any_relocation_info RE = Obj-&gt;getRelocation(Rel);

  unsigned Arch = Obj-&gt;getArch();

  std::string fmtbuf;
  raw_string_ostream fmt(fmtbuf);
  unsigned Type = Obj-&gt;getAnyRelocationType(RE);
  bool IsPCRel = Obj-&gt;getAnyRelocationPCRel(RE);

  // Determine any addends that should be displayed with the relocation.
  // These require decoding the relocation type, which is triple-specific.

  // X86_64 has entirely custom relocation types.
  if (Arch == Triple::x86_64) {
    bool isPCRel = Obj-&gt;getAnyRelocationPCRel(RE);

    switch (Type) {
    case MachO::X86_64_RELOC_GOT_LOAD:
    case MachO::X86_64_RELOC_GOT: {
      printRelocationTargetName(Obj, RE, fmt);
      fmt &lt;&lt; &quot;@GOT&quot;;
      if (isPCRel)
        fmt &lt;&lt; &quot;PCREL&quot;;
      break;
    }
    case MachO::X86_64_RELOC_SUBTRACTOR: {
      DataRefImpl RelNext = Rel;
      Obj-&gt;moveRelocationNext(RelNext);
      MachO::any_relocation_info RENext = Obj-&gt;getRelocation(RelNext);

      // X86_64_RELOC_SUBTRACTOR must be followed by a relocation of type
      // X86_64_RELOC_UNSIGNED.
      // NOTE: Scattered relocations don&#39;t exist on x86_64.
      unsigned RType = Obj-&gt;getAnyRelocationType(RENext);
      if (RType != MachO::X86_64_RELOC_UNSIGNED)
        report_fatal_error(&quot;Expected X86_64_RELOC_UNSIGNED after &quot;
                           &quot;X86_64_RELOC_SUBTRACTOR.&quot;);

      // The X86_64_RELOC_UNSIGNED contains the minuend symbol;
      // X86_64_RELOC_SUBTRACTOR contains the subtrahend.
      printRelocationTargetName(Obj, RENext, fmt);
      fmt &lt;&lt; &quot;-&quot;;
      printRelocationTargetName(Obj, RE, fmt);
      break;
    }
    case MachO::X86_64_RELOC_TLV:
      printRelocationTargetName(Obj, RE, fmt);
      fmt &lt;&lt; &quot;@TLV&quot;;
      if (isPCRel)
        fmt &lt;&lt; &quot;P&quot;;
      break;
    case MachO::X86_64_RELOC_SIGNED_1:
      printRelocationTargetName(Obj, RE, fmt);
      fmt &lt;&lt; &quot;-1&quot;;
      break;
    case MachO::X86_64_RELOC_SIGNED_2:
      printRelocationTargetName(Obj, RE, fmt);
      fmt &lt;&lt; &quot;-2&quot;;
      break;
    case MachO::X86_64_RELOC_SIGNED_4:
      printRelocationTargetName(Obj, RE, fmt);
      fmt &lt;&lt; &quot;-4&quot;;
      break;
    default:
      printRelocationTargetName(Obj, RE, fmt);
      break;
    }
    // X86 and ARM share some relocation types in common.
  } else if (Arch == Triple::x86 || Arch == Triple::arm ||
             Arch == Triple::ppc) {
    // Generic relocation types...
    switch (Type) {
    case MachO::GENERIC_RELOC_PAIR: // prints no info
      return std::error_code();
    case MachO::GENERIC_RELOC_SECTDIFF: {
      DataRefImpl RelNext = Rel;
      Obj-&gt;moveRelocationNext(RelNext);
      MachO::any_relocation_info RENext = Obj-&gt;getRelocation(RelNext);

      // X86 sect diff&#39;s must be followed by a relocation of type
      // GENERIC_RELOC_PAIR.
      unsigned RType = Obj-&gt;getAnyRelocationType(RENext);

      if (RType != MachO::GENERIC_RELOC_PAIR)
        report_fatal_error(&quot;Expected GENERIC_RELOC_PAIR after &quot;
                           &quot;GENERIC_RELOC_SECTDIFF.&quot;);

      printRelocationTargetName(Obj, RE, fmt);
      fmt &lt;&lt; &quot;-&quot;;
      printRelocationTargetName(Obj, RENext, fmt);
      break;
    }
    }

    if (Arch == Triple::x86 || Arch == Triple::ppc) {
      switch (Type) {
      case MachO::GENERIC_RELOC_LOCAL_SECTDIFF: {
        DataRefImpl RelNext = Rel;
        Obj-&gt;moveRelocationNext(RelNext);
        MachO::any_relocation_info RENext = Obj-&gt;getRelocation(RelNext);

        // X86 sect diff&#39;s must be followed by a relocation of type
        // GENERIC_RELOC_PAIR.
        unsigned RType = Obj-&gt;getAnyRelocationType(RENext);
        if (RType != MachO::GENERIC_RELOC_PAIR)
          report_fatal_error(&quot;Expected GENERIC_RELOC_PAIR after &quot;
                             &quot;GENERIC_RELOC_LOCAL_SECTDIFF.&quot;);

        printRelocationTargetName(Obj, RE, fmt);
        fmt &lt;&lt; &quot;-&quot;;
        printRelocationTargetName(Obj, RENext, fmt);
        break;
      }
      case MachO::GENERIC_RELOC_TLV: {
        printRelocationTargetName(Obj, RE, fmt);
        fmt &lt;&lt; &quot;@TLV&quot;;
        if (IsPCRel)
          fmt &lt;&lt; &quot;P&quot;;
        break;
      }
      default:
        printRelocationTargetName(Obj, RE, fmt);
      }
    } else { // ARM-specific relocations
      switch (Type) {
      case MachO::ARM_RELOC_HALF:
      case MachO::ARM_RELOC_HALF_SECTDIFF: {
        // Half relocations steal a bit from the length field to encode
        // whether this is an upper16 or a lower16 relocation.
        bool isUpper = Obj-&gt;getAnyRelocationLength(RE) &gt;&gt; 1;

        if (isUpper)
          fmt &lt;&lt; &quot;:upper16:(&quot;;
        else
          fmt &lt;&lt; &quot;:lower16:(&quot;;
        printRelocationTargetName(Obj, RE, fmt);

        DataRefImpl RelNext = Rel;
        Obj-&gt;moveRelocationNext(RelNext);
        MachO::any_relocation_info RENext = Obj-&gt;getRelocation(RelNext);

        // ARM half relocs must be followed by a relocation of type
        // ARM_RELOC_PAIR.
        unsigned RType = Obj-&gt;getAnyRelocationType(RENext);
        if (RType != MachO::ARM_RELOC_PAIR)
          report_fatal_error(&quot;Expected ARM_RELOC_PAIR after &quot;
                             &quot;ARM_RELOC_HALF&quot;);

        // NOTE: The half of the target virtual address is stashed in the
        // address field of the secondary relocation, but we can&#39;t reverse
        // engineer the constant offset from it without decoding the movw/movt
        // instruction to find the other half in its immediate field.

        // ARM_RELOC_HALF_SECTDIFF encodes the second section in the
        // symbol/section pointer of the follow-on relocation.
        if (Type == MachO::ARM_RELOC_HALF_SECTDIFF) {
          fmt &lt;&lt; &quot;-&quot;;
          printRelocationTargetName(Obj, RENext, fmt);
        }

        fmt &lt;&lt; &quot;)&quot;;
        break;
      }
      default: { printRelocationTargetName(Obj, RE, fmt); }
      }
    }
  } else
    printRelocationTargetName(Obj, RE, fmt);

  fmt.flush();
  Result.append(fmtbuf.begin(), fmtbuf.end());
  return std::error_code();
}

static std::error_code getRelocationValueString(const RelocationRef &amp;Rel,
                                                SmallVectorImpl&lt;char&gt; &amp;Result) {
  const ObjectFile *Obj = Rel.getObject();
  if (auto *ELF = dyn_cast&lt;ELFObjectFileBase&gt;(Obj))
    return getRelocationValueString(ELF, Rel, Result);
  if (auto *COFF = dyn_cast&lt;COFFObjectFile&gt;(Obj))
    return getRelocationValueString(COFF, Rel, Result);
  auto *MachO = cast&lt;MachOObjectFile&gt;(Obj);
  return getRelocationValueString(MachO, Rel, Result);
}

/// @brief Indicates whether this relocation should hidden when listing
/// relocations, usually because it is the trailing part of a multipart
/// relocation that will be printed as part of the leading relocation.
static bool getHidden(RelocationRef RelRef) {
  const ObjectFile *Obj = RelRef.getObject();
  auto *MachO = dyn_cast&lt;MachOObjectFile&gt;(Obj);
  if (!MachO)
    return false;

  unsigned Arch = MachO-&gt;getArch();
  DataRefImpl Rel = RelRef.getRawDataRefImpl();
  uint64_t Type = MachO-&gt;getRelocationType(Rel);

  // On arches that use the generic relocations, GENERIC_RELOC_PAIR
  // is always hidden.
  if (Arch == Triple::x86 || Arch == Triple::arm || Arch == Triple::ppc) {
    if (Type == MachO::GENERIC_RELOC_PAIR)
      return true;
  } else if (Arch == Triple::x86_64) {
    // On x86_64, X86_64_RELOC_UNSIGNED is hidden only when it follows
    // an X86_64_RELOC_SUBTRACTOR.
    if (Type == MachO::X86_64_RELOC_UNSIGNED &amp;&amp; Rel.d.a &gt; 0) {
      DataRefImpl RelPrev = Rel;
      RelPrev.d.a--;
      uint64_t PrevType = MachO-&gt;getRelocationType(RelPrev);
      if (PrevType == MachO::X86_64_RELOC_SUBTRACTOR)
        return true;
    }
  }

  return false;
}


static cl::opt&lt;bool&gt;
LittleEndian(&quot;le&quot;, 
cl::desc(&quot;Little endian format&quot;));

#ifdef DLINK
  static cl::opt&lt;bool&gt;
  DumpSo(&quot;cpu0dumpso&quot;, 
  cl::desc(&quot;Dump shared library .so&quot;));
  
  static cl::opt&lt;bool&gt;
  LinkSo(&quot;cpu0linkso&quot;, 
  cl::desc(&quot;Link shared library .so&quot;));
  
  #include &quot;elf2hex-dlinker.h&quot;
#endif

#ifdef ELF2HEX_DEBUG
// Modified from PrintSectionHeaders()
static uint64_t GetSectionHeaderStartAddress(const ObjectFile *Obj, 
  StringRef sectionName) {
//  outs() &lt;&lt; &quot;Sections:\n&quot;
//            &quot;Idx Name          Size      Address          Type\n&quot;;
  std::error_code ec;
  unsigned i = 0;
  for (const SectionRef &amp;Section : Obj-&gt;sections()) {
    if (error(ec)) return 0;
    StringRef Name;
    if (error(Section.getName(Name))) return 0;
    uint64_t Address;
    Address = Section.getAddress();
    uint64_t Size;
    Size = Section.getSize();
    bool Text;
    Text = Section.isText();
    if (Name == sectionName)
      return Address;
    else
      return 0;
    ++i;
  }
  return 0;
}
#endif

// Fill /*address*/ 00 00 00 00 [startAddr..endAddr] from startAddr to endAddr. 
// Include startAddr and endAddr.
static void Fill0s(uint64_t startAddr, uint64_t endAddr) {
  std::size_t addr;

  assert((startAddr &lt;= endAddr) &amp;&amp; &quot;startAddr must &lt;= BaseAddr&quot;);
  // Fill /*address*/ 00 00 00 00 for 4 bytes alignment (1 Cpu0 word size)
  for (addr = startAddr; addr &lt; endAddr; addr += 4) {
    outs() &lt;&lt; format(&quot;/*%8&quot; PRIx64 &quot; */&quot;, addr);
    outs() &lt;&lt; format(&quot;%02&quot; PRIx64 &quot; &quot;, 0) &lt;&lt; format(&quot;%02&quot; PRIx64 &quot; &quot;, 0) \
    &lt;&lt; format(&quot;%02&quot; PRIx64 &quot; &quot;, 0) &lt;&lt; format(&quot;%02&quot; PRIx64 &quot; &quot;, 0) &lt;&lt; &#39;\n&#39;;
  }

  return;
}

static void PrintDataSection(const ObjectFile *o, uint64_t&amp; lastDumpAddr, 
  SectionRef Section) {
  std::string Error;
  StringRef Name;
  StringRef Contents;
  uint64_t BaseAddr;
  bool BSS;
  uint64_t size;
  if (error(Section.getName(Name))) return;
  if (error(Section.getContents(Contents))) return;
  BaseAddr = Section.getAddress();
  BSS = Section.isBSS();

  size = (Contents.size()+3)/4*4;
  if (Contents.size() &lt;= 0) {
    return;
  }

  outs() &lt;&lt; &quot;/*Contents of section &quot; &lt;&lt; Name &lt;&lt; &quot;:*/\n&quot;;
  // Dump out the content as hex and printable ascii characters.
  for (std::size_t addr = 0, end = Contents.size(); addr &lt; end; addr += 16) {
    outs() &lt;&lt; format(&quot;/*%8&quot; PRIx64 &quot; */&quot;, BaseAddr + addr);
    // Dump line of hex.
    for (std::size_t i = 0; i &lt; 16; ++i) {
      if (i != 0 &amp;&amp; i % 4 == 0)
        outs() &lt;&lt; &#39; &#39;;
      if (addr + i &lt; end)
        outs() &lt;&lt; hexdigit((Contents[addr + i] &gt;&gt; 4) &amp; 0xF, true)
               &lt;&lt; hexdigit(Contents[addr + i] &amp; 0xF, true) &lt;&lt; &quot; &quot;;
    }
    // Print ascii.
    outs() &lt;&lt; &quot;/*&quot; &lt;&lt; &quot;  &quot;;
    for (std::size_t i = 0; i &lt; 16 &amp;&amp; addr + i &lt; end; ++i) {
      if (std::isprint(static_cast&lt;unsigned char&gt;(Contents[addr + i]) &amp; 0xFF))
        outs() &lt;&lt; Contents[addr + i];
      else
        outs() &lt;&lt; &quot;.&quot;;
    }
    outs() &lt;&lt; &quot;*/&quot; &lt;&lt; &quot;\n&quot;;
  }
  for (std::size_t i = Contents.size(); i &lt; size; i++) {
    outs() &lt;&lt; &quot;00 &quot;;
  }
  outs() &lt;&lt; &quot;\n&quot;;
#ifdef ELF2HEX_DEBUG
  errs() &lt;&lt; &quot;Name &quot; &lt;&lt; Name &lt;&lt; &quot;  BaseAddr &quot;;
  errs() &lt;&lt; format(&quot;%8&quot; PRIx64 &quot; Contents.size() &quot;, BaseAddr);
  errs() &lt;&lt; format(&quot;%8&quot; PRIx64 &quot; size &quot;, Contents.size());
  errs() &lt;&lt; format(&quot;%8&quot; PRIx64 &quot; \n&quot;, size);
#endif
  // save the end address of this section to lastDumpAddr
  lastDumpAddr = BaseAddr + size;
}

// Modified from DisassembleObject()
static void DisassembleObjectInHexFormat(const ObjectFile *Obj
/*, bool InlineRelocs*/  , std::unique_ptr&lt;MCDisassembler&gt;&amp; DisAsm, 
  std::unique_ptr&lt;MCInstPrinter&gt;&amp; IP, uint64_t&amp; lastDumpAddr,
  std::unique_ptr&lt;const MCSubtargetInfo&gt;&amp; STI) {

#ifdef ELF2HEX_DEBUG
  errs() &lt;&lt; format(&quot;!lastDumpAddr %8&quot; PRIx64 &quot;\n&quot;, lastDumpAddr);
#endif
  std::error_code ec;
  for (const SectionRef &amp;Section : Obj-&gt;sections()) {
    if (error(ec)) break;
    StringRef Name;
    StringRef Contents;
    uint64_t BaseAddr;
    if (error(Section.getName(Name))) continue;
    if (error(Section.getContents(Contents))) continue;
    BaseAddr = Section.getAddress();
    if (BaseAddr &lt; 0x100)
      continue;
  #ifdef ELF2HEX_DEBUG
    errs() &lt;&lt; &quot;Name &quot; &lt;&lt; Name &lt;&lt; format(&quot;  BaseAddr %8&quot; PRIx64 &quot;\n&quot;, BaseAddr);
    errs() &lt;&lt; format(&quot;!!lastDumpAddr %8&quot; PRIx64 &quot;\n&quot;, lastDumpAddr);
  #endif
    bool text;
    text = Section.isText();
    if (!text) {
    #ifdef ELF2HEX_DEBUG
      errs() &lt;&lt; &quot;!text\n&quot;;
    #endif
      if (lastDumpAddr &lt; BaseAddr) {
        Fill0s(lastDumpAddr, BaseAddr - 1);
        lastDumpAddr = BaseAddr;
      }
      if (Name == &quot;.got.plt&quot;) {
        uint64_t BaseAddr;
        BaseAddr = Section.getAddress();
      #ifdef DLINK
        if (LinkSo) {
          raw_fd_ostream fd_global_offset(&quot;dlconfig/global_offset&quot;, ec, 
                                          sys::fs::F_Text);
          fd_global_offset &lt;&lt; format(&quot;%02&quot; PRIx64 &quot; &quot;, BaseAddr &gt;&gt; 24);
          fd_global_offset &lt;&lt; format(&quot;%02&quot; PRIx64 &quot; &quot;, (BaseAddr &gt;&gt; 16) &amp; 0xFF);
          fd_global_offset &lt;&lt; format(&quot;%02&quot; PRIx64 &quot; &quot;, (BaseAddr &gt;&gt; 8) &amp; 0xFF);
          fd_global_offset &lt;&lt; format(&quot;%02&quot; PRIx64 &quot;    &quot;, BaseAddr &amp; 0xFF);
        }
      #endif
        PrintDataSection(Obj, lastDumpAddr, Section);
      }
      else if ((Name == &quot;.bss&quot; || Name == &quot;.sbss&quot;) &amp;&amp; Contents.size() &gt; 0) {
        uint64_t size = (Contents.size() + 3)/4*4;
        Fill0s(BaseAddr, BaseAddr + size - 1);
        lastDumpAddr = BaseAddr + size;
        continue;
      }
      else {
        PrintDataSection(Obj, lastDumpAddr, Section);
      }
      continue;
    }
    else {
      if (lastDumpAddr &lt; BaseAddr) {
        Fill0s(lastDumpAddr, BaseAddr - 1);
        lastDumpAddr = BaseAddr;
      }
    }
    // It&#39;s .text section
    uint64_t SectionAddr;
    SectionAddr = Section.getAddress();
    uint64_t SectSize = Section.getSize();
    if (!SectSize)
      continue;

    // Make a list of all the symbols in this section.
    std::vector&lt;std::pair&lt;uint64_t, StringRef&gt; &gt; Symbols;
    for (const SymbolRef &amp;Symbol : Obj-&gt;symbols()) {
      if (Section.containsSymbol(Symbol)) {
        ErrorOr&lt;uint64_t&gt; AddressOrErr = Symbol.getAddress();
        if (error(AddressOrErr.getError()))
          break;
        uint64_t Address = *AddressOrErr;
        Address -= SectionAddr;
        if (Address &gt;= SectSize)
          continue;

        ErrorOr&lt;StringRef&gt; Name = Symbol.getName();
        if (error(Name.getError()))
          break;
        Symbols.push_back(std::make_pair(Address, *Name));
      }
    }

    // Sort the symbols by address, just in case they didn&#39;t come in that way.
    array_pod_sort(Symbols.begin(), Symbols.end());
  #ifdef ELF2HEX_DEBUG
    for (unsigned si = 0, se = Symbols.size(); si != se; ++si) {
        errs() &lt;&lt; &#39;\n&#39; &lt;&lt; &quot;/*&quot; &lt;&lt; Symbols[si].first &lt;&lt; &quot;  &quot; &lt;&lt; Symbols[si].second &lt;&lt; &quot;:*/\n&quot;;
    }
  #endif

    // Make a list of all the relocations for this section.
    std::vector&lt;RelocationRef&gt; Rels;

    // Sort relocations by address.
    std::sort(Rels.begin(), Rels.end(), RelocAddressLess);

    StringRef SegmentName = &quot;&quot;;
    if (const MachOObjectFile *MachO =
        dyn_cast&lt;const MachOObjectFile&gt;(Obj)) {
      DataRefImpl DR = Section.getRawDataRefImpl();
      SegmentName = MachO-&gt;getSectionFinalSegmentName(DR);
    }
    StringRef name;
    if (error(Section.getName(name))) break;
    outs() &lt;&lt; &quot;/*&quot; &lt;&lt; &quot;Disassembly of section &quot;;
    if (!SegmentName.empty())
      outs() &lt;&lt; SegmentName &lt;&lt; &quot;,&quot;;
    outs() &lt;&lt; name &lt;&lt; &#39;:&#39; &lt;&lt; &quot;*/&quot;;

    // If the section has no symbols just insert a dummy one and disassemble
    // the whole section.
    if (Symbols.empty())
      Symbols.push_back(std::make_pair(0, name));

    SmallString&lt;40&gt; Comments;
    raw_svector_ostream CommentStream(Comments);

    StringRef BytesStr;
    if (error(Section.getContents(BytesStr))) break;
    ArrayRef&lt;uint8_t&gt; Bytes(reinterpret_cast&lt;const uint8_t *&gt;(BytesStr.data()),
                            BytesStr.size());
    uint64_t Size;
    uint64_t Index;
    SectSize = Section.getSize();

    std::vector&lt;RelocationRef&gt;::const_iterator rel_cur = Rels.begin();
    std::vector&lt;RelocationRef&gt;::const_iterator rel_end = Rels.end();
    // Disassemble symbol by symbol.
    for (unsigned si = 0, se = Symbols.size(); si != se; ++si) {
      uint64_t Start = Symbols[si].first;
      uint64_t End;
      // The end is either the size of the section or the beginning of the next
      // symbol.
      if (si == se - 1)
        End = SectSize;
      // Make sure this symbol takes up space.
      else if (Symbols[si + 1].first != Start)
        End = Symbols[si + 1].first - 1;
      else {
        outs() &lt;&lt; &#39;\n&#39; &lt;&lt; &quot;/*&quot; &lt;&lt; Symbols[si].second &lt;&lt; &quot;:*/\n&quot;;
        continue;
      }

      outs() &lt;&lt; &#39;\n&#39; &lt;&lt; &quot;/*&quot; &lt;&lt; Symbols[si].second &lt;&lt; &quot;:*/\n&quot;;
    #ifdef DLINK
      uint16_t funIndex = 0;
      if (LinkSo) {
      // correctDynFunIndex
        funIndex = cpu0DynFunIndex.correctDynFunIndex(Symbols[si].second.data());
      }
    #endif

#ifndef NDEBUG
        raw_ostream &amp;DebugOut = DebugFlag ? dbgs() : nulls();
#else
        raw_ostream &amp;DebugOut = nulls();
#endif

      for (Index = Start; Index &lt; End; Index += Size) {
        MCInst Inst;

    #ifdef DLINK
  #ifdef ELF2HEX_DEBUG
    errs() &lt;&lt; &quot;funIndex: &quot; &lt;&lt; funIndex &lt;&lt; &quot;Index: &quot; &lt;&lt; Index &lt;&lt; &quot;Size: &quot; &lt;&lt; Size &lt;&lt; &quot;\n&quot;;
  #endif
        if (LinkSo &amp;&amp; funIndex &amp;&amp; Index == Start) {
          outs() &lt;&lt; format(&quot;/*%8&quot; PRIx64 &quot;:*/\t&quot;, SectionAddr + Index);
          outs() &lt;&lt; &quot;01 6b &quot; &lt;&lt; format(&quot;%02&quot; PRIx64, (funIndex*4+16) &amp; 0xff00)
                  &lt;&lt; format(&quot; %02&quot; PRIx64, (funIndex*4+16) &amp; 0x00ff);
          outs() &lt;&lt; &quot;                                  /* ld\t$t9, &quot; 
                 &lt;&lt; funIndex*4+16 &lt;&lt; &quot;($gp)\n&quot;;
        }
        else
    #endif
       {
          if (DisAsm-&gt;getInstruction(Inst, Size, Bytes.slice(Index),
                                     SectionAddr + Index, DebugOut,
                                     CommentStream)) {
            outs() &lt;&lt; format(&quot;/*%8&quot; PRIx64 &quot;:*/&quot;, SectionAddr + Index);
            if (!NoShowRawInsn) {
              outs() &lt;&lt; &quot;\t&quot;;
              dumpBytes(Bytes.slice(Index, Size), outs());
            }
            outs() &lt;&lt; &quot;/*&quot;;
            IP-&gt;printInst(&amp;Inst, outs(), &quot;&quot;, *STI);
            outs() &lt;&lt; CommentStream.str();
            outs() &lt;&lt; &quot;*/&quot;;
            Comments.clear();
            outs() &lt;&lt; &quot;\n&quot;;
          } else {
            errs() &lt;&lt; ToolName &lt;&lt; &quot;: warning: invalid instruction encoding\n&quot;;
            if (Size == 0)
              Size = 1; // skip illegible bytes
          }
        }

        //  outs() &lt;&lt; &quot;Size = &quot; &lt;&lt; Size &lt;&lt;  &quot;Index = &quot; &lt;&lt; Index &lt;&lt; &quot;lastDumpAddr = &quot;
        //         &lt;&lt; lastDumpAddr &lt;&lt; &quot;\n&quot;; // debug
        // Print relocation for instruction.
        while (rel_cur != rel_end) {
          bool hidden = getHidden(*rel_cur);
          uint64_t addr = rel_cur-&gt;getOffset();
          SmallString&lt;16&gt; name;
          SmallString&lt;32&gt; val;

          // If this relocation is hidden, skip it.
          if (hidden) goto skip_print_rel;

          // Stop when rel_cur&#39;s address is past the current instruction.
          if (addr &gt;= Index + Size) break;
          rel_cur-&gt;getTypeName(name);
          if (error(getRelocationValueString(*rel_cur, val)))
            goto skip_print_rel;

          outs() &lt;&lt; format(&quot;\t\t\t/*%8&quot; PRIx64 &quot;: &quot;, SectionAddr + addr) &lt;&lt; name
                 &lt;&lt; &quot;\t&quot; &lt;&lt; val &lt;&lt; &quot;*/\n&quot;;

        skip_print_rel:
          ++rel_cur;
        }
      }
    #ifdef ELF2HEX_DEBUG
      errs() &lt;&lt; format(&quot;SectionAddr + Index = %8&quot; PRIx64 &quot;\n&quot;, SectionAddr + Index);
      errs() &lt;&lt; format(&quot;lastDumpAddr %8&quot; PRIx64 &quot;\n&quot;, lastDumpAddr);
    #endif
    }
    // In section .plt or .text, the Contents.size() maybe &lt; (SectionAddr + Index)
    if (Contents.size() &lt; (SectionAddr + Index))
      lastDumpAddr = SectionAddr + Index;
    else
      lastDumpAddr = SectionAddr + Contents.size();
  }
}

static uint64_t SectionOffset(const ObjectFile *o, StringRef secName) {
  std::error_code ec;

  for (const SectionRef &amp;Section : o-&gt;sections()) {
    if (error(ec)) return 0;
    StringRef Name;
    StringRef Contents;
    uint64_t BaseAddr;
    bool BSS;
    if (error(Section.getName(Name))) return 0;
    if (error(Section.getContents(Contents))) return 0;
    BaseAddr = Section.getAddress();
    BSS = Section.isBSS();

    if (Name == secName)
      return BaseAddr;
  }
  return 0;
}

static void PrintBootSection(uint64_t pltOffset, bool isLittleEndian) {
  uint64_t offset = pltOffset - 4;
  if (isLittleEndian) {
    outs() &lt;&lt; &quot;/*       0:*/	&quot;;
    outs() &lt;&lt; format(&quot;%02&quot; PRIx64 &quot; &quot;, (offset &amp; 0xff));
    outs() &lt;&lt; format(&quot;%02&quot; PRIx64 &quot;&quot;, (offset &amp; 0xff00) &gt;&gt; 8);
    outs() &lt;&lt; &quot; 00 36&quot;;
    outs() &lt;&lt; &quot;                                  /*	jmp	0x&quot;;
    outs() &lt;&lt; format(&quot;%02&quot; PRIx64 &quot;%02&quot; PRIx64 &quot; */\n&quot;, (offset &amp; 0xff00) &gt;&gt; 8, 
                     (offset &amp; 0xff)); 
    outs() &lt;&lt;
      &quot;/*       4:*/	04 00 00 36                                  /*	jmp	4 */\n&quot;;
    outs() &lt;&lt; &quot;/*       8:*/	&quot;;
    outs() &lt;&lt; format(&quot;%02&quot; PRIx64 &quot; &quot;, (offset &amp; 0xff));
    outs() &lt;&lt; format(&quot;%02&quot; PRIx64 &quot;&quot;, (offset &amp; 0xff00) &gt;&gt; 8);
    outs() &lt;&lt; &quot; 00 36&quot;;
    outs() &lt;&lt; &quot;                                  /*	jmp	0x&quot;;
    outs() &lt;&lt; format(&quot;%02&quot; PRIx64 &quot;%02&quot; PRIx64 &quot; */\n&quot;, (offset &amp; 0xff00) &gt;&gt; 8, 
                     (offset &amp; 0xff)); 
    outs() &lt;&lt;
      &quot;/*       c:*/	fc ff ff 36                                  /*	jmp	-4 */\n&quot;;
  }
  else {
    outs() &lt;&lt; &quot;/*       0:*/	36 00 &quot;;
    outs() &lt;&lt; format(&quot;%02&quot; PRIx64 &quot; &quot;, (offset &amp; 0xff00) &gt;&gt; 8);
    outs() &lt;&lt; format(&quot;%02&quot; PRIx64 &quot;&quot;, (offset &amp; 0xff));
    outs() &lt;&lt; &quot;                                  /*	jmp	0x&quot;;
    outs() &lt;&lt; format(&quot;%02&quot; PRIx64 &quot;%02&quot; PRIx64 &quot; */\n&quot;, (offset &amp; 0xff00) &gt;&gt; 8, 
                     (offset &amp; 0xff)); 
    outs() &lt;&lt;
      &quot;/*       4:*/	36 00 00 04                                  /*	jmp	4 */\n&quot;;
    outs() &lt;&lt; &quot;/*       8:*/	36 00 &quot;;
    outs() &lt;&lt; format(&quot;%02&quot; PRIx64 &quot; &quot;, (offset &amp; 0xff00) &gt;&gt; 8);
    outs() &lt;&lt; format(&quot;%02&quot; PRIx64 &quot;&quot;, (offset &amp; 0xff));
    outs() &lt;&lt; &quot;                                  /*	jmp	0x&quot;;
    outs() &lt;&lt; format(&quot;%02&quot; PRIx64 &quot;%02&quot; PRIx64 &quot; */\n&quot;, (offset &amp; 0xff00) &gt;&gt; 8, 
                     (offset &amp; 0xff)); 
    outs() &lt;&lt;
      &quot;/*       c:*/	36 ff ff fc                                  /*	jmp	-4 */\n&quot;;
  }
}

#if 0
// Create by ref PrintSymbolTable()
static void FillJTI(const ObjectFile *o) {
  for (const SymbolRef &amp;Symbol : o-&gt;symbols()) {
    StringRef JTIBlockName;
    uint64_t BBAddr[0x10000];
    StringRef Name;
    uint64_t Address;
    SymbolRef::Type Type;
    uint64_t Size;
    uint32_t Flags = Symbol.getFlags();
    section_iterator Section = o-&gt;section_end();
    if (error(Section-&gt;getName(SectionName)))
      SectionName = &quot;&quot;;
    if (SectionName != &quot;.rodata&quot;) continue;
    if (error(Symbol.getName(Name)))
      continue;
  // For example: Name=JTI8_0 =&gt; JTIBlockName=BB8 (rule hit until _)
    if (strncmp(Name.c_str(), &quot;JTI&quot;, strlen(&quot;JTI&quot;) == 0) {
      int i = 0;
      for (i = strlen(&quot;JTI&quot;); Name[i] != &#39;_&#39;; i++);
      if (i &gt; strlen(&quot;JTI&quot;)) 
        JTIBlockName = &quot;BB&quot; + Name.substr(strlen(&quot;JTI&quot;), i-strlen(&quot;JTI&quot;));
    }
  // Then get all BB8_* address.
    Address = Section.getAddress();
    if (error(Symbol.getSection(Section)))
      continue;
    if (Section != &quot;.text&quot;)
      continue;
}
#endif

static void Elf2Hex(const ObjectFile *o) {
  uint64_t lastDumpAddr = 0;

  const Target *TheTarget = getTarget(o);
  // getTarget() will have already issued a diagnostic if necessary, so
  // just bail here if it failed.
  if (!TheTarget)
    return;

  // Package up features to be passed to target/subtarget
  std::string FeaturesStr;
  if (MAttrs.size()) {
    SubtargetFeatures Features;
    for (unsigned i = 0; i != MAttrs.size(); ++i)
      Features.AddFeature(MAttrs[i]);
    FeaturesStr = Features.getString();
  }

  std::unique_ptr&lt;const MCRegisterInfo&gt; MRI(TheTarget-&gt;createMCRegInfo(TripleName));
  if (!MRI) {
    errs() &lt;&lt; &quot;error: no register info for target &quot; &lt;&lt; TripleName &lt;&lt; &quot;\n&quot;;
    return;
  }

  // Set up disassembler.
  std::unique_ptr&lt;const MCAsmInfo&gt; AsmInfo(
    TheTarget-&gt;createMCAsmInfo(*MRI, TripleName));
  if (!AsmInfo) {
    errs() &lt;&lt; &quot;error: no assembly info for target &quot; &lt;&lt; TripleName &lt;&lt; &quot;\n&quot;;
    return;
  }

  std::unique_ptr&lt;const MCSubtargetInfo&gt; STI(
    TheTarget-&gt;createMCSubtargetInfo(TripleName, &quot;&quot;, FeaturesStr));
  if (!STI) {
    errs() &lt;&lt; &quot;error: no subtarget info for target &quot; &lt;&lt; TripleName &lt;&lt; &quot;\n&quot;;
    return;
  }

  std::unique_ptr&lt;const MCInstrInfo&gt; MII(TheTarget-&gt;createMCInstrInfo());
  if (!MII) {
    errs() &lt;&lt; &quot;error: no instruction info for target &quot; &lt;&lt; TripleName &lt;&lt; &quot;\n&quot;;
    return;
  }

  std::unique_ptr&lt;const MCObjectFileInfo&gt; MOFI(new MCObjectFileInfo);
  MCContext Ctx(AsmInfo.get(), MRI.get(), MOFI.get());

  std::unique_ptr&lt;MCDisassembler&gt; DisAsm(
    TheTarget-&gt;createMCDisassembler(*STI, Ctx));
  if (!DisAsm) {
    errs() &lt;&lt; &quot;error: no disassembler for target &quot; &lt;&lt; TripleName &lt;&lt; &quot;\n&quot;;
    return;
  }

  std::unique_ptr&lt;const MCInstrAnalysis&gt; MIA(
      TheTarget-&gt;createMCInstrAnalysis(MII.get()));

  int AsmPrinterVariant = AsmInfo-&gt;getAssemblerDialect();
  std::unique_ptr&lt;MCInstPrinter&gt; IP(TheTarget-&gt;createMCInstPrinter(
      Triple(TripleName), AsmPrinterVariant, *AsmInfo, *MII, *MRI));
  if (!IP) {
    errs() &lt;&lt; &quot;error: no instruction printer for target &quot; &lt;&lt; TripleName
      &lt;&lt; &#39;\n&#39;;
    return;
  }

#ifdef ELF2HEX_DEBUG
  uint64_t startAddr = GetSectionHeaderStartAddress(o, &quot;_start&quot;);
  errs() &lt;&lt; format(&quot;_start address:%08&quot; PRIx64 &quot;\n&quot;, startAddr);
#endif
#ifdef DLINK
  if (DumpSo) {
    DisassembleSoInHexFormat(o, DisAsm, IP, lastDumpAddr, STI);
    PrintSoDataSections(o, lastDumpAddr, LittleEndian);
  }
  else
#endif
  {
    std::error_code EC;
    uint64_t pltOffset = SectionOffset(o, &quot;.plt&quot;);
    PrintBootSection(pltOffset, LittleEndian);
  #ifdef DLINK
    if (LinkSo) {
      cpu0DynFunIndex.createPltName(o);
      cpu0DynFunIndex.createStrtab();
      raw_fd_ostream fd_plt_offset(&quot;dlconfig/plt_offset&quot;, EC, 
                                    sys::fs::F_Text);
      fd_plt_offset &lt;&lt; format(&quot;%08&quot; PRIx64 &quot; &quot;, pltOffset);
    }
  #endif
    lastDumpAddr = BOOT_SIZE;
    Fill0s(lastDumpAddr, 0x100);
    lastDumpAddr = 0x100;
    DisassembleObjectInHexFormat(o, DisAsm, IP, lastDumpAddr, STI);
  }
}

static void DumpObject(const ObjectFile *o) {
  outs() &lt;&lt; &quot;/*&quot;;
  outs() &lt;&lt; o-&gt;getFileName()
         &lt;&lt; &quot;:\tfile format &quot; &lt;&lt; o-&gt;getFileFormatName() &lt;&lt; &quot;*/&quot;;
  outs() &lt;&lt; &quot;\n\n&quot;;

  Elf2Hex(o);
}

/// @brief Open file and figure out how to dump it.
static void DumpInput(StringRef file) {
  // If file isn&#39;t stdin, check that it exists.
  if (file != &quot;-&quot; &amp;&amp; !sys::fs::exists(file)) {
    report_error(file, errc::no_such_file_or_directory);
    return;
  }

  // Attempt to open the binary.
  ErrorOr&lt;OwningBinary&lt;Binary&gt;&gt; BinaryOrErr = createBinary(file);
  if (std::error_code EC = BinaryOrErr.getError()) {
    report_error(file, EC);
    return;
  }
  Binary &amp;Binary = *BinaryOrErr.get().getBinary();

  if (ObjectFile *o = dyn_cast&lt;ObjectFile&gt;(&amp;Binary))
    DumpObject(o);
  else
    report_error(file, object_error::invalid_file_type);
}

int main(int argc, char **argv) {
  // Print a stack trace if we signal out.
  sys::PrintStackTraceOnErrorSignal();
  PrettyStackTraceProgram X(argc, argv);
  llvm_shutdown_obj Y;  // Call llvm_shutdown() on exit.

  // Initialize targets and assembly printers/parsers.
  llvm::InitializeAllTargetInfos();
  llvm::InitializeAllTargetMCs();
  llvm::InitializeAllAsmParsers();
  llvm::InitializeAllDisassemblers();

  // Register the target printer for --version.
  cl::AddExtraVersionPrinter(TargetRegistry::printRegisteredTargetsForVersion);

  cl::ParseCommandLineOptions(argc, argv, &quot;llvm object file dumper\n&quot;);
  TripleName = Triple::normalize(TripleName);

  ToolName = argv[0];

  // Defaults to a.out if no filenames specified.
  if (InputFilenames.size() == 0)
    InputFilenames.push_back(&quot;a.out&quot;);

  std::for_each(InputFilenames.begin(), InputFilenames.end(),
                DumpInput);

  return ReturnValue;
}

</pre></div>
</div>
<p>The code included in &#8220;#ifdef DLINK&#8221; are for dynamic linker support.
The elf2hex.h supports both endian dump.</p>
</div>
<div class="section" id="create-cpu0-backend-under-lld">
<h2><a class="toc-backref" href="#id34">Create Cpu0 backend under LLD</a><a class="headerlink" href="#create-cpu0-backend-under-lld" title="Permalink to this headline">¶</a></h2>
<div class="section" id="setup-cpu0-backend-under-lld">
<h3><a class="toc-backref" href="#id35">Setup Cpu0 backend under lld</a><a class="headerlink" href="#setup-cpu0-backend-under-lld" title="Permalink to this headline">¶</a></h3>
<p>LLD project is underdevelopment and can be compiled only with c++11 standard
(C++2011 year announced standard).
For iMac, our software is OS X version 10.9.1 and Xcode version 5.0.2.
For old iMac software version, you can install VM (such as Virtual Box) and
build lld as Linux platform. Please download lld from llvm web
<a class="footnote-reference" href="#llvm-download" id="id3">[3]</a> and put lld
souce code on {llvm-src}/tools/lld just like we download llvm and clang as
shown in Appendex A of book &#8220;Tutorial: Creating an LLVM Backend for the Cpu0
Architecture&#8221; as follows.</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">1-160-136-173:tools Jonathan$</span> <span class="nb">pwd</span>
<span class="go">/Users/Jonathan/llvm/test/src/tools</span>
<span class="gp">1-160-136-173:tools Jonathan$</span> ls
<span class="go">...</span>
<span class="go">lld              llvm-config      llvm-extract    llvm-nm           llvm-stress   obj2yaml</span>
</pre></div>
</div>
<p>Next, setup Cpu0 backend as follows,</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">1-160-136-173:lld Jonathan$</span> <span class="nb">pwd</span>
<span class="go">/Users/Jonathan/llvm/test/src/tools/lld</span>
<span class="gp">1-160-136-173:lld Jonathan$</span> cp -rf ~/test/lbt/exlbt/lld/* .
</pre></div>
</div>
<p>Now, build lld with Cpu0 backend as follows,</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">1-160-136-173:cmake_debug_build Jonathan$</span> cmake -DCMAKE_CXX_COMPILER<span class="o">=</span>clang++ -
<span class="go">DCMAKE_C_COMPILER=clang -DCMAKE_CXX_FLAGS=-std=c++11 -DCMAKE_BUILD_TYPE=Debug</span>
<span class="go">-G &quot;Xcode&quot; ../src</span>
<span class="go">...</span>
<span class="go">-- Targeting Cpu0</span>
<span class="go">...</span>
<span class="go">-- Configuring done</span>
<span class="go">-- Generating done</span>
<span class="go">-- Build files have been written to: /Users/Jonathan/llvm/test/cmake_debug_build</span>
</pre></div>
</div>
<p>If using VM (guest machine is Linux) or Linux, build as follows,</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">[Gamma@localhost cmake_debug_build]$</span> cmake -DCMAKE_CXX_COMPILER<span class="o">=</span>g++ -
<span class="go">DCMAKE_C_COMPILER=gcc -DCMAKE_CXX_FLAGS=-std=c++11 -DCMAKE_BUILD_TYPE=Debug</span>
<span class="go">-G &quot;Unix Makefiles&quot; ../src</span>
<span class="go">...</span>
<span class="go">-- Targeting Cpu0</span>
<span class="go">...</span>
<span class="go">-- Configuring done</span>
<span class="go">-- Generating done</span>
<span class="go">-- Build files have been written to: /home/cschen/llvm/test/cmake_debug_build</span>
</pre></div>
</div>
</div>
<div class="section" id="cpu0-backend-souce-code">
<h3><a class="toc-backref" href="#id36">Cpu0 backend souce code</a><a class="headerlink" href="#cpu0-backend-souce-code" title="Permalink to this headline">¶</a></h3>
<p>The code added on lld to support Cpu0 ELF as follows,</p>
<p class="rubric">exlbt/lld/include/Core/Reference.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// Which architecture the kind value is for.</span>
<span class="k">enum</span> <span class="k">class</span> <span class="nc">KindArch</span> <span class="p">{</span> <span class="p">...,</span> <span class="n">Cpu0</span> <span class="p">};</span>
</pre></div>
</div>
<p class="rubric">exlbt/lld/include/ReaderWriter/Reference.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ELFLinkingContext</span><span class="o">&gt;</span> <span class="n">createCpu0LinkingContext</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">Triple</span><span class="p">);</span>
</pre></div>
</div>
<p class="rubric">exlbt/lld/lib/Driver/CMakeLists.txt</p>
<div class="highlight-cmake"><div class="highlight"><pre><span></span><span class="nb">add_llvm_library</span><span class="p">(</span><span class="s">lldDriver</span>
    <span class="s">...</span>
    <span class="s">lldCpu0ELFTarget</span>
  <span class="p">)</span>
</pre></div>
</div>
<p class="rubric">exlbt/lld/lib/Driver/GnuLdDriver.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ELFLinkingContext</span><span class="o">&gt;</span>
<span class="n">GnuLdDriver</span><span class="o">::</span><span class="n">createELFLinkingContext</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">Triple</span> <span class="n">triple</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">p</span> <span class="o">=</span> <span class="n">elf</span><span class="o">::</span><span class="n">createCpu0LinkingContext</span><span class="p">(</span><span class="n">triple</span><span class="p">)))</span> <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">exlbt/lld/lib/ReaderWriter/ELF/CMakeLists.txt</p>
<div class="highlight-cmake"><div class="highlight"><pre><span></span><span class="nb">add_subdirectory</span><span class="p">(</span><span class="s">Cpu0</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">exlbt/lld/lib/ReaderWriter/ELF/Atoms.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SimpleELFDefinedAtom</span> <span class="o">:</span> <span class="k">public</span> <span class="n">SimpleDefinedAtom</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="kt">void</span> <span class="n">addReferenceELF_Cpu0</span><span class="p">(</span><span class="n">Reference</span><span class="o">::</span><span class="n">KindValue</span> <span class="n">relocType</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">off</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">Atom</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="n">Reference</span><span class="o">::</span><span class="n">Addend</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">addReferenceELF</span><span class="p">(</span><span class="n">Reference</span><span class="o">::</span><span class="n">KindArch</span><span class="o">::</span><span class="n">Cpu0</span><span class="p">,</span> <span class="n">relocType</span><span class="p">,</span> <span class="n">off</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">exlbt/lld/ELFFile.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ELFT</span><span class="o">&gt;</span> <span class="n">Reference</span><span class="o">::</span><span class="n">KindArch</span> <span class="n">ELFFile</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;::</span><span class="n">kindArch</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">_objFile</span><span class="o">-&gt;</span><span class="n">getHeader</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">e_machine</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="k">case</span> <span class="n">llvm</span><span class="o">::</span><span class="n">ELF</span><span class="o">::</span><span class="nl">EM_CPU0</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">Reference</span><span class="o">::</span><span class="n">KindArch</span><span class="o">::</span><span class="n">Cpu0</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">llvm</span><span class="o">::</span><span class="n">ELF</span><span class="o">::</span><span class="nl">EM_CPU0_LE</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">Reference</span><span class="o">::</span><span class="n">KindArch</span><span class="o">::</span><span class="n">Cpu0el</span><span class="p">;</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">exlbt/lld/ELFLinkingContext.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">uint16_t</span> <span class="n">ELFLinkingContext</span><span class="o">::</span><span class="n">getOutputMachine</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">getTriple</span><span class="p">().</span><span class="n">getArch</span><span class="p">())</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="k">case</span> <span class="n">llvm</span><span class="o">::</span><span class="n">Triple</span><span class="o">::</span><span class="nl">cpu0</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">llvm</span><span class="o">::</span><span class="n">ELF</span><span class="o">::</span><span class="n">EM_CPU0</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">llvm</span><span class="o">::</span><span class="n">Triple</span><span class="o">::</span><span class="nl">cpu0el</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">llvm</span><span class="o">::</span><span class="n">ELF</span><span class="o">::</span><span class="n">EM_CPU0_LE</span><span class="p">;</span>
  <span class="p">...</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="p">...</span>
</pre></div>
</div>
<p class="rubric">exlbt/lld/lib/ReaderWriter/ELF/ELFFile.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ELFLinkingContext</span><span class="o">&gt;</span>
<span class="n">ELFLinkingContext</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">Triple</span> <span class="n">triple</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">triple</span><span class="p">.</span><span class="n">getArch</span><span class="p">())</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="k">case</span> <span class="n">llvm</span><span class="o">::</span><span class="n">ELF</span><span class="o">::</span><span class="nl">EM_CPU0</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">Reference</span><span class="o">::</span><span class="n">KindArch</span><span class="o">::</span><span class="n">Cpu0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">exlbt/lld/lib/ReaderWriter/ELF/Cpu0/CMakeLists.txt</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">add_llvm_library</span><span class="p">(</span><span class="n">lldCpu0ELFTarget</span>
  <span class="n">Cpu0ExecutableWriter</span><span class="o">.</span><span class="n">cpp</span>
  <span class="n">Cpu0LinkingContext</span><span class="o">.</span><span class="n">cpp</span>
  <span class="n">Cpu0TargetHandler</span><span class="o">.</span><span class="n">cpp</span>
  <span class="n">Cpu0RelocationHandler</span><span class="o">.</span><span class="n">cpp</span>
  <span class="n">Cpu0RelocationPass</span><span class="o">.</span><span class="n">cpp</span>
  <span class="n">Cpu0SectionChunks</span><span class="o">.</span><span class="n">cpp</span>
  <span class="n">LINK_LIBS</span>
    <span class="n">lldELF</span>
    <span class="n">lldReaderWriter</span>
    <span class="n">lldCore</span>
    <span class="n">LLVMObject</span>
    <span class="n">LLVMSupport</span>
  <span class="p">)</span>

<span class="n">include_directories</span><span class="p">(</span><span class="o">.</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">exlbt/lld/lib/ReaderWriter/ELF/Cpu0/Cpu0DynamicLibraryWriter.h</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//===-</span> <span class="n">lib</span><span class="o">/</span><span class="n">ReaderWriter</span><span class="o">/</span><span class="n">ELF</span><span class="o">/</span><span class="n">Cpu0</span><span class="o">/</span><span class="n">Cpu0DynamicLibraryWriter</span><span class="o">.</span><span class="n">h</span> <span class="o">---------------===//</span>
<span class="o">//</span>
<span class="o">//</span>                             <span class="n">The</span> <span class="n">LLVM</span> <span class="n">Linker</span>
<span class="o">//</span>
<span class="o">//</span> <span class="n">This</span> <span class="n">file</span> <span class="ow">is</span> <span class="n">distributed</span> <span class="n">under</span> <span class="n">the</span> <span class="n">University</span> <span class="n">of</span> <span class="n">Illinois</span> <span class="n">Open</span> <span class="n">Source</span>
<span class="o">//</span> <span class="n">License</span><span class="o">.</span> <span class="n">See</span> <span class="n">LICENSE</span><span class="o">.</span><span class="n">TXT</span> <span class="k">for</span> <span class="n">details</span><span class="o">.</span>
<span class="o">//</span>
<span class="o">//===----------------------------------------------------------------------===//</span>
<span class="c1">#ifndef CPU0_DYNAMIC_LIBRARY_WRITER_H</span>
<span class="c1">#define CPU0_DYNAMIC_LIBRARY_WRITER_H</span>

<span class="c1">#include &quot;DynamicLibraryWriter.h&quot;</span>
<span class="c1">#include &quot;Cpu0LinkingContext.h&quot;</span>
<span class="c1">#include &quot;Cpu0TargetHandler.h&quot;</span>

<span class="n">namespace</span> <span class="n">lld</span> <span class="p">{</span>
<span class="n">namespace</span> <span class="n">elf</span> <span class="p">{</span>

<span class="n">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ELFT</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Cpu0DynamicLibraryWriter</span> <span class="p">:</span> <span class="n">public</span> <span class="n">DynamicLibraryWriter</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
  <span class="n">Cpu0DynamicLibraryWriter</span><span class="p">(</span><span class="n">Cpu0LinkingContext</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="p">,</span>
                             <span class="n">Cpu0TargetLayout</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">layout</span><span class="p">);</span>

<span class="n">protected</span><span class="p">:</span>
  <span class="o">//</span> <span class="n">Add</span> <span class="nb">any</span> <span class="n">runtime</span> <span class="n">files</span> <span class="ow">and</span> <span class="n">their</span> <span class="n">atoms</span> <span class="n">to</span> <span class="n">the</span> <span class="n">output</span>
  <span class="n">void</span> <span class="n">createImplicitFiles</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="p">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">File</span><span class="o">&gt;&gt;</span> <span class="o">&amp;</span><span class="p">)</span> <span class="n">override</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">}</span> <span class="o">//</span> <span class="n">namespace</span> <span class="n">elf</span>
<span class="p">}</span> <span class="o">//</span> <span class="n">namespace</span> <span class="n">lld</span>

<span class="n">using</span> <span class="n">namespace</span> <span class="n">lld</span><span class="p">::</span><span class="n">elf</span><span class="p">;</span>

<span class="n">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ELFT</span><span class="o">&gt;</span> <span class="n">Cpu0DynamicLibraryWriter</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;</span><span class="p">::</span><span class="n">Cpu0DynamicLibraryWriter</span><span class="p">(</span>
    <span class="n">Cpu0LinkingContext</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="p">,</span> <span class="n">Cpu0TargetLayout</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">layout</span><span class="p">)</span>
    <span class="p">:</span> <span class="n">DynamicLibraryWriter</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">layout</span><span class="p">)</span> <span class="p">{}</span>

<span class="n">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ELFT</span><span class="o">&gt;</span> <span class="n">void</span> <span class="n">Cpu0DynamicLibraryWriter</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;</span><span class="p">::</span><span class="n">createImplicitFiles</span><span class="p">(</span>
    <span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="p">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">File</span><span class="o">&gt;&gt;</span> <span class="o">&amp;</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">DynamicLibraryWriter</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;</span><span class="p">::</span><span class="n">createImplicitFiles</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
  <span class="n">auto</span> <span class="n">gotFile</span> <span class="o">=</span> <span class="n">llvm</span><span class="p">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">SimpleFile</span><span class="o">&gt;</span><span class="p">(</span><span class="s2">&quot;GOTFile&quot;</span><span class="p">);</span>
  <span class="n">gotFile</span><span class="o">-&gt;</span><span class="n">addAtom</span><span class="p">(</span><span class="o">*</span><span class="n">new</span> <span class="p">(</span><span class="n">gotFile</span><span class="o">-&gt;</span><span class="n">allocator</span><span class="p">())</span> <span class="n">GlobalOffsetTableAtom</span><span class="p">(</span><span class="o">*</span><span class="n">gotFile</span><span class="p">));</span>
  <span class="n">gotFile</span><span class="o">-&gt;</span><span class="n">addAtom</span><span class="p">(</span><span class="o">*</span><span class="n">new</span> <span class="p">(</span><span class="n">gotFile</span><span class="o">-&gt;</span><span class="n">allocator</span><span class="p">())</span> <span class="n">DynamicAtom</span><span class="p">(</span><span class="o">*</span><span class="n">gotFile</span><span class="p">));</span>
  <span class="n">result</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">move</span><span class="p">(</span><span class="n">gotFile</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">#endif</span>
</pre></div>
</div>
<p class="rubric">exlbt/lld/lib/ReaderWriter/ELF/Cpu0/Cpu0ExecutableWriter.h</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//===-</span> <span class="n">lib</span><span class="o">/</span><span class="n">ReaderWriter</span><span class="o">/</span><span class="n">ELF</span><span class="o">/</span><span class="n">Cpu0</span><span class="o">/</span><span class="n">Cpu0ExecutableWriter</span><span class="o">.</span><span class="n">h</span> <span class="o">------------------===//</span>
<span class="o">//</span>
<span class="o">//</span>                             <span class="n">The</span> <span class="n">LLVM</span> <span class="n">Linker</span>
<span class="o">//</span>
<span class="o">//</span> <span class="n">This</span> <span class="n">file</span> <span class="ow">is</span> <span class="n">distributed</span> <span class="n">under</span> <span class="n">the</span> <span class="n">University</span> <span class="n">of</span> <span class="n">Illinois</span> <span class="n">Open</span> <span class="n">Source</span>
<span class="o">//</span> <span class="n">License</span><span class="o">.</span> <span class="n">See</span> <span class="n">LICENSE</span><span class="o">.</span><span class="n">TXT</span> <span class="k">for</span> <span class="n">details</span><span class="o">.</span>
<span class="o">//</span>
<span class="o">//===----------------------------------------------------------------------===//</span>
<span class="c1">#ifndef CPU0_EXECUTABLE_WRITER_H</span>
<span class="c1">#define CPU0_EXECUTABLE_WRITER_H</span>

<span class="c1">#include &quot;ExecutableWriter.h&quot;</span>
<span class="c1">#include &quot;Cpu0LinkingContext.h&quot;</span>
<span class="c1">#include &quot;Cpu0TargetHandler.h&quot;</span>

<span class="n">namespace</span> <span class="n">lld</span> <span class="p">{</span>
<span class="n">namespace</span> <span class="n">elf</span> <span class="p">{</span>

<span class="n">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ELFT</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Cpu0ExecutableWriter</span> <span class="p">:</span> <span class="n">public</span> <span class="n">ExecutableWriter</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
  <span class="n">Cpu0ExecutableWriter</span><span class="p">(</span><span class="n">Cpu0LinkingContext</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="p">,</span> <span class="n">Cpu0TargetLayout</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">layout</span><span class="p">);</span>

<span class="n">protected</span><span class="p">:</span>
  <span class="o">//</span> <span class="n">Add</span> <span class="nb">any</span> <span class="n">runtime</span> <span class="n">files</span> <span class="ow">and</span> <span class="n">their</span> <span class="n">atoms</span> <span class="n">to</span> <span class="n">the</span> <span class="n">output</span>
  <span class="n">void</span>
  <span class="n">createImplicitFiles</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="p">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">File</span><span class="o">&gt;&gt;</span> <span class="o">&amp;</span><span class="n">result</span><span class="p">)</span> <span class="n">override</span> <span class="p">{</span>
    <span class="n">ExecutableWriter</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;</span><span class="p">::</span><span class="n">createImplicitFiles</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
    <span class="n">auto</span> <span class="n">gotFile</span> <span class="o">=</span> <span class="n">llvm</span><span class="p">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">SimpleFile</span><span class="o">&gt;</span><span class="p">(</span><span class="s2">&quot;GOTFile&quot;</span><span class="p">);</span>
    <span class="n">gotFile</span><span class="o">-&gt;</span><span class="n">addAtom</span><span class="p">(</span><span class="o">*</span><span class="n">new</span> <span class="p">(</span><span class="n">gotFile</span><span class="o">-&gt;</span><span class="n">allocator</span><span class="p">())</span>
                         <span class="n">GlobalOffsetTableAtom</span><span class="p">(</span><span class="o">*</span><span class="n">gotFile</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">_ctx</span><span class="o">.</span><span class="n">isDynamic</span><span class="p">())</span>
      <span class="n">gotFile</span><span class="o">-&gt;</span><span class="n">addAtom</span><span class="p">(</span><span class="o">*</span><span class="n">new</span> <span class="p">(</span><span class="n">gotFile</span><span class="o">-&gt;</span><span class="n">allocator</span><span class="p">())</span> <span class="n">DynamicAtom</span><span class="p">(</span><span class="o">*</span><span class="n">gotFile</span><span class="p">));</span>
    <span class="n">result</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">move</span><span class="p">(</span><span class="n">gotFile</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="n">void</span> <span class="n">buildDynamicSymbolTable</span><span class="p">(</span><span class="n">const</span> <span class="n">File</span> <span class="o">&amp;</span><span class="n">file</span><span class="p">)</span> <span class="n">override</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">auto</span> <span class="n">sec</span> <span class="p">:</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">_layout</span><span class="o">.</span><span class="n">sections</span><span class="p">())</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">auto</span> <span class="n">section</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">AtomSection</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">sec</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">const</span> <span class="n">auto</span> <span class="o">&amp;</span><span class="n">atom</span> <span class="p">:</span> <span class="n">section</span><span class="o">-&gt;</span><span class="n">atoms</span><span class="p">())</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">_targetLayout</span><span class="o">.</span><span class="n">getGOTSection</span><span class="p">()</span><span class="o">.</span><span class="n">hasGlobalGOTEntry</span><span class="p">(</span><span class="n">atom</span><span class="o">-&gt;</span><span class="n">_atom</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">this</span><span class="o">-&gt;</span><span class="n">_dynamicSymbolTable</span><span class="o">-&gt;</span><span class="n">addSymbol</span><span class="p">(</span><span class="n">atom</span><span class="o">-&gt;</span><span class="n">_atom</span><span class="p">,</span> <span class="n">section</span><span class="o">-&gt;</span><span class="n">ordinal</span><span class="p">(),</span>
                                                 <span class="n">atom</span><span class="o">-&gt;</span><span class="n">_virtualAddr</span><span class="p">,</span> <span class="n">atom</span><span class="p">);</span>
          <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">ExecutableWriter</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;</span><span class="p">::</span><span class="n">buildDynamicSymbolTable</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">Cpu0TargetLayout</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">_targetLayout</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">}</span> <span class="o">//</span> <span class="n">namespace</span> <span class="n">elf</span>
<span class="p">}</span> <span class="o">//</span> <span class="n">namespace</span> <span class="n">lld</span>

<span class="c1">#endif</span>
</pre></div>
</div>
<p class="rubric">exlbt/lld/lib/ReaderWriter/ELF/Cpu0/Cpu0ExecutableWriter.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>
<span class="c1">#include &quot;Cpu0ExecutableWriter.h&quot;</span>

<span class="n">namespace</span> <span class="n">lld</span> <span class="p">{</span>
<span class="n">namespace</span> <span class="n">elf</span> <span class="p">{</span>

<span class="n">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ELFT</span><span class="o">&gt;</span>
<span class="n">Cpu0ExecutableWriter</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;</span><span class="p">::</span>
<span class="n">Cpu0ExecutableWriter</span><span class="p">(</span><span class="n">Cpu0LinkingContext</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="p">,</span> <span class="n">Cpu0TargetLayout</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">layout</span><span class="p">)</span>
    <span class="p">:</span> <span class="n">ExecutableWriter</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">layout</span><span class="p">),</span> <span class="n">_targetLayout</span><span class="p">(</span><span class="n">layout</span><span class="p">)</span> <span class="p">{}</span>

<span class="n">template</span> <span class="k">class</span> <span class="nc">Cpu0ExecutableWriter</span><span class="o">&lt;</span><span class="n">ELF32BE</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">template</span> <span class="k">class</span> <span class="nc">Cpu0ExecutableWriter</span><span class="o">&lt;</span><span class="n">ELF32LE</span><span class="o">&gt;</span><span class="p">;</span>

<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">exlbt/lld/lib/ReaderWriter/ELF/Cpu0/Cpu0LinkingContext.h</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//===-</span> <span class="n">lib</span><span class="o">/</span><span class="n">ReaderWriter</span><span class="o">/</span><span class="n">ELF</span><span class="o">/</span><span class="n">Cpu0</span><span class="o">/</span><span class="n">Cpu0LinkingContext</span><span class="o">.</span><span class="n">h</span> <span class="o">-----------------===//</span>
<span class="o">//</span>
<span class="o">//</span>                             <span class="n">The</span> <span class="n">LLVM</span> <span class="n">Linker</span>
<span class="o">//</span>
<span class="o">//</span> <span class="n">This</span> <span class="n">file</span> <span class="ow">is</span> <span class="n">distributed</span> <span class="n">under</span> <span class="n">the</span> <span class="n">University</span> <span class="n">of</span> <span class="n">Illinois</span> <span class="n">Open</span> <span class="n">Source</span>
<span class="o">//</span> <span class="n">License</span><span class="o">.</span> <span class="n">See</span> <span class="n">LICENSE</span><span class="o">.</span><span class="n">TXT</span> <span class="k">for</span> <span class="n">details</span><span class="o">.</span>
<span class="o">//</span>
<span class="o">//===----------------------------------------------------------------------===//</span>

<span class="c1">#ifndef LLD_READER_WRITER_ELF_CPU0_CPU0_LINKING_CONTEXT_H</span>
<span class="c1">#define LLD_READER_WRITER_ELF_CPU0_CPU0_LINKING_CONTEXT_H</span>

<span class="c1">#include &quot;lld/ReaderWriter/ELFLinkingContext.h&quot;</span>
<span class="c1">#include &quot;llvm/Object/ELF.h&quot;</span>
<span class="c1">#include &quot;llvm/Support/ELF.h&quot;</span>

<span class="n">namespace</span> <span class="n">lld</span> <span class="p">{</span>
<span class="n">namespace</span> <span class="n">elf</span> <span class="p">{</span>

<span class="o">///</span> \<span class="n">brief</span> <span class="n">Cpu0</span> <span class="n">internal</span> <span class="n">references</span><span class="o">.</span>
<span class="n">enum</span> <span class="p">{</span>
  <span class="o">///</span> \<span class="n">brief</span> <span class="n">The</span> <span class="mi">32</span> <span class="n">bit</span> <span class="n">index</span> <span class="n">of</span> <span class="n">the</span> <span class="n">relocation</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">got</span> <span class="n">this</span> <span class="n">reference</span> <span class="n">refers</span>
  <span class="o">///</span> <span class="n">to</span><span class="o">.</span>
  <span class="n">LLD_R_CPU0_GOTRELINDEX</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Cpu0LinkingContext</span> <span class="p">:</span> <span class="n">public</span> <span class="n">ELFLinkingContext</span> <span class="p">{</span>
<span class="n">protected</span><span class="p">:</span>
  <span class="n">Cpu0LinkingContext</span><span class="p">(</span><span class="n">llvm</span><span class="p">::</span><span class="n">Triple</span><span class="p">,</span> <span class="n">std</span><span class="p">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">TargetHandler</span><span class="o">&gt;</span><span class="p">);</span>

<span class="n">public</span><span class="p">:</span>
  <span class="n">static</span> <span class="n">std</span><span class="p">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ELFLinkingContext</span><span class="o">&gt;</span> <span class="n">create</span><span class="p">(</span><span class="n">llvm</span><span class="p">::</span><span class="n">Triple</span><span class="p">);</span>
  <span class="nb">int</span> <span class="n">getMachineType</span><span class="p">()</span> <span class="n">const</span> <span class="n">override</span> <span class="p">{</span> <span class="k">return</span> <span class="n">llvm</span><span class="p">::</span><span class="n">ELF</span><span class="p">::</span><span class="n">EM_CPU0</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">Cpu0LinkingContext</span><span class="p">(</span><span class="n">llvm</span><span class="p">::</span><span class="n">Triple</span><span class="p">);</span>

  <span class="n">void</span> <span class="n">addPasses</span><span class="p">(</span><span class="n">PassManager</span> <span class="o">&amp;</span><span class="p">)</span> <span class="n">override</span><span class="p">;</span>
  <span class="n">void</span> <span class="n">registerRelocationNames</span><span class="p">(</span><span class="n">Registry</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">)</span> <span class="n">override</span><span class="p">;</span>

  <span class="n">uint64_t</span> <span class="n">getBaseAddress</span><span class="p">()</span> <span class="n">const</span> <span class="n">override</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_baseAddress</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
      <span class="k">return</span> <span class="mh">0x00</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">_baseAddress</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nb">bool</span> <span class="n">isDynamicRelocation</span><span class="p">(</span><span class="n">const</span> <span class="n">Reference</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">)</span> <span class="n">const</span> <span class="n">override</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">kindNamespace</span><span class="p">()</span> <span class="o">!=</span> <span class="n">Reference</span><span class="p">::</span><span class="n">KindNamespace</span><span class="p">::</span><span class="n">ELF</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">false</span><span class="p">;</span>
    <span class="k">assert</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">kindArch</span><span class="p">()</span> <span class="o">==</span> <span class="n">Reference</span><span class="p">::</span><span class="n">KindArch</span><span class="p">::</span><span class="n">Cpu0</span><span class="p">);</span>
    <span class="n">switch</span> <span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">kindValue</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">case</span> <span class="n">llvm</span><span class="p">::</span><span class="n">ELF</span><span class="p">::</span><span class="n">R_CPU0_GLOB_DAT</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">true</span><span class="p">;</span>
    <span class="n">default</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">false</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="nb">bool</span> <span class="n">isPLTRelocation</span><span class="p">(</span><span class="n">const</span> <span class="n">Reference</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">)</span> <span class="n">const</span> <span class="n">override</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">kindNamespace</span><span class="p">()</span> <span class="o">!=</span> <span class="n">Reference</span><span class="p">::</span><span class="n">KindNamespace</span><span class="p">::</span><span class="n">ELF</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">false</span><span class="p">;</span>
    <span class="k">assert</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">kindArch</span><span class="p">()</span> <span class="o">==</span> <span class="n">Reference</span><span class="p">::</span><span class="n">KindArch</span><span class="p">::</span><span class="n">Cpu0</span><span class="p">);</span>
    <span class="n">switch</span> <span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">kindValue</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">case</span> <span class="n">llvm</span><span class="p">::</span><span class="n">ELF</span><span class="p">::</span><span class="n">R_CPU0_JUMP_SLOT</span><span class="p">:</span>
    <span class="n">case</span> <span class="n">llvm</span><span class="p">::</span><span class="n">ELF</span><span class="p">::</span><span class="n">R_CPU0_RELGOT</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">true</span><span class="p">;</span>
    <span class="n">default</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">false</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="o">///</span> \<span class="n">brief</span> <span class="n">Cpu0</span> <span class="n">has</span> <span class="n">one</span> <span class="n">relative</span> <span class="n">relocations</span>
  <span class="o">///</span> <span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">supporting</span> <span class="n">relative</span> <span class="n">relocs</span> <span class="o">-</span> <span class="n">R_CPU0_RELGOT</span>
  <span class="nb">bool</span> <span class="n">isRelativeReloc</span><span class="p">(</span><span class="n">const</span> <span class="n">Reference</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">)</span> <span class="n">const</span> <span class="n">override</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">kindNamespace</span><span class="p">()</span> <span class="o">!=</span> <span class="n">Reference</span><span class="p">::</span><span class="n">KindNamespace</span><span class="p">::</span><span class="n">ELF</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">false</span><span class="p">;</span>
    <span class="k">assert</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">kindArch</span><span class="p">()</span> <span class="o">==</span> <span class="n">Reference</span><span class="p">::</span><span class="n">KindArch</span><span class="p">::</span><span class="n">Cpu0</span><span class="p">);</span>
    <span class="n">switch</span> <span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">kindValue</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">case</span> <span class="n">llvm</span><span class="p">::</span><span class="n">ELF</span><span class="p">::</span><span class="n">R_CPU0_RELGOT</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">true</span><span class="p">;</span>
    <span class="n">default</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">false</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="nb">bool</span> <span class="n">isStaticExecutable</span><span class="p">()</span> <span class="n">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_isStaticExecutable</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
<span class="p">}</span> <span class="o">//</span> <span class="n">end</span> <span class="n">namespace</span> <span class="n">elf</span>
<span class="p">}</span> <span class="o">//</span> <span class="n">end</span> <span class="n">namespace</span> <span class="n">lld</span>

<span class="c1">#endif</span>
</pre></div>
</div>
<p class="rubric">exlbt/lld/lib/ReaderWriter/ELF/Cpu0/Cpu0LinkingContext.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//===-</span> <span class="n">lib</span><span class="o">/</span><span class="n">ReaderWriter</span><span class="o">/</span><span class="n">ELF</span><span class="o">/</span><span class="n">Cpu0</span><span class="o">/</span><span class="n">Cpu0LinkingContext</span><span class="o">.</span><span class="n">cpp</span> <span class="o">---------------===//</span>
<span class="o">//</span>
<span class="o">//</span>                             <span class="n">The</span> <span class="n">LLVM</span> <span class="n">Linker</span>
<span class="o">//</span>
<span class="o">//</span> <span class="n">This</span> <span class="n">file</span> <span class="ow">is</span> <span class="n">distributed</span> <span class="n">under</span> <span class="n">the</span> <span class="n">University</span> <span class="n">of</span> <span class="n">Illinois</span> <span class="n">Open</span> <span class="n">Source</span>
<span class="o">//</span> <span class="n">License</span><span class="o">.</span> <span class="n">See</span> <span class="n">LICENSE</span><span class="o">.</span><span class="n">TXT</span> <span class="k">for</span> <span class="n">details</span><span class="o">.</span>
<span class="o">//</span>
<span class="o">//===----------------------------------------------------------------------===//</span>

<span class="c1">#include &quot;llvm/Support/Endian.h&quot;</span>
<span class="c1">#include &quot;Cpu0LinkingContext.h&quot;</span>
<span class="c1">#include &quot;Cpu0RelocationPass.h&quot;</span>
<span class="c1">#include &quot;Cpu0TargetHandler.h&quot;</span>

<span class="n">using</span> <span class="n">namespace</span> <span class="n">lld</span><span class="p">;</span>
<span class="n">using</span> <span class="n">namespace</span> <span class="n">lld</span><span class="p">::</span><span class="n">elf</span><span class="p">;</span>
<span class="n">using</span> <span class="n">namespace</span> <span class="n">llvm</span><span class="p">::</span><span class="n">support</span><span class="p">;</span>

<span class="n">Cpu0LinkingContext</span><span class="p">::</span><span class="n">Cpu0LinkingContext</span><span class="p">(</span>
    <span class="n">llvm</span><span class="p">::</span><span class="n">Triple</span> <span class="n">triple</span><span class="p">,</span> <span class="n">std</span><span class="p">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">TargetHandler</span><span class="o">&gt;</span> <span class="n">handler</span><span class="p">)</span>
    <span class="p">:</span> <span class="n">ELFLinkingContext</span><span class="p">(</span><span class="n">triple</span><span class="p">,</span> <span class="n">std</span><span class="p">::</span><span class="n">move</span><span class="p">(</span><span class="n">handler</span><span class="p">))</span> <span class="p">{}</span>

<span class="n">static</span> <span class="n">std</span><span class="p">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">TargetHandler</span><span class="o">&gt;</span> <span class="n">createTarget</span><span class="p">(</span><span class="n">llvm</span><span class="p">::</span><span class="n">Triple</span> <span class="n">triple</span><span class="p">,</span>
                                                   <span class="n">Cpu0LinkingContext</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">switch</span> <span class="p">(</span><span class="n">triple</span><span class="o">.</span><span class="n">getArch</span><span class="p">())</span> <span class="p">{</span>
  <span class="n">case</span> <span class="n">llvm</span><span class="p">::</span><span class="n">Triple</span><span class="p">::</span><span class="n">cpu0</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">llvm</span><span class="p">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Cpu0TargetHandler</span><span class="o">&lt;</span><span class="n">ELF32BE</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">big</span><span class="p">);</span>
  <span class="n">case</span> <span class="n">llvm</span><span class="p">::</span><span class="n">Triple</span><span class="p">::</span><span class="n">cpu0el</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">llvm</span><span class="p">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Cpu0TargetHandler</span><span class="o">&lt;</span><span class="n">ELF32LE</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">little</span><span class="p">);</span>
  <span class="n">default</span><span class="p">:</span>
    <span class="n">llvm_unreachable</span><span class="p">(</span><span class="s2">&quot;Unhandled arch&quot;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="n">Cpu0LinkingContext</span><span class="p">::</span><span class="n">Cpu0LinkingContext</span><span class="p">(</span><span class="n">llvm</span><span class="p">::</span><span class="n">Triple</span> <span class="n">triple</span><span class="p">)</span>
    <span class="p">:</span> <span class="n">Cpu0LinkingContext</span><span class="p">(</span><span class="n">triple</span><span class="p">,</span> <span class="n">createTarget</span><span class="p">(</span><span class="n">triple</span><span class="p">,</span> <span class="o">*</span><span class="n">this</span><span class="p">))</span> <span class="p">{}</span>

<span class="n">void</span> <span class="n">Cpu0LinkingContext</span><span class="p">::</span><span class="n">addPasses</span><span class="p">(</span><span class="n">PassManager</span> <span class="o">&amp;</span><span class="n">pm</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">auto</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">createCpu0RelocationPass</span><span class="p">(</span><span class="o">*</span><span class="n">this</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">pass</span><span class="p">)</span>
    <span class="n">pm</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">move</span><span class="p">(</span><span class="k">pass</span><span class="p">));</span>
  <span class="n">ELFLinkingContext</span><span class="p">::</span><span class="n">addPasses</span><span class="p">(</span><span class="n">pm</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">std</span><span class="p">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ELFLinkingContext</span><span class="o">&gt;</span>
<span class="n">elf</span><span class="p">::</span><span class="n">createCpu0LinkingContext</span><span class="p">(</span><span class="n">llvm</span><span class="p">::</span><span class="n">Triple</span> <span class="n">triple</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">switch</span> <span class="p">(</span><span class="n">triple</span><span class="o">.</span><span class="n">getArch</span><span class="p">())</span> <span class="p">{</span>
  <span class="n">case</span> <span class="n">llvm</span><span class="p">::</span><span class="n">Triple</span><span class="p">::</span><span class="n">cpu0</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">llvm</span><span class="p">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Cpu0LinkingContext</span><span class="o">&gt;</span><span class="p">(</span><span class="n">triple</span><span class="p">);</span>
  <span class="n">case</span> <span class="n">llvm</span><span class="p">::</span><span class="n">Triple</span><span class="p">::</span><span class="n">cpu0el</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">llvm</span><span class="p">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Cpu0LinkingContext</span><span class="o">&gt;</span><span class="p">(</span><span class="n">triple</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">nullptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">static</span> <span class="n">const</span> <span class="n">Registry</span><span class="p">::</span><span class="n">KindStrings</span> <span class="n">kindStrings</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
<span class="c1">#define ELF_RELOC(name, value) LLD_KIND_STRING_ENTRY(name),</span>
<span class="c1">#include &quot;llvm/Support/ELFRelocs/Cpu0.def&quot;</span>
<span class="c1">#undef ELF_RELOC</span>
  <span class="n">LLD_KIND_STRING_ENTRY</span><span class="p">(</span><span class="n">LLD_R_CPU0_GOTRELINDEX</span><span class="p">),</span>
  <span class="n">LLD_KIND_STRING_END</span>
<span class="p">};</span>

<span class="n">void</span> <span class="n">Cpu0LinkingContext</span><span class="p">::</span><span class="n">registerRelocationNames</span><span class="p">(</span><span class="n">Registry</span> <span class="o">&amp;</span><span class="n">registry</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">registry</span><span class="o">.</span><span class="n">addKindTable</span><span class="p">(</span><span class="n">Reference</span><span class="p">::</span><span class="n">KindNamespace</span><span class="p">::</span><span class="n">ELF</span><span class="p">,</span>
                        <span class="n">Reference</span><span class="p">::</span><span class="n">KindArch</span><span class="p">::</span><span class="n">Cpu0</span><span class="p">,</span> <span class="n">kindStrings</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">exlbt/lld/lib/ReaderWriter/ELF/Cpu0/Cpu0RelocationHandler.h</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//===-</span> <span class="n">lib</span><span class="o">/</span><span class="n">ReaderWriter</span><span class="o">/</span><span class="n">ELF</span><span class="o">/</span><span class="n">Cpu0</span><span class="o">/</span><span class="n">Cpu0RelocationHandler</span><span class="o">.</span><span class="n">h</span> <span class="o">--------------===//</span>
<span class="o">//</span>
<span class="o">//</span>                             <span class="n">The</span> <span class="n">LLVM</span> <span class="n">Linker</span>
<span class="o">//</span>
<span class="o">//</span> <span class="n">This</span> <span class="n">file</span> <span class="ow">is</span> <span class="n">distributed</span> <span class="n">under</span> <span class="n">the</span> <span class="n">University</span> <span class="n">of</span> <span class="n">Illinois</span> <span class="n">Open</span> <span class="n">Source</span>
<span class="o">//</span> <span class="n">License</span><span class="o">.</span> <span class="n">See</span> <span class="n">LICENSE</span><span class="o">.</span><span class="n">TXT</span> <span class="k">for</span> <span class="n">details</span><span class="o">.</span>
<span class="o">//</span>
<span class="o">//===----------------------------------------------------------------------===//</span>

<span class="c1">#ifndef CPU0_RELOCATION_HANDLER_H</span>
<span class="c1">#define CPU0_RELOCATION_HANDLER_H</span>

<span class="c1">#include &quot;Cpu0TargetHandler.h&quot;</span>
<span class="c1">#include &quot;lld/ReaderWriter/ELFLinkingContext.h&quot;</span>
<span class="c1">#include &quot;llvm/Support/Endian.h&quot;</span>

<span class="n">using</span> <span class="n">namespace</span> <span class="n">llvm</span><span class="p">::</span><span class="n">support</span><span class="p">;</span>

<span class="n">namespace</span> <span class="n">lld</span> <span class="p">{</span>
<span class="n">namespace</span> <span class="n">elf</span> <span class="p">{</span>
<span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span> <span class="n">ELFT</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Cpu0TargetLayout</span><span class="p">;</span>
<span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span> <span class="n">ELFT</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Cpu0TargetHandler</span><span class="p">;</span>

<span class="n">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ELFT</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Cpu0TargetRelocationHandler</span> <span class="n">final</span> <span class="p">:</span> <span class="n">public</span> <span class="n">TargetRelocationHandler</span> <span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
  <span class="n">Cpu0TargetRelocationHandler</span><span class="p">(</span><span class="n">Cpu0LinkingContext</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="p">,</span> 
                              <span class="n">Cpu0TargetLayout</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">layout</span><span class="p">,</span> 
                              <span class="n">Cpu0TargetHandler</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">targetHandler</span><span class="p">,</span>
                              <span class="n">endianness</span> <span class="n">endian</span><span class="p">)</span>
      <span class="p">:</span> <span class="n">_tlsSize</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">),</span> <span class="n">_layout</span><span class="p">(</span><span class="n">layout</span><span class="p">),</span> <span class="n">_targetHandler</span><span class="p">(</span><span class="n">targetHandler</span><span class="p">),</span>
        <span class="n">_endian</span><span class="p">(</span><span class="n">endian</span><span class="p">)</span>
  <span class="p">{}</span>

  <span class="n">std</span><span class="p">::</span><span class="n">error_code</span> <span class="n">applyRelocation</span><span class="p">(</span><span class="n">ELFWriter</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">llvm</span><span class="p">::</span><span class="n">FileOutputBuffer</span> <span class="o">&amp;</span><span class="p">,</span>
                                  <span class="n">const</span> <span class="n">AtomLayout</span> <span class="o">&amp;</span><span class="p">,</span>
                                  <span class="n">const</span> <span class="n">Reference</span> <span class="o">&amp;</span><span class="p">)</span> <span class="n">const</span> <span class="n">override</span><span class="p">;</span>

  <span class="n">endianness</span> <span class="n">endian</span><span class="p">()</span> <span class="n">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_endian</span><span class="p">;</span> <span class="p">};</span>

<span class="n">private</span><span class="p">:</span>
  <span class="o">//</span> <span class="n">Cached</span> <span class="n">size</span> <span class="n">of</span> <span class="n">the</span> <span class="n">TLS</span> <span class="n">segment</span><span class="o">.</span>
  <span class="n">mutable</span> <span class="n">uint64_t</span> <span class="n">_tlsSize</span><span class="p">;</span>
  <span class="n">Cpu0LinkingContext</span> <span class="o">&amp;</span><span class="n">_ctx</span><span class="p">;</span>
  <span class="n">Cpu0TargetLayout</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">_layout</span><span class="p">;</span>
  <span class="n">Cpu0TargetHandler</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">_targetHandler</span><span class="p">;</span>
  <span class="n">endianness</span> <span class="n">_endian</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">}</span> <span class="o">//</span> <span class="n">end</span> <span class="n">namespace</span> <span class="n">elf</span>
<span class="p">}</span> <span class="o">//</span> <span class="n">end</span> <span class="n">namespace</span> <span class="n">lld</span>

<span class="c1">#endif // Cpu0_RELOCATION_HANDLER_H</span>
</pre></div>
</div>
<p class="rubric">exlbt/lld/lib/ReaderWriter/ELF/Cpu0/Cpu0RelocationHandler.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>//===- lib/ReaderWriter/ELF/Cpu0/Cpu0RelocationHandler.cpp ------------===//
//
//                             The LLVM Linker
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#include &quot;Cpu0LinkingContext.h&quot;
#include &quot;Cpu0TargetHandler.h&quot;
#include &quot;llvm/Support/Endian.h&quot;

using namespace lld;
using namespace lld::elf;
using namespace llvm::support;
using namespace llvm::support::endian;

//template &lt;class ELFT&gt;
/// \brief R_CPU0_HI16 - word64: (S + A) &gt;&gt; 16
void relocHI16(uint8_t *location, uint64_t P, uint64_t S, int64_t A, endianness endian) {
 // Don&#39;t know why A, ref.addend(), = 9
  uint32_t result = (uint32_t)(S &gt;&gt; 16);
//  endian::write&lt;uint32_t, ELFT::TargetEndianness, unaligned&gt;(location, result);
  if (endian == big) {
    write32be(location, result | read32be(location));
  }
  else if (endian == little) {
    write32le(location, result | read32le(location));
  }
  else {
    llvm_unreachable(&quot;Unexpected size&quot;);
  }
}

void relocLO16(uint8_t *location, uint64_t P, uint64_t S, uint64_t A, endianness endian) {
 // Don&#39;t know why A, ref.addend(), = 9
  uint32_t result = (uint32_t)(S &amp; 0x0000ffff);
  if (endian == big) {
    write32be(location, result | read32be(location));
  }
  else if (endian == little) {
    write32le(location, result | read32le(location));
  }
  else {
    llvm_unreachable(&quot;Unexpected size&quot;);
  }
}

#if 0 // Not support yet
/// \brief R_CPU0_GOT16 - word32: S
void relocGOT16(uint8_t *location, uint64_t P, uint64_t S, int64_t A) {
  uint32_t result = (uint32_t)(S);
  write32be(location, result | read32be(location));
}
#endif

/// \brief R_CPU0_PC24 - word32: S + A - P
void relocPC24(uint8_t *location, uint64_t P, uint64_t S, int64_t A, endianness endian) {
  uint32_t result = (uint32_t)(S  - P);
  if (endian == big) {
    uint32_t machinecode = (uint32_t) * 
                           reinterpret_cast&lt;llvm::support::ubig32_t *&gt;(location);
    uint32_t opcode = (machinecode &amp; 0xff000000);
    uint32_t offset = (machinecode &amp; 0x00ffffff);
    write32be(location, ((result + offset) &amp; 0x00ffffff) | opcode);
  }
  else if (endian == little) {
    uint32_t machinecode = (uint32_t) * 
                           reinterpret_cast&lt;llvm::support::ulittle32_t *&gt;(location);
    uint32_t opcode = (machinecode &amp; 0xff000000);
    uint32_t offset = (machinecode &amp; 0x00ffffff);
    write32le(location, ((result + offset) &amp; 0x00ffffff) | opcode);
  }
  else {
    llvm_unreachable(&quot;Unexpected size&quot;);
  }
}

/// \brief R_CPU0_32 - word32:  S
void reloc32(uint8_t *location, uint64_t P, uint64_t S, int64_t A, endianness endian) {
  int32_t result = (uint32_t)(S);
  if (endian == big) {
    write32be(location, result | read32be(location));
  }
  else if (endian == little) {
    write32le(location, result | read32be(location));
  }
  else {
    llvm_unreachable(&quot;Unexpected size&quot;);
  }
  // TODO: Make sure that the result zero extends to the 64bit value.
}

template &lt;class ELFT&gt; std::error_code Cpu0TargetRelocationHandler&lt;ELFT&gt;::applyRelocation(
    ELFWriter &amp;writer, llvm::FileOutputBuffer &amp;buf, const AtomLayout &amp;atom,
    const Reference &amp;ref) const {
#ifdef DLINKER
  static bool firstTime = true;
  std::string soName(&quot;libfoobar.cpu0.so&quot;);
  int idx = 0;
  if (firstTime) {
    if (this-&gt;_ctx.getOutputELFType() == llvm::ELF::ET_DYN) {
      _targetHandler.soPlt.createFunAddr(_layout, buf);
    }
    else if (this-&gt;_ctx.getOutputELFType() == llvm::ELF::ET_EXEC &amp;&amp; 
             !this-&gt;_ctx.isStaticExecutable()) {
      _targetHandler.soPlt.createFunAddr(_layout, buf);
    }
    firstTime = false;
  }
#endif // DLINKER
  uint8_t *atomContent = buf.getBufferStart() + atom._fileOffset;
  uint8_t *loc = atomContent + ref.offsetInAtom();
  uint64_t target = writer.addressOfAtom(ref.target());
  uint64_t reloc = atom._virtualAddr + ref.offsetInAtom();
#ifdef DLINKER
#if 1 // For case R_CPU0_GOT16:
//  auto gotAtomIter = _context.getTargetHandler&lt;Cpu0ELFType&gt;().targetLayout().
//                     findAbsoluteAtom(&quot;_GLOBAL_OFFSET_TABLE_&quot;);
//  uint64_t globalOffsetTableAddress = writer.addressOfAtom(*gotAtomIter);
// .got.plt start from _GLOBAL_OFFSET_TABLE_
  auto gotpltSection = _layout.findOutputSection(&quot;.got.plt&quot;);
  uint64_t gotPltFileOffset;
  if (gotpltSection)
    gotPltFileOffset = gotpltSection-&gt;fileOffset();
  else
    gotPltFileOffset = 0;
#endif
#endif // DLINKER

  if (ref.kindNamespace() != Reference::KindNamespace::ELF)
    return std::error_code();
  assert(ref.kindArch() == Reference::KindArch::Cpu0);
  switch (ref.kindValue()) {
  case R_CPU0_NONE:
    break;
  case R_CPU0_HI16:
    relocHI16(loc, reloc, target, ref.addend(), _endian);
    break;
  case R_CPU0_LO16:
    relocLO16(loc, reloc, target, ref.addend(), _endian);
    break;
#if 0 // Not support yet
  case R_CPU0_GOT16:
#if 1
    idx = _targetHandler.soPlt.getDynFunIndexByTargetAddr(targetVAddress);
    relocGOT16(location, reloc, idx, ref.addend(), _endian);
#else
    relocGOT16(location, reloc, (target - gotPltFileOffset),
               ref.addend());
#endif
    break;
#endif
  case R_CPU0_PC24:
    relocPC24(loc, reloc, target, ref.addend(), _endian);
    break;
#ifdef DLINKER
  case R_CPU0_CALL16:
  // offset at _GLOBAL_OFFSET_TABLE_ and $gp point to _GLOBAL_OFFSET_TABLE_.
    idx = _targetHandler.soPlt.getDynFunIndexByTargetAddr(target);
    reloc32(loc, reloc, idx*0x04+16, ref.addend(), _endian);
    break;
#endif // DLINKER
  case R_CPU0_32:
    reloc32(loc, reloc, target, ref.addend(), _endian);
    break;
  // Runtime only relocations. Ignore here.
  case R_CPU0_JUMP_SLOT:
  case R_CPU0_GLOB_DAT:
    break;
  default:
    return make_unhandled_reloc_error();
  }

  return std::error_code();
}

namespace lld {
namespace elf {

template class Cpu0TargetRelocationHandler&lt;ELF32BE&gt;;
template class Cpu0TargetRelocationHandler&lt;ELF32LE&gt;;

} // end namespace elf
} // end namespace lld

</pre></div>
</div>
<p class="rubric">exlbt/lld/lib/ReaderWriter/ELF/Cpu0/Cpu0RelocationPass.h</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//===-</span> <span class="n">lib</span><span class="o">/</span><span class="n">ReaderWriter</span><span class="o">/</span><span class="n">ELF</span><span class="o">/</span><span class="n">Cpu0</span><span class="o">/</span><span class="n">Cpu0RelocationPass</span><span class="o">.</span><span class="n">h</span> <span class="o">-----------------===//</span>
<span class="o">//</span>
<span class="o">//</span>                             <span class="n">The</span> <span class="n">LLVM</span> <span class="n">Linker</span>
<span class="o">//</span>
<span class="o">//</span> <span class="n">This</span> <span class="n">file</span> <span class="ow">is</span> <span class="n">distributed</span> <span class="n">under</span> <span class="n">the</span> <span class="n">University</span> <span class="n">of</span> <span class="n">Illinois</span> <span class="n">Open</span> <span class="n">Source</span>
<span class="o">//</span> <span class="n">License</span><span class="o">.</span> <span class="n">See</span> <span class="n">LICENSE</span><span class="o">.</span><span class="n">TXT</span> <span class="k">for</span> <span class="n">details</span><span class="o">.</span>
<span class="o">//</span>
<span class="o">//===----------------------------------------------------------------------===//</span>
<span class="o">///</span>
<span class="o">///</span> \<span class="n">file</span>
<span class="o">///</span> \<span class="n">brief</span> <span class="n">Declares</span> <span class="n">the</span> <span class="n">relocation</span> <span class="n">processing</span> <span class="k">pass</span> <span class="k">for</span> <span class="n">x86</span><span class="o">-</span><span class="mf">64.</span> <span class="n">This</span> <span class="n">includes</span>
<span class="o">///</span>   <span class="n">GOT</span> <span class="ow">and</span> <span class="n">PLT</span> <span class="n">entries</span><span class="p">,</span> <span class="n">TLS</span><span class="p">,</span> <span class="n">COPY</span><span class="p">,</span> <span class="ow">and</span> <span class="n">ifunc</span><span class="o">.</span>
<span class="o">///</span>
<span class="o">//===----------------------------------------------------------------------===//</span>

<span class="c1">#ifndef LLD_READER_WRITER_ELF_CPU0_CPU0_RELOCATION_PASS_H</span>
<span class="c1">#define LLD_READER_WRITER_ELF_CPU0_CPU0_RELOCATION_PASS_H</span>

<span class="c1">#include &lt;memory&gt;</span>
<span class="c1">#include &quot;Cpu0TargetHandler.h&quot;</span>

<span class="n">namespace</span> <span class="n">lld</span> <span class="p">{</span>
<span class="k">class</span> <span class="nc">Pass</span><span class="p">;</span>
<span class="n">namespace</span> <span class="n">elf</span> <span class="p">{</span>
<span class="k">class</span> <span class="nc">Cpu0LinkingContext</span><span class="p">;</span>

<span class="o">///</span> \<span class="n">brief</span> <span class="n">Create</span> <span class="n">x86</span><span class="o">-</span><span class="mi">64</span> <span class="n">relocation</span> <span class="k">pass</span> <span class="k">for</span> <span class="n">the</span> <span class="n">given</span> <span class="n">linking</span> <span class="n">context</span><span class="o">.</span>
<span class="n">std</span><span class="p">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Pass</span><span class="o">&gt;</span>
<span class="n">createCpu0RelocationPass</span><span class="p">(</span><span class="n">const</span> <span class="n">Cpu0LinkingContext</span> <span class="o">&amp;</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">}</span>

<span class="c1">#endif</span>
</pre></div>
</div>
<p class="rubric">exlbt/lld/lib/ReaderWriter/ELF/Cpu0/Cpu0RelocationPass.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>//===- lib/ReaderWriter/ELF/Cpu0/Cpu0RelocationPass.cpp ---------------===//
//
//                             The LLVM Linker
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
///
/// \file
/// \brief Defines the relocation processing pass for cpu0. This includes
///   GOT and PLT entries, TLS, COPY, and ifunc.
///
/// This also includes aditional behaivor that gnu-ld and gold implement but
/// which is not specified anywhere.
///
//===----------------------------------------------------------------------===//

#include &quot;Cpu0RelocationPass.h&quot;
#include &quot;Atoms.h&quot;
#include &quot;Cpu0LinkingContext.h&quot;
#include &quot;lld/Core/Simple.h&quot;
#include &quot;llvm/ADT/DenseMap.h&quot;
#include &quot;llvm/ADT/STLExtras.h&quot;
#include &quot;llvm/Support/Endian.h&quot;

using namespace lld;
using namespace lld::elf;
using namespace llvm::ELF;
using namespace llvm::support;

extern endianness gEndian; // set in constuctor of Cpu0TargetHandler.cpp

// .plt value (entry 0), big endian
const uint8_t cpu0BootAtomContent[16] = {
  0x36, 0xff, 0xff, 0xfc, // jmp start
  0x36, 0x00, 0x00, 0x04, // jmp 4
  0x36, 0xff, 0xff, 0xfc, // jmp ISR
  0x36, 0xff, 0xff, 0xfc // jmp -4
};
// little endian
const uint8_t cpu0elBootAtomContent[16] = {
  0xfc, 0xff, 0xff, 0x36, // jmp start
  0x04, 0x00, 0x00, 0x36, // jmp 4
  0xfc, 0xff, 0xff, 0x36, // jmp ISR
  0xfc, 0xff, 0xff, 0x36 // jmp -4
};

// .got values
const uint8_t cpu0GotAtomContent[64] = { 0 };

#ifdef DLINKER
// .plt value (entry 0), big endian
const uint8_t cpu0Plt0AtomContent[16] = {
  0x02, 0xeb, 0x00, 0x04, // st $lr, $zero, reloc-index ($gp)
  0x02, 0xcb, 0x00, 0x08, // st $fp, $zero, reloc-index ($gp)
  0x02, 0xdb, 0x00, 0x0c, // st $sp, $zero, reloc-index ($gp)
  0x36, 0xff, 0xff, 0xfc  // jmp dynamic_linker
};
// little endian
const uint8_t cpu0elPlt0AtomContent[16] = {
  0x04, 0x00, 0xeb, 0x02, // st $lr, $zero, reloc-index ($gp)
  0x08, 0x00, 0xcb, 0x02, // st $fp, $zero, reloc-index ($gp)
  0x0c, 0x00, 0xdb, 0x02, // st $sp, $zero, reloc-index ($gp)
  0xfc, 0xff, 0xff, 0x36  // jmp dynamic_linker
};

// .plt values (other entries), big endian
const uint8_t cpu0PltAtomContent[16] = {
  0x01, 0x6b, 0x00, 0x10, // ld $t9, 0x10($gp) (0x10($gp) point to plt0
  0x3c, 0x60, 0x00, 0x00, // ret $t9 // jump to Cpu0.Stub
  0x00, 0x00, 0x00, 0x00, // nop
  0x00, 0x00, 0x00, 0x00  // nop
};
// little endian
const uint8_t cpu0elPltAtomContent[16] = {
  0x10, 0x00, 0x6b, 0x01, // ld $t9, 0x10($gp) (0x10($gp) point to plt0
  0x00, 0x00, 0x60, 0x3c, // ret $t9 // jump to Cpu0.Stub
  0x00, 0x00, 0x00, 0x00, // nop
  0x00, 0x00, 0x00, 0x00  // nop
};

// TLS GD Entry
static const uint8_t cpu0GotTlsGdAtomContent[] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};
#endif // DLINKER

/// boot record
class Cpu0BootAtom : public PLT0Atom {
public:
  Cpu0BootAtom(const File &amp;f) : PLT0Atom(f) {
#ifndef NDEBUG
    _name = &quot;.PLT0&quot;;
#endif
  }
  virtual ArrayRef&lt;uint8_t&gt; rawContent() const {
    if (gEndian == big)
      return ArrayRef&lt;uint8_t&gt;(cpu0BootAtomContent, 16);
    else
      return ArrayRef&lt;uint8_t&gt;(cpu0elBootAtomContent, 16);
  }
};

namespace {
/// \brief Atoms that are used by Cpu0 dynamic linking
class Cpu0GOTAtom : public GOTAtom {
public:
  Cpu0GOTAtom(const File &amp;f, StringRef secName) : GOTAtom(f, secName) {}

  ArrayRef&lt;uint8_t&gt; rawContent() const override {
    return ArrayRef&lt;uint8_t&gt;(cpu0GotAtomContent, 64);
  }
};

#ifdef DLINKER
/// \brief Cpu0 GOT TLS GD entry.
class GOTTLSGdAtom : public Cpu0GOTAtom {
public:
  GOTTLSGdAtom(const File &amp;f, StringRef secName) : Cpu0GOTAtom(f, secName) {}

  ArrayRef&lt;uint8_t&gt; rawContent() const override {
    return llvm::makeArrayRef(cpu0GotTlsGdAtomContent);
  }
};

class Cpu0PLT0Atom : public PLT0Atom {
public:
  Cpu0PLT0Atom(const File &amp;f) : PLT0Atom(f) {}
  ArrayRef&lt;uint8_t&gt; rawContent() const override {
    if (gEndian == big)
      return ArrayRef&lt;uint8_t&gt;(cpu0Plt0AtomContent, 16);
    else
      return ArrayRef&lt;uint8_t&gt;(cpu0elPlt0AtomContent, 16);
  }
};

class Cpu0PLTAtom : public PLTAtom {
public:
  Cpu0PLTAtom(const File &amp;f, StringRef secName) : PLTAtom(f, secName) {}

  ArrayRef&lt;uint8_t&gt; rawContent() const override {
    if (gEndian == big)
      return ArrayRef&lt;uint8_t&gt;(cpu0PltAtomContent, 16);
    else
      return ArrayRef&lt;uint8_t&gt;(cpu0elPltAtomContent, 16);
  }
};
#endif // DLINKER

class ELFPassFile : public SimpleFile {
public:
  ELFPassFile(const ELFLinkingContext &amp;eti) : SimpleFile(&quot;ELFPassFile&quot;) {
    setOrdinal(eti.getNextOrdinalAndIncrement());
  }

  llvm::BumpPtrAllocator _alloc;
};

/// \brief CRTP base for handling relocations.
template &lt;class Derived&gt; class RelocationPass : public Pass {
  /// \brief Handle a specific reference.
  void handleReference(const DefinedAtom &amp;atom, const Reference &amp;ref) {
    if (ref.kindNamespace() != Reference::KindNamespace::ELF)
      return;
    assert(ref.kindArch() == Reference::KindArch::Cpu0);
    switch (ref.kindValue()) {
    case R_CPU0_PC24:
      static_cast&lt;Derived *&gt;(this)-&gt;handlePlain(ref);
    case R_CPU0_CALL16:
      static_cast&lt;Derived *&gt;(this)-&gt;handlePLT32(ref);
      break;
    }
  }

protected:
#ifdef DLINKER
  /// \brief get the PLT entry for a given IFUNC Atom.
  ///
  /// If the entry does not exist. Both the GOT and PLT entry is created.
  const PLTAtom *getIFUNCPLTEntry(const DefinedAtom *da) {
    auto plt = _pltMap.find(da);
    if (plt != _pltMap.end())
      return plt-&gt;second;
    auto ga = new (_file._alloc) Cpu0GOTAtom(_file, &quot;.got.plt&quot;);
    ga-&gt;addReferenceELF_Cpu0(R_CPU0_RELGOT, 0, da, 0);
    auto pa = new (_file._alloc) Cpu0PLTAtom(_file, &quot;.plt&quot;);
    pa-&gt;addReferenceELF_Cpu0(R_CPU0_PC24, 2, ga, -4);
#ifndef NDEBUG
    ga-&gt;_name = &quot;__got_ifunc_&quot;;
    ga-&gt;_name += da-&gt;name();
    pa-&gt;_name = &quot;__plt_ifunc_&quot;;
    pa-&gt;_name += da-&gt;name();
#endif
    _gotMap[da] = ga;
    _pltMap[da] = pa;
    _gotVector.push_back(ga);
    _pltVector.push_back(pa);
    return pa;
  }
#endif // DLINKER

  /// \brief Redirect the call to the PLT stub for the target IFUNC.
  ///
  /// This create a PLT and GOT entry for the IFUNC if one does not exist. The
  /// GOT entry and a IRELATIVE relocation to the original target resolver.
  std::error_code handleIFUNC(const Reference &amp;ref) {
#ifdef DLINKER
    auto target = dyn_cast_or_null&lt;const DefinedAtom&gt;(ref.target());
    if (target &amp;&amp; target-&gt;contentType() == DefinedAtom::typeResolver)
      const_cast&lt;Reference &amp;&gt;(ref).setTarget(getIFUNCPLTEntry(target));
#endif // DLINKER
    return std::error_code();
  }

  /// \brief Create a GOT entry for the TP offset of a TLS atom.
  const GOTAtom *getGOTTPOFF(const Atom *atom) {
    auto got = _gotMap.find(atom);
    if (got == _gotMap.end()) {
      auto g = new (_file._alloc) Cpu0GOTAtom(_file, &quot;.got&quot;);
      g-&gt;addReferenceELF_Cpu0(R_CPU0_TLS_TPREL32, 0, atom, 0);
#ifndef NDEBUG
      g-&gt;_name = &quot;__got_tls_&quot;;
      g-&gt;_name += atom-&gt;name();
#endif
      _gotMap[atom] = g;
      _gotVector.push_back(g);
      return g;
    }
    return got-&gt;second;
  }

  /// \brief Create a GOT entry containing 0.
  const GOTAtom *getNullGOT() {
    if (!_null) {
      _null = new (_file._alloc) Cpu0GOTAtom(_file, &quot;.got.plt&quot;);
#ifndef NDEBUG
      _null-&gt;_name = &quot;__got_null&quot;;
#endif
    }
    return _null;
  }

  const GOTAtom *getGOT(const DefinedAtom *da) {
    auto got = _gotMap.find(da);
    if (got == _gotMap.end()) {
      auto g = new (_file._alloc) Cpu0GOTAtom(_file, &quot;.got&quot;);
      g-&gt;addReferenceELF_Cpu0(R_CPU0_32, 0, da, 0);
#ifndef NDEBUG
      g-&gt;_name = &quot;__got_&quot;;
      g-&gt;_name += da-&gt;name();
#endif
      _gotMap[da] = g;
      _gotVector.push_back(g);
      return g;
    }
    return got-&gt;second;
  }

public:
  RelocationPass(const ELFLinkingContext &amp;ctx)
      : _file(ctx), _ctx(ctx), _boot(new Cpu0BootAtom(_file)) {}

  /// \brief Do the pass.
  ///
  /// The goal here is to first process each reference individually. Each call
  /// to handleReference may modify the reference itself and/or create new
  /// atoms which must be stored in one of the maps below.
  ///
  /// After all references are handled, the atoms created during that are all
  /// added to mf.
  std::error_code perform(SimpleFile &amp;mf) override {
    ScopedTask task(getDefaultDomain(), &quot;Cpu0 GOT/PLT Pass&quot;);
    // Process all references.
    for (const auto &amp;atom : mf.defined())
      for (const auto &amp;ref : *atom)
        handleReference(*atom, *ref);

    // Add all created atoms to the link.
    uint64_t ordinal = 0;
    if (_ctx.getOutputELFType() == llvm::ELF::ET_EXEC) {
      SimpleFile::DefinedAtomRange atomRange = mf.definedAtoms();
      auto it = atomRange.begin();
      bool find = false;
      for (it = atomRange.begin(); it &lt; atomRange.end(); it++) {
        if ((*it)-&gt;name() == &quot;start&quot;) {
          find = true;
          break;
        }
      }
      assert(find &amp;&amp; &quot;not found start\n&quot;);
      _boot-&gt;addReferenceELF_Cpu0(R_CPU0_PC24, 0, *it, -3);
      find = false;
      for (it = atomRange.begin(); it &lt; atomRange.end(); it++) {
        if ((*it)-&gt;name() == &quot;ISR&quot;) {
          find = true;
          break;
        }
      }
      assert(find &amp;&amp; &quot;not found ISR\n&quot;);
      _boot-&gt;addReferenceELF_Cpu0(R_CPU0_PC24, 8, *it, -3);
      _boot-&gt;setOrdinal(ordinal++);
      mf.addAtom(*_boot);
    }
#ifdef DLINKER
    if (_plt0) {
      SimpleFile::DefinedAtomRange atomRange = mf.definedAtoms();
      auto it = atomRange.begin();
      bool find = false;
      for (it = atomRange.begin(); it &lt; atomRange.end(); it++) {
        if ((*it)-&gt;name() == &quot;_Z14dynamic_linkerv&quot;) {
          find = true;
          break;
        }
      }
      assert(find &amp;&amp; &quot;Cannot find _Z14dynamic_linkerv()&quot;);
      _plt0-&gt;addReferenceELF_Cpu0(R_CPU0_PC24, 12, *it, -3);
      _plt0-&gt;setOrdinal(ordinal++);
      mf.addAtom(*_plt0);
    }
#endif // DLINKER
    for (auto &amp;plt : _pltVector) {
      plt-&gt;setOrdinal(ordinal++);
      mf.addAtom(*plt);
    }
    if (_null) {
      _null-&gt;setOrdinal(ordinal++);
      mf.addAtom(*_null);
    }
    if (_plt0) {
      _got0-&gt;setOrdinal(ordinal++);
      mf.addAtom(*_got0);
    }
    for (auto &amp;got : _gotVector) {
      got-&gt;setOrdinal(ordinal++);
      mf.addAtom(*got);
    }
    for (auto &amp;got : _tlsGotVector) {
      got-&gt;setOrdinal(ordinal++);
      mf.addAtom(*got);
    }
    for (auto obj : _objectVector) {
      obj-&gt;setOrdinal(ordinal++);
      mf.addAtom(*obj);
    }
    return std::error_code();
  }

protected:
  /// \brief Owner of all the Atoms created by this pass.
  ELFPassFile _file;
  const ELFLinkingContext &amp;_ctx;

  /// \brief Map Atoms to their GOT entries.
  llvm::DenseMap&lt;const Atom *, GOTAtom *&gt; _gotMap;

  /// \brief Map Atoms to their PLT entries.
  llvm::DenseMap&lt;const Atom *, PLTAtom *&gt; _pltMap;

  /// \brief Map Atoms to TLS GD GOT entries.
  llvm::DenseMap&lt;const Atom *, GOTAtom *&gt; _gotTLSGdMap;

  /// \brief Map Atoms to their Object entries.
  llvm::DenseMap&lt;const Atom *, ObjectAtom *&gt; _objectMap;

  /// \brief the list of GOT/PLT atoms
  std::vector&lt;GOTAtom *&gt; _gotVector;
  std::vector&lt;PLTAtom *&gt; _pltVector;
  std::vector&lt;ObjectAtom *&gt; _objectVector;
  PLT0Atom *_boot;

  /// \brief the list of TLS GOT atoms.
  std::vector&lt;GOTAtom *&gt; _tlsGotVector;

  /// \brief GOT entry that is always 0. Used for undefined weaks.
  GOTAtom *_null = nullptr;

  /// \brief The got and plt entries for .PLT0. This is used to call into the
  /// dynamic linker for symbol resolution.
  /// @{
  PLT0Atom *_plt0 = nullptr;
  GOTAtom *_got0 = nullptr;
  /// @}
};

/// This implements the static relocation model. Meaning GOT and PLT entries are
/// not created for references that can be directly resolved. These are
/// converted to a direct relocation. For entries that do require a GOT or PLT
/// entry, that entry is statically bound.
///
/// TLS always assumes module 1 and attempts to remove indirection.
class StaticRelocationPass final
    : public RelocationPass&lt;StaticRelocationPass&gt; {
public:
  StaticRelocationPass(const elf::Cpu0LinkingContext &amp;ctx)
      : RelocationPass(ctx) {}

  std::error_code handlePlain(const Reference &amp;ref) { return handleIFUNC(ref); }

  std::error_code handlePLT32(const Reference &amp;ref) {
    // __tls_get_addr is handled elsewhere.
    if (ref.target() &amp;&amp; ref.target()-&gt;name() == &quot;__tls_get_addr&quot;) {
      const_cast&lt;Reference &amp;&gt;(ref).setKindValue(R_CPU0_NONE);
      return std::error_code();
    }
    // Static code doesn&#39;t need PLTs.
    const_cast&lt;Reference &amp;&gt;(ref).setKindValue(R_CPU0_PC24);
    // Handle IFUNC.
    if (const DefinedAtom *da =
            dyn_cast_or_null&lt;const DefinedAtom&gt;(ref.target()))
      if (da-&gt;contentType() == DefinedAtom::typeResolver)
        return handleIFUNC(ref);
    return std::error_code();
  }

  std::error_code handleGOT(const Reference &amp;ref) {
    if (isa&lt;UndefinedAtom&gt;(ref.target()))
      const_cast&lt;Reference &amp;&gt;(ref).setTarget(getNullGOT());
    else if (const DefinedAtom *da = dyn_cast&lt;const DefinedAtom&gt;(ref.target()))
      const_cast&lt;Reference &amp;&gt;(ref).setTarget(getGOT(da));
    return std::error_code();
  }
};

#ifdef DLINKER
class DynamicRelocationPass final
    : public RelocationPass&lt;DynamicRelocationPass&gt; {
public:
  DynamicRelocationPass(const elf::Cpu0LinkingContext &amp;ctx)
      : RelocationPass(ctx) {}

  const PLT0Atom *getPLT0() {
    if (_plt0)
      return _plt0;
    // Fill in the null entry.
    getNullGOT();
    _plt0 = new (_file._alloc) Cpu0PLT0Atom(_file);
    _got0 = new (_file._alloc) Cpu0GOTAtom(_file, &quot;.got.plt&quot;);
#ifndef NDEBUG
    _got0-&gt;_name = &quot;__got0&quot;;
#endif
    return _plt0;
  }

  const PLTAtom *getPLTEntry(const Atom *a) {
    auto plt = _pltMap.find(a);
    if (plt != _pltMap.end())
      return plt-&gt;second;
    auto ga = new (_file._alloc) Cpu0GOTAtom(_file, &quot;.got.plt&quot;);
    ga-&gt;addReferenceELF_Cpu0(R_CPU0_JUMP_SLOT, 0, a, 0);
    auto pa = new (_file._alloc) Cpu0PLTAtom(_file, &quot;.plt&quot;);
    getPLT0();  // add _PLT0 and _got0

    // Set the starting address of the got entry to the second instruction in
    // the plt entry.
    ga-&gt;addReferenceELF_Cpu0(R_CPU0_32, 0, pa, 4);
#ifndef NDEBUG
    ga-&gt;_name = &quot;__got_&quot;;
    ga-&gt;_name += a-&gt;name();
    pa-&gt;_name = &quot;__plt_&quot;;
    pa-&gt;_name += a-&gt;name();
#endif
    _gotMap[a] = ga;
    _pltMap[a] = pa;
    _gotVector.push_back(ga);
    _pltVector.push_back(pa);
    return pa;
  }

  std::error_code handlePlain(const Reference &amp;ref) {
    if (!ref.target())
      return std::error_code();
    if (auto sla = dyn_cast&lt;SharedLibraryAtom&gt;(ref.target())) {
      if (sla-&gt;type() == SharedLibraryAtom::Type::Code)
        const_cast&lt;Reference &amp;&gt;(ref).setTarget(getPLTEntry(sla));
    } else
      return handleIFUNC(ref);
    return std::error_code();
  }

  std::error_code handlePLT32(const Reference &amp;ref) {
    // Turn this into a PC24 to the PLT entry.
    // Must move setKindValue() to below.
    // const_cast&lt;Reference &amp;&gt;(ref).setKindValue(R_CPU0_PC24);
    // Handle IFUNC.
    if (const DefinedAtom *da =
            dyn_cast_or_null&lt;const DefinedAtom&gt;(ref.target()))
      if (da-&gt;contentType() == DefinedAtom::typeResolver)
        return handleIFUNC(ref);
    if (isa&lt;const SharedLibraryAtom&gt;(ref.target()) ||
        isa&lt;UndefinedAtom&gt;(ref.target())) {
      const_cast&lt;Reference &amp;&gt;(ref).setTarget(getPLTEntry(ref.target()));
      // Turn this into a PC24 to the PLT entry.
    #if 1
      const_cast&lt;Reference &amp;&gt;(ref).setKindValue(R_CPU0_PC24);
    #endif
    }
    return std::error_code();
  }

  const GOTAtom *getSharedGOT(const Atom *a) {
    auto got = _gotMap.find(a);
    if (got == _gotMap.end()) {
      auto g = new (_file._alloc) Cpu0GOTAtom(_file, &quot;.got&quot;);
      g-&gt;addReferenceELF_Cpu0(R_CPU0_GLOB_DAT, 0, a, 0);
#ifndef NDEBUG
      g-&gt;_name = &quot;__got_&quot;;
      g-&gt;_name += a-&gt;name();
#endif
      _gotMap[a] = g;
      _gotVector.push_back(g);
      return g;
    }
    return got-&gt;second;
  }

  std::error_code handleGOT(const Reference &amp;ref) {
    if (const DefinedAtom *da = dyn_cast&lt;const DefinedAtom&gt;(ref.target()))
      const_cast&lt;Reference &amp;&gt;(ref).setTarget(getGOT(da));
    // Handle undefined atoms in the same way as shared lib atoms: to be
    // resolved at run time.
    else if (isa&lt;SharedLibraryAtom&gt;(ref.target()) ||
             isa&lt;UndefinedAtom&gt;(ref.target()))
      const_cast&lt;Reference &amp;&gt;(ref).setTarget(getSharedGOT(ref.target()));
    return std::error_code();
  }
};
#endif // DLINKER
} // end anon namespace

std::unique_ptr&lt;Pass&gt;
lld::elf::createCpu0RelocationPass(const Cpu0LinkingContext &amp;ctx) {
  switch (ctx.getOutputELFType()) {
  case llvm::ELF::ET_EXEC:
  // when the output file is execution file: e.g. a.out
#ifdef DLINKER
    if (ctx.isDynamic())
      return llvm::make_unique&lt;DynamicRelocationPass&gt;(ctx);
    else
      return std::unique_ptr&lt;Pass&gt;(new StaticRelocationPass(ctx));
#else
    return llvm::make_unique&lt;StaticRelocationPass&gt;(ctx);
#endif // DLINKER
#ifdef DLINKER
  case llvm::ELF::ET_DYN:
  // when the output file is shared object: e.g. foobar.so
    return llvm::make_unique&lt;DynamicRelocationPass&gt;(ctx);
#endif // DLINKER
  case llvm::ELF::ET_REL:
    return nullptr;
  default:
    llvm_unreachable(&quot;Unhandled output file type&quot;);
  }
}
</pre></div>
</div>
<p class="rubric">exlbt/lld/lib/ReaderWriter/ELF/Cpu0/Cpu0SectionChunks.h</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//===-</span> <span class="n">lib</span><span class="o">/</span><span class="n">ReaderWriter</span><span class="o">/</span><span class="n">ELF</span><span class="o">/</span><span class="n">Cpu0</span><span class="o">/</span><span class="n">Cpu0SectionChunks</span><span class="o">.</span><span class="n">h</span> <span class="o">----------------===//</span>
<span class="o">//</span>
<span class="o">//</span>                             <span class="n">The</span> <span class="n">LLVM</span> <span class="n">Linker</span>
<span class="o">//</span>
<span class="o">//</span> <span class="n">This</span> <span class="n">file</span> <span class="ow">is</span> <span class="n">distributed</span> <span class="n">under</span> <span class="n">the</span> <span class="n">University</span> <span class="n">of</span> <span class="n">Illinois</span> <span class="n">Open</span> <span class="n">Source</span>
<span class="o">//</span> <span class="n">License</span><span class="o">.</span> <span class="n">See</span> <span class="n">LICENSE</span><span class="o">.</span><span class="n">TXT</span> <span class="k">for</span> <span class="n">details</span><span class="o">.</span>
<span class="o">//</span>
<span class="o">//===----------------------------------------------------------------------===//</span>

<span class="c1">#ifndef LLD_READER_WRITER_ELF_CPU0_CPU0_SECTION_CHUNKS_H</span>
<span class="c1">#define LLD_READER_WRITER_ELF_CPU0_CPU0_SECTION_CHUNKS_H</span>

<span class="c1">#include &quot;TargetLayout.h&quot;</span>

<span class="n">namespace</span> <span class="n">lld</span> <span class="p">{</span>
<span class="n">namespace</span> <span class="n">elf</span> <span class="p">{</span>

<span class="n">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ELFT</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Cpu0GOTSection</span> <span class="p">:</span> <span class="n">public</span> <span class="n">AtomSection</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
  <span class="n">Cpu0GOTSection</span><span class="p">(</span><span class="n">const</span> <span class="n">ELFLinkingContext</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="p">);</span>

  <span class="nb">bool</span> <span class="n">hasGlobalGOTEntry</span><span class="p">(</span><span class="n">const</span> <span class="n">Atom</span> <span class="o">*</span><span class="n">a</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">_tlsMap</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">const</span> <span class="n">AtomLayout</span> <span class="o">*</span><span class="n">appendAtom</span><span class="p">(</span><span class="n">const</span> <span class="n">Atom</span> <span class="o">*</span><span class="n">atom</span><span class="p">)</span> <span class="n">override</span><span class="p">;</span>

<span class="n">private</span><span class="p">:</span>
  <span class="o">///</span> \<span class="n">brief</span> <span class="n">Map</span> <span class="n">TLS</span> <span class="n">Atoms</span> <span class="n">to</span> <span class="n">their</span> <span class="n">GOT</span> <span class="n">entry</span> <span class="n">index</span><span class="o">.</span>
  <span class="n">llvm</span><span class="p">::</span><span class="n">DenseMap</span><span class="o">&lt;</span><span class="n">const</span> <span class="n">Atom</span> <span class="o">*</span><span class="p">,</span> <span class="n">std</span><span class="p">::</span><span class="n">size_t</span><span class="o">&gt;</span> <span class="n">_tlsMap</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">}</span> <span class="o">//</span> <span class="n">elf</span>
<span class="p">}</span> <span class="o">//</span> <span class="n">lld</span>

<span class="c1">#endif</span>
</pre></div>
</div>
<p class="rubric">exlbt/lld/lib/ReaderWriter/ELF/Cpu0/Cpu0SectionChunks.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//===-</span> <span class="n">lib</span><span class="o">/</span><span class="n">ReaderWriter</span><span class="o">/</span><span class="n">ELF</span><span class="o">/</span><span class="n">Cpu0</span><span class="o">/</span><span class="n">Cpu0SectionChunks</span><span class="o">.</span><span class="n">cpp</span> <span class="o">--------------===//</span>
<span class="o">//</span>
<span class="o">//</span>                             <span class="n">The</span> <span class="n">LLVM</span> <span class="n">Linker</span>
<span class="o">//</span>
<span class="o">//</span> <span class="n">This</span> <span class="n">file</span> <span class="ow">is</span> <span class="n">distributed</span> <span class="n">under</span> <span class="n">the</span> <span class="n">University</span> <span class="n">of</span> <span class="n">Illinois</span> <span class="n">Open</span> <span class="n">Source</span>
<span class="o">//</span> <span class="n">License</span><span class="o">.</span> <span class="n">See</span> <span class="n">LICENSE</span><span class="o">.</span><span class="n">TXT</span> <span class="k">for</span> <span class="n">details</span><span class="o">.</span>
<span class="o">//</span>
<span class="o">//===----------------------------------------------------------------------===//</span>

<span class="c1">#include &quot;Cpu0SectionChunks.h&quot;</span>
<span class="c1">#include &quot;TargetLayout.h&quot;</span>

<span class="n">namespace</span> <span class="n">lld</span> <span class="p">{</span>
<span class="n">namespace</span> <span class="n">elf</span> <span class="p">{</span>

<span class="n">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ELFT</span><span class="o">&gt;</span> <span class="n">Cpu0GOTSection</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;</span><span class="p">::</span><span class="n">Cpu0GOTSection</span><span class="p">(</span><span class="n">const</span> <span class="n">ELFLinkingContext</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="p">)</span>
  <span class="p">:</span> <span class="n">AtomSection</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="s2">&quot;.got&quot;</span><span class="p">,</span> <span class="n">DefinedAtom</span><span class="p">::</span><span class="n">typeGOT</span><span class="p">,</span> <span class="n">DefinedAtom</span><span class="p">::</span><span class="n">permRW_</span><span class="p">,</span>
    <span class="n">TargetLayout</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;</span><span class="p">::</span><span class="n">ORDER_GOT</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">this</span><span class="o">-&gt;</span><span class="n">_alignment</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ELFT</span><span class="o">&gt;</span> <span class="n">const</span> <span class="n">AtomLayout</span> <span class="o">*</span><span class="n">Cpu0GOTSection</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;</span><span class="p">::</span><span class="n">appendAtom</span><span class="p">(</span><span class="n">const</span> <span class="n">Atom</span> <span class="o">*</span><span class="n">atom</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">AtomSection</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;</span><span class="p">::</span><span class="n">appendAtom</span><span class="p">(</span><span class="n">atom</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">template</span> <span class="k">class</span> <span class="nc">Cpu0GOTSection</span><span class="o">&lt;</span><span class="n">ELF32BE</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">template</span> <span class="k">class</span> <span class="nc">Cpu0GOTSection</span><span class="o">&lt;</span><span class="n">ELF32LE</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span> <span class="o">//</span> <span class="n">elf</span>
<span class="p">}</span> <span class="o">//</span> <span class="n">lld</span>
</pre></div>
</div>
<p class="rubric">exlbt/lld/lib/ReaderWriter/ELF/Cpu0/Cpu0TargetHandler.h</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>//===- lib/ReaderWriter/ELF/Cpu0/Cpu0TargetHandler.h ------------------===//
//
//                             The LLVM Linker
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#ifndef LLD_READER_WRITER_ELF_CPU0_CPU0_TARGET_HANDLER_H
#define LLD_READER_WRITER_ELF_CPU0_CPU0_TARGET_HANDLER_H

#include &quot;ELFReader.h&quot;
#include &quot;TargetLayout.h&quot;
#include &quot;Cpu0LinkingContext.h&quot;
#include &quot;Cpu0RelocationHandler.h&quot;
#include &quot;Cpu0SectionChunks.h&quot;
#include &quot;lld/Core/Simple.h&quot;
#include &quot;llvm/Support/Endian.h&quot;

using namespace llvm::support;

#define DLINKER

namespace lld {
namespace elf {

#ifdef DLINKER
template &lt;class ELFT&gt; 
class Cpu0SoPlt {
private:
  uint32_t funAddr[100];
  int funAddrSize = 0;
public:
  void createFunAddr(Cpu0TargetLayout&lt;ELFT&gt; &amp;cpu0Layout,
                     llvm::FileOutputBuffer &amp;buf);
  // Return function index, 1: 1st function appear on section .text of .so.
  //   2: 2nd function ...
  // For example: 3 functions _Z2laii, _Z3fooii and _Z3barv. 1: is _Z2laii 
  //   2 is _Z3fooii, 3: is _Z3barv.
  int getDynFunIndexByTargetAddr(uint64_t fAddr);
};
#endif

template &lt;class ELFT&gt; class Cpu0TargetLayout : public TargetLayout&lt;ELFT&gt; {
public:
  Cpu0TargetLayout(Cpu0LinkingContext &amp;ctx) : TargetLayout&lt;ELFT&gt;(ctx),
    _gotSection(new (this-&gt;_allocator) Cpu0GOTSection&lt;ELFT&gt;(ctx)) {}

  AtomSection&lt;ELFT&gt; *
  createSection(StringRef name, int32_t type,
                DefinedAtom::ContentPermissions permissions,
                typename TargetLayout&lt;ELFT&gt;::SectionOrder order) override {
    if (type == DefinedAtom::typeGOT &amp;&amp; name == &quot;.got&quot;)
      return _gotSection;
    return TargetLayout&lt;ELFT&gt;::createSection(name, type, permissions, order);
  }

  void finalizeOutputSectionLayout() override {
    sortOutputSectionByPriority&lt;ELFT&gt;(&quot;.init_array&quot;);
    sortOutputSectionByPriority&lt;ELFT&gt;(&quot;.fini_array&quot;);
  }

 const Cpu0GOTSection&lt;ELFT&gt; &amp;getGOTSection() const { return *_gotSection; }

private:
  uint32_t getPriority(StringRef sectionName) const {
    StringRef priority = sectionName.drop_front().rsplit(&#39;.&#39;).second;
    uint32_t prio;
    if (priority.getAsInteger(10, prio))
      return std::numeric_limits&lt;uint32_t&gt;::max();
    return prio;
  }

  template &lt;typename T&gt; void sortOutputSectionByPriority(StringRef prefix) {
    OutputSection&lt;T&gt; *section = Cpu0TargetLayout&lt;ELFT&gt;::findOutputSection(prefix);
    if (!section)
      return;
    auto sections = section-&gt;sections();
    std::sort(sections.begin(), sections.end(),
              [&amp;](Chunk&lt;T&gt; *lhs, Chunk&lt;T&gt; *rhs) {
                Section&lt;T&gt; *lhsSection = dyn_cast&lt;Section&lt;T&gt;&gt;(lhs);
                Section&lt;T&gt; *rhsSection = dyn_cast&lt;Section&lt;T&gt;&gt;(rhs);
                if (!lhsSection || !rhsSection)
                  return false;
                StringRef lhsName = lhsSection-&gt;inputSectionName();
                StringRef rhsName = rhsSection-&gt;inputSectionName();
                if (!lhsName.startswith(prefix) || !rhsName.startswith(prefix))
                  return false;
                return getPriority(lhsName) &lt; getPriority(rhsName);
              });
  }

private:
  Cpu0GOTSection&lt;ELFT&gt; *_gotSection;
};

template &lt;class ELFT&gt; class Cpu0TargetHandler : public TargetHandler {
public:
  Cpu0TargetHandler(Cpu0LinkingContext &amp;ctx, endianness endian);

  const TargetRelocationHandler &amp;getRelocationHandler() const override {
    return *_relocationHandler;
  }

  std::unique_ptr&lt;Reader&gt; getObjReader() override {
    return llvm::make_unique&lt;ELFReader&lt;ELFFile&lt;ELFT&gt;&gt;&gt;(_ctx);
  }

  std::unique_ptr&lt;Reader&gt; getDSOReader() override {
    return llvm::make_unique&lt;ELFReader&lt;DynamicFile&lt;ELFT&gt;&gt;&gt;(_ctx);
  }

  std::unique_ptr&lt;Writer&gt; getWriter() override;

#ifdef DLINKER
  Cpu0SoPlt&lt;ELFT&gt; soPlt;
#endif
protected:
  Cpu0LinkingContext &amp;_ctx;
  std::unique_ptr&lt;Cpu0TargetLayout&lt;ELFT&gt;&gt; _targetLayout;
  std::unique_ptr&lt;Cpu0TargetRelocationHandler&lt;ELFT&gt;&gt; _relocationHandler;
};

} // end namespace elf
} // end namespace lld

#endif
</pre></div>
</div>
<p class="rubric">exlbt/lld/Cpu0/lib/ReaderWriter/ELF/Cpu0TargetHandler.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//===-</span> <span class="n">lib</span><span class="o">/</span><span class="n">ReaderWriter</span><span class="o">/</span><span class="n">ELF</span><span class="o">/</span><span class="n">Cpu0</span><span class="o">/</span><span class="n">Cpu0TargetHandler</span><span class="o">.</span><span class="n">cpp</span> <span class="o">----------------===//</span>
<span class="o">//</span>
<span class="o">//</span>                             <span class="n">The</span> <span class="n">LLVM</span> <span class="n">Linker</span>
<span class="o">//</span>
<span class="o">//</span> <span class="n">This</span> <span class="n">file</span> <span class="ow">is</span> <span class="n">distributed</span> <span class="n">under</span> <span class="n">the</span> <span class="n">University</span> <span class="n">of</span> <span class="n">Illinois</span> <span class="n">Open</span> <span class="n">Source</span>
<span class="o">//</span> <span class="n">License</span><span class="o">.</span> <span class="n">See</span> <span class="n">LICENSE</span><span class="o">.</span><span class="n">TXT</span> <span class="k">for</span> <span class="n">details</span><span class="o">.</span>
<span class="o">//</span>
<span class="o">//===----------------------------------------------------------------------===//</span>

<span class="c1">#include &quot;Atoms.h&quot;</span>
<span class="c1">#include &quot;Cpu0DynamicLibraryWriter.h&quot;</span>
<span class="c1">#include &quot;Cpu0ExecutableWriter.h&quot;</span>
<span class="c1">#include &quot;Cpu0LinkingContext.h&quot;</span>
<span class="c1">#include &quot;Cpu0TargetHandler.h&quot;</span>

<span class="n">endianness</span> <span class="n">gEndian</span> <span class="o">=</span> <span class="n">native</span><span class="p">;</span>

<span class="n">namespace</span> <span class="n">lld</span> <span class="p">{</span>
<span class="n">namespace</span> <span class="n">elf</span> <span class="p">{</span>

<span class="c1">#ifdef DLINKER</span>
<span class="n">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ELFT</span><span class="o">&gt;</span>
<span class="n">void</span> <span class="n">Cpu0SoPlt</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;</span><span class="p">::</span><span class="n">createFunAddr</span><span class="p">(</span><span class="n">Cpu0TargetLayout</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">cpu0Layout</span><span class="p">,</span>
                              <span class="n">llvm</span><span class="p">::</span><span class="n">FileOutputBuffer</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">auto</span> <span class="n">dynsymSection</span> <span class="o">=</span> <span class="n">cpu0Layout</span><span class="o">.</span>
                       <span class="n">findOutputSection</span><span class="p">(</span><span class="s2">&quot;.dynsym&quot;</span><span class="p">);</span>
  <span class="n">uint64_t</span> <span class="n">dynsymFileOffset</span><span class="p">,</span> <span class="n">dynsymSize</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">dynsymSection</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">dynsymFileOffset</span> <span class="o">=</span> <span class="n">dynsymSection</span><span class="o">-&gt;</span><span class="n">fileOffset</span><span class="p">();</span>
    <span class="n">dynsymSize</span> <span class="o">=</span> <span class="n">dynsymSection</span><span class="o">-&gt;</span><span class="n">memSize</span><span class="p">();</span>
    <span class="n">uint8_t</span> <span class="o">*</span><span class="n">atomContent</span> <span class="o">=</span> <span class="n">buf</span><span class="o">.</span><span class="n">getBufferStart</span><span class="p">()</span> <span class="o">+</span> <span class="n">dynsymFileOffset</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">uint64_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dynsymSize</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">16</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">funAddr</span><span class="p">[</span><span class="n">funAddrSize</span><span class="p">]</span> <span class="o">=</span> 
        <span class="o">*</span><span class="n">reinterpret_cast</span><span class="o">&lt;</span><span class="n">llvm</span><span class="p">::</span><span class="n">support</span><span class="p">::</span><span class="n">ubig32_t</span><span class="o">*&gt;</span><span class="p">((</span><span class="n">uint32_t</span><span class="o">*</span><span class="p">)</span>
        <span class="p">(</span><span class="n">atomContent</span> <span class="o">+</span> <span class="n">i</span><span class="p">));</span>
      <span class="n">funAddrSize</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ELFT</span><span class="o">&gt;</span>
<span class="nb">int</span> <span class="n">Cpu0SoPlt</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;</span><span class="p">::</span><span class="n">getDynFunIndexByTargetAddr</span><span class="p">(</span><span class="n">uint64_t</span> <span class="n">fAddr</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">funAddrSize</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">//</span> <span class="n">Below</span> <span class="n">statement</span> <span class="n">fix</span> <span class="n">the</span> <span class="n">issue</span> <span class="n">that</span> <span class="n">both</span> <span class="n">__tls_get_addr</span> <span class="ow">and</span> <span class="n">first</span> 
    <span class="o">//</span> <span class="n">function</span> <span class="n">has</span> <span class="n">the</span> <span class="n">same</span> <span class="n">file</span> <span class="n">offset</span> <span class="mi">0</span> <span class="n">issue</span><span class="o">.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">funAddrSize</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">funAddr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">funAddr</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
      <span class="k">continue</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">fAddr</span> <span class="o">==</span> <span class="n">funAddr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">template</span> <span class="k">class</span> <span class="nc">Cpu0SoPlt</span><span class="o">&lt;</span><span class="n">ELF32BE</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">template</span> <span class="k">class</span> <span class="nc">Cpu0SoPlt</span><span class="o">&lt;</span><span class="n">ELF32LE</span><span class="o">&gt;</span><span class="p">;</span>
<span class="c1">#endif // DLINKER</span>

<span class="n">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ELFT</span><span class="o">&gt;</span>
<span class="n">Cpu0TargetHandler</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;</span><span class="p">::</span><span class="n">Cpu0TargetHandler</span><span class="p">(</span><span class="n">Cpu0LinkingContext</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="p">,</span> 
                                           <span class="n">endianness</span> <span class="n">endian</span><span class="p">)</span>
    <span class="p">:</span> <span class="n">_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">),</span> <span class="n">_targetLayout</span><span class="p">(</span><span class="n">new</span> <span class="n">Cpu0TargetLayout</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ctx</span><span class="p">)),</span>
      <span class="n">_relocationHandler</span><span class="p">(</span><span class="n">new</span> <span class="n">Cpu0TargetRelocationHandler</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;</span>
                         <span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">*</span><span class="n">_targetLayout</span><span class="p">,</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span> <span class="n">endian</span><span class="p">))</span> <span class="p">{</span>
  <span class="n">gEndian</span> <span class="o">=</span> <span class="n">endian</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ELFT</span><span class="o">&gt;</span>
<span class="n">std</span><span class="p">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Writer</span><span class="o">&gt;</span> <span class="n">Cpu0TargetHandler</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;</span><span class="p">::</span><span class="n">getWriter</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">switch</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">_ctx</span><span class="o">.</span><span class="n">getOutputELFType</span><span class="p">())</span> <span class="p">{</span>
  <span class="n">case</span> <span class="n">llvm</span><span class="p">::</span><span class="n">ELF</span><span class="p">::</span><span class="n">ET_EXEC</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">llvm</span><span class="p">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Cpu0ExecutableWriter</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">_ctx</span><span class="p">,</span> <span class="o">*</span><span class="n">_targetLayout</span><span class="p">);</span>
  <span class="n">case</span> <span class="n">llvm</span><span class="p">::</span><span class="n">ELF</span><span class="p">::</span><span class="n">ET_DYN</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">llvm</span><span class="p">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Cpu0DynamicLibraryWriter</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">_ctx</span><span class="p">,</span> <span class="o">*</span><span class="n">_targetLayout</span><span class="p">);</span>
  <span class="n">case</span> <span class="n">llvm</span><span class="p">::</span><span class="n">ELF</span><span class="p">::</span><span class="n">ET_REL</span><span class="p">:</span>
    <span class="n">llvm_unreachable</span><span class="p">(</span><span class="s2">&quot;TODO: support -r mode&quot;</span><span class="p">);</span>
  <span class="n">default</span><span class="p">:</span>
    <span class="n">llvm_unreachable</span><span class="p">(</span><span class="s2">&quot;unsupported output type&quot;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="n">template</span> <span class="k">class</span> <span class="nc">Cpu0TargetHandler</span><span class="o">&lt;</span><span class="n">ELF32BE</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">template</span> <span class="k">class</span> <span class="nc">Cpu0TargetHandler</span><span class="o">&lt;</span><span class="n">ELF32LE</span><span class="o">&gt;</span><span class="p">;</span>

<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Above code in Cpu0 lld support both endian for static link and dynamic link.
The &#8220;#ifdef DLINKER&#8221; is for dynamic link support.</p>
</div>
<div class="section" id="lld-introduction">
<h3><a class="toc-backref" href="#id37">LLD introduction</a><a class="headerlink" href="#lld-introduction" title="Permalink to this headline">¶</a></h3>
<p>In general, linker do the Relocation Records Resolve as Chapter ELF support
depicted, and optimization for those cannot finish in compiler stage. One of
the optimization opportunities in linker is Dead Code Stripping which is
explained in this section.</p>
<p>List the LLD project status as follows,</p>
<ul class="simple">
<li>The lld project aims to to be the built-in linker for clang/llvm.
Currently, clang must invoke the system linker to produce executables.</li>
<li>web site <a class="reference external" href="http://lld.llvm.org/">http://lld.llvm.org/</a></li>
<li>Current Status<ul>
<li>lld is in its early stages of development.</li>
<li>It can currently self host on Linux x86-64 with -static.</li>
</ul>
</li>
<li>How to build<ul>
<li>cmake -DCMAKE_CXX_COMPILER=g++ -DCMAKE_C_COMPILER=gcc -DCMAKE_CXX_FLAGS=-std
=c++11 -DCMAKE_BUILD_TYPE=Debug -G &#8220;Unix Makefiles&#8221; ../src/</li>
</ul>
</li>
</ul>
<p>This whole book focuses on backend design, and this chapter is same.
To help readers
understand the lld document, first we list the linking steps from lld web.
After that, explain each step with the class of source code and what kind of
Cpu0 backend implementation needed in each step.
Since some of the following come from our understanding,
please read the lld design web document first (only a few pages),
<a class="reference external" href="http://lld.llvm.org/design.html">http://lld.llvm.org/design.html</a>, then reading the following to
ensure you agree to our understanding.</p>
<div class="section" id="how-lld-do-the-linker-job">
<h4><a class="toc-backref" href="#id38">How LLD do the linker job</a><a class="headerlink" href="#how-lld-do-the-linker-job" title="Permalink to this headline">¶</a></h4>
<ul>
<li><p class="first">LLD structure</p>
<ul class="simple">
<li>Internal structure Atom<ul>
<li>Like llvm IR, lld operating and optimize in Atom.</li>
</ul>
</li>
<li>ELF reader/writer, Mach-O reader/writer, COFF<ul>
<li>Connect to any specific linker format by implement the concrete Read/Writer.</li>
<li>e.g. Implement Microsoft link format Reader/Writer
=&gt; extend lld to support Microsoft link format.</li>
</ul>
</li>
</ul>
</li>
<li><p class="first">Atom</p>
<ul class="simple">
<li>An atom is an indivisible chunk of code or data.</li>
<li>Typically each user written function or global variable is an atom.</li>
<li>In addition, the compiler may emit other atoms, such as for literal c-strings
or floating point constants, or for runtime data structures like dwarf unwind
info or pointers to initializers.</li>
</ul>
</li>
<li><p class="first">Atoms classified:</p>
<ul class="simple">
<li>The following Hello World code can be classified with these different kinds of
Atoms as follows,</li>
</ul>
<p class="rubric">Atom example code</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">extern</span> <span class="kt">int</span> <span class="nf">printf</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">format</span><span class="p">,</span> <span class="p">...);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="s">&quot;Hello world!&quot;</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li>DefinedAtom<ul>
<li>95% of all atoms. This is a chunk of code or data</li>
</ul>
</li>
<li>UndefinedAtom<ul>
<li>printf in this example.</li>
</ul>
</li>
<li>SharedLibraryAtom<ul>
<li>Symbols defined in shared library (file *.so).</li>
</ul>
</li>
<li>AbsoluteAtom<ul>
<li>This is for embedded support where some stuff is implemented in ROM at some
fixed address.</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="figure align-center" id="id20">
<span id="lld-atom"></span><a class="reference internal image-reference" href="_images/atom.png"><img alt="_images/atom.png" src="_images/atom.png" style="width: 386.0px; height: 417.0px;" /></a>
<p class="caption"><span class="caption-number">Fig. 3 </span><span class="caption-text">Atom classified (from lld web)</span></p>
</div>
</div>
<div class="section" id="linking-steps">
<h4><a class="toc-backref" href="#id39">Linking Steps</a><a class="headerlink" href="#linking-steps" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>Command line processing<ul>
<li>lld -flavor gnu -target cpu0-unknown-linux-gnu hello.o printf-stdarg.o -o a.out</li>
</ul>
</li>
<li>Parsing input files<ul>
<li>ELF reader =&gt; create lld:File</li>
</ul>
</li>
<li>Resolving<ul>
<li>dead code stripping</li>
</ul>
</li>
<li>Passes/Optimizations<ul>
<li>Like llvm passes, give backend a chance to do something like optimization.</li>
</ul>
</li>
<li>Generate output file<ul>
<li>Resolving Relocation Records – I guess in this step</li>
</ul>
</li>
</ul>
<div class="section" id="command-line-processing">
<h5><a class="toc-backref" href="#id40">Command line processing</a><a class="headerlink" href="#command-line-processing" title="Permalink to this headline">¶</a></h5>
<p>To support a new backend, refer to Cpu0 code added above.</p>
</div>
<div class="section" id="parsing-input-files">
<h5><a class="toc-backref" href="#id41">Parsing input files</a><a class="headerlink" href="#parsing-input-files" title="Permalink to this headline">¶</a></h5>
<ul class="simple">
<li>Input Files<ul>
<li>A goal of lld is to be file format independent.</li>
<li>The lld::Reader is the base class for all object file readers</li>
<li>Every Reader subclass defines its own “options” class (for instance the
mach-o Reader defines the class ReaderOptionsMachO). This options class is
the one-and-only way to control how the Reader operates when parsing an input
file into an Atom graph</li>
</ul>
</li>
<li>Reader<ul>
<li>Refer lld/lib/ReaderWriter/ELF/Reader.cpp and it&#8217;s related files since lld
change quickly.</li>
</ul>
</li>
<li>lld::File representations<ul>
<li>In memory, abstract C++ classes (lld::Atom, lld::Reference, and lld::File).<ul>
<li>Data structure keeped in memory to be fast</li>
</ul>
</li>
<li>textual (in YAML)<ul>
<li>target-triple:   x86_64-apple-darwin11</li>
<li>atoms:<ul>
<li>name:    _main</li>
<li>scope:   global</li>
<li>type:    code</li>
<li>content: [ 55, 48, 89, e5, 48, 8d, 3d, 00, 00, 00, 00, 30, c0, e8, 00, 00,
00, 00, 31, c0, 5d, c3 ]</li>
</ul>
</li>
</ul>
</li>
<li>binary format (“native”)<ul>
<li>With this model for the native file format, files can be read and turned
into the in-memory graph of lld::Atoms with just a few memory allocations.
And the format can easily adapt over time to new features.</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="resolving">
<h5><a class="toc-backref" href="#id42">Resolving</a><a class="headerlink" href="#resolving" title="Permalink to this headline">¶</a></h5>
<ul class="simple">
<li>Dead code stripping (if requested) is done at the end of resolving.</li>
<li>The linker does a simple mark-and-sweep. It starts with <strong>“root”</strong> atoms (like
“main” in a main executable) and follows each references and marks each Atom
that it visits as <strong>“live”</strong>.</li>
<li>When done, all atoms not marked <strong>“live”</strong> are removed.</li>
</ul>
<p class="rubric">Dead code stripping - example (modified from llvm lto document web)</p>
<p class="rubric">a.h</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">extern</span> <span class="nb">int</span> <span class="n">foo1</span><span class="p">(</span><span class="n">void</span><span class="p">);</span>
<span class="n">extern</span> <span class="n">void</span> <span class="n">foo2</span><span class="p">(</span><span class="n">void</span><span class="p">);</span>
<span class="n">extern</span> <span class="nb">int</span> <span class="n">foo4</span><span class="p">(</span><span class="n">void</span><span class="p">);</span>

</pre></div>
</div>
<p class="rubric">a.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1">#include &quot;a.h&quot;</span>

<span class="n">static</span> <span class="n">signed</span> <span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="n">void</span> <span class="n">foo2</span><span class="p">(</span><span class="n">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">static</span> <span class="nb">int</span> <span class="n">foo3</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="mi">10</span><span class="o">+</span><span class="n">foo4</span><span class="p">());</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">foo1</span><span class="p">(</span><span class="n">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="nb">int</span> <span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">foo3</span><span class="p">();</span>

  <span class="n">data</span> <span class="o">=</span> <span class="n">data</span> <span class="o">+</span> <span class="mi">42</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>

</pre></div>
</div>
<p class="rubric">ch13_1.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1">#include &quot;a.h&quot;</span>

<span class="n">void</span> <span class="n">ISR</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">asm</span><span class="p">(</span><span class="s2">&quot;ISR:&quot;</span><span class="p">);</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">foo4</span><span class="p">(</span><span class="n">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="mi">5</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">foo1</span><span class="p">();</span>
<span class="p">}</span>

</pre></div>
</div>
<p>Above code can be reduced to <a class="reference internal" href="#lld-deadcodestripping"><span class="std std-numref">Fig. 4</span></a> to perform
mark and swip in graph for Dead Code Stripping.</p>
<div class="figure align-center" id="id21">
<span id="lld-deadcodestripping"></span><a class="reference internal image-reference" href="_images/deadcodestripping.png"><img alt="_images/deadcodestripping.png" src="_images/deadcodestripping.png" style="width: 144.4px; height: 270.8px;" /></a>
<p class="caption"><span class="caption-number">Fig. 4 </span><span class="caption-text">Atom classified (from lld web)</span></p>
</div>
<p>As above example, the foo2() is an isolated node without any reference. It&#8217;s
dead code and can be removed in linker optimization. We test this example by
build-ch13_1.sh and find foo2() cannot be removed.
There are two possibilities for this situation.
One is we do not trigger lld dead code stripping
optimization in command (the default is not do it). The other is lld hasn&#8217;t
implemented it yet at this point. It&#8217;s reasonable since the
lld is in its early stages of development. We didn&#8217;t dig it more, since the
Cpu0 backend tutorial just need a linker to finish Relocation Records Resolve
and see how it runs on PC.</p>
<p>Remind, llvm-linker is the linker works on IR level linker optimization.
Sometime when you got the obj file only (if you have a.o in this case),
the native linker (such as lld) have the opportunity to do Dead Code Stripping
while the IR linker hasn&#8217;t.</p>
</div>
<div class="section" id="passes-optimizations">
<h5><a class="toc-backref" href="#id43">Passes/Optimizations</a><a class="headerlink" href="#passes-optimizations" title="Permalink to this headline">¶</a></h5>
<ul class="simple">
<li>Passes<ul>
<li>stub (PLT) generation</li>
<li>GOT instantiation</li>
<li>order_file optimization</li>
<li>branch island generation</li>
<li>branch shim generation</li>
<li>Objective-C optimizations (Darwin specific)</li>
<li>TLV instantiation (Darwin specific)</li>
<li>DTrace probe processing (Darwin specific)</li>
<li>compact unwind encoding (Darwin specific)</li>
</ul>
</li>
</ul>
<p>The Cpu0RelocationPass.cpp and Cpu0RelocationPass.h are example codes for lld
backend Passes. The Relocation Pass structure shown as <a class="reference internal" href="#lld-f3"><span class="std std-numref">Fig. 5</span></a>.
The Cpu0 backend has two Relocation Passes and both of them are children of
RelocationPass. The StaticRelocationPass is for static linker and
DynamicRelocationPass is for dynamic linker. We will see how to register a
relocation pass according the staic or dynamic linker you like to do in
next section.</p>
<div class="figure align-center" id="id22">
<span id="lld-f3"></span><a class="reference internal image-reference" href="_images/3.png"><img alt="_images/3.png" src="_images/3.png" style="width: 833.0px; height: 726.0px;" /></a>
<p class="caption"><span class="caption-number">Fig. 5 </span><span class="caption-text">Cpu0 lld RelocationPass</span></p>
</div>
<p>All lld backends which want to handle the Relocation
Records Resolve need to register a pass when the lld backend code is up.
After register the pass, LLD will do last two
steps, Passes/Optimization and Generate Output file, interactivly just like the
&#8220;Parsing and Generating code&#8221; in compiler.
LLD will do Passes/Optimization and call your
lld backend hook function &#8220;applyRelocation()&#8221; (defined in
Cpu0TargetRelocationHandler.cpp) to finish the address binding in linker stage.
Based on this understanding, we believe the &#8220;applyRelocation()&#8221; is at the step
of Generate output file rather than Passes/Optimization even LLD web document
didn&#8217;t indicate this.</p>
<p>The following code will register a pass when the lld backend code is up.</p>
<p class="rubric">exlbt/lld/lib/ReaderWriter/ELF/Cpu0/Cpu0RelocationPass.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>
<span class="n">std</span><span class="p">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Pass</span><span class="o">&gt;</span>
<span class="n">lld</span><span class="p">::</span><span class="n">elf</span><span class="p">::</span><span class="n">createCpu0RelocationPass</span><span class="p">(</span><span class="n">const</span> <span class="n">Cpu0LinkingContext</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">switch</span> <span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">getOutputELFType</span><span class="p">())</span> <span class="p">{</span>
  <span class="n">case</span> <span class="n">llvm</span><span class="p">::</span><span class="n">ELF</span><span class="p">::</span><span class="n">ET_EXEC</span><span class="p">:</span>
  <span class="o">//</span> <span class="n">when</span> <span class="n">the</span> <span class="n">output</span> <span class="n">file</span> <span class="ow">is</span> <span class="n">execution</span> <span class="n">file</span><span class="p">:</span> <span class="n">e</span><span class="o">.</span><span class="n">g</span><span class="o">.</span> <span class="n">a</span><span class="o">.</span><span class="n">out</span>
<span class="c1">#ifdef DLINKER</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">isDynamic</span><span class="p">())</span>
      <span class="k">return</span> <span class="n">llvm</span><span class="p">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">DynamicRelocationPass</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
    <span class="k">else</span>
      <span class="k">return</span> <span class="n">std</span><span class="p">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Pass</span><span class="o">&gt;</span><span class="p">(</span><span class="n">new</span> <span class="n">StaticRelocationPass</span><span class="p">(</span><span class="n">ctx</span><span class="p">));</span>
<span class="c1">#else</span>
    <span class="k">return</span> <span class="n">llvm</span><span class="p">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">StaticRelocationPass</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
<span class="c1">#endif // DLINKER</span>
<span class="c1">#ifdef DLINKER</span>
  <span class="n">case</span> <span class="n">llvm</span><span class="p">::</span><span class="n">ELF</span><span class="p">::</span><span class="n">ET_DYN</span><span class="p">:</span>
  <span class="o">//</span> <span class="n">when</span> <span class="n">the</span> <span class="n">output</span> <span class="n">file</span> <span class="ow">is</span> <span class="n">shared</span> <span class="nb">object</span><span class="p">:</span> <span class="n">e</span><span class="o">.</span><span class="n">g</span><span class="o">.</span> <span class="n">foobar</span><span class="o">.</span><span class="n">so</span>
    <span class="k">return</span> <span class="n">llvm</span><span class="p">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">DynamicRelocationPass</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
<span class="c1">#endif // DLINKER</span>
  <span class="n">case</span> <span class="n">llvm</span><span class="p">::</span><span class="n">ELF</span><span class="p">::</span><span class="n">ET_REL</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">nullptr</span><span class="p">;</span>
  <span class="n">default</span><span class="p">:</span>
    <span class="n">llvm_unreachable</span><span class="p">(</span><span class="s2">&quot;Unhandled output file type&quot;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="generate-output-file">
<h5><a class="toc-backref" href="#id44">Generate Output File</a><a class="headerlink" href="#generate-output-file" title="Permalink to this headline">¶</a></h5>
<ul class="simple">
<li>All concrete writers (e.g. ELF, mach-o, etc) are subclasses of the lld::Writer
class.</li>
<li>Every Writer subclass defines its own “options” class (for instance the mach-o
Writer defines the class WriterOptionsMachO). This options class is the
one-and-only way to control how the Writer operates when producing an output
file from an Atom graph.</li>
<li>Writer<ul>
<li>Refer lld/lib/ReaderWriter/ELF/Writer.cpp and it&#8217;s related files since lld
change quickly.</li>
</ul>
</li>
</ul>
<p>After register a relocation pass, lld backend hook function &#8220;applyRelocation()&#8221;
will be called by lld driver to finish the address binding in linker stage.</p>
<p class="rubric">exlbt/lld/lib/ReaderWriter/ELF/Cpu0/Cpu0RelocationHandler.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ELFT</span><span class="o">&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">error_code</span> <span class="n">Cpu0TargetRelocationHandler</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;::</span><span class="n">applyRelocation</span><span class="p">(</span>
    <span class="n">ELFWriter</span> <span class="o">&amp;</span><span class="n">writer</span><span class="p">,</span> <span class="n">llvm</span><span class="o">::</span><span class="n">FileOutputBuffer</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="n">AtomLayout</span> <span class="o">&amp;</span><span class="n">atom</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">Reference</span> <span class="o">&amp;</span><span class="n">ref</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">atomContent</span> <span class="o">=</span> <span class="n">buf</span><span class="p">.</span><span class="n">getBufferStart</span><span class="p">()</span> <span class="o">+</span> <span class="n">atom</span><span class="p">.</span><span class="n">_fileOffset</span><span class="p">;</span>
  <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">loc</span> <span class="o">=</span> <span class="n">atomContent</span> <span class="o">+</span> <span class="n">ref</span><span class="p">.</span><span class="n">offsetInAtom</span><span class="p">();</span>
  <span class="kt">uint64_t</span> <span class="n">target</span> <span class="o">=</span> <span class="n">writer</span><span class="p">.</span><span class="n">addressOfAtom</span><span class="p">(</span><span class="n">ref</span><span class="p">.</span><span class="n">target</span><span class="p">());</span>
  <span class="kt">uint64_t</span> <span class="n">reloc</span> <span class="o">=</span> <span class="n">atom</span><span class="p">.</span><span class="n">_virtualAddr</span> <span class="o">+</span> <span class="n">ref</span><span class="p">.</span><span class="n">offsetInAtom</span><span class="p">();</span>
  <span class="p">...</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">ref</span><span class="p">.</span><span class="n">kind</span><span class="p">())</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nl">R_CPU0_NONE</span><span class="p">:</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="nl">R_CPU0_HI16</span><span class="p">:</span>
    <span class="n">relocHI16</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">reloc</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">ref</span><span class="p">.</span><span class="n">addend</span><span class="p">(),</span> <span class="n">_endian</span><span class="p">);</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="nl">R_CPU0_LO16</span><span class="p">:</span>
    <span class="n">relocLO16</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">reloc</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">ref</span><span class="p">.</span><span class="n">addend</span><span class="p">(),</span> <span class="n">_endian</span><span class="p">);</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="p">...</span>
  <span class="k">case</span> <span class="nl">R_CPU0_PC24</span><span class="p">:</span>
    <span class="n">relocPC24</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">reloc</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">ref</span><span class="p">.</span><span class="n">addend</span><span class="p">(),</span> <span class="n">_endian</span><span class="p">);</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="p">...</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">error_code</span><span class="o">::</span><span class="n">success</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">exlbt/input/ch_hello.c</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">extern</span> <span class="nb">int</span> <span class="n">printf</span><span class="p">(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="nb">format</span><span class="p">,</span> <span class="o">...</span><span class="p">);</span>

<span class="nb">int</span> <span class="n">main</span><span class="p">(</span><span class="n">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">char</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="s2">&quot;Hello world!&quot;</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
<span class="p">}</span>

</pre></div>
</div>
<p class="rubric">exlbt/input/build-hello.sh</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>#!/usr/bin/env bash

source functions.sh

sh_name=build-hello.sh
argNum=$#
arg1=$1
arg2=$2

prologue;

clang -target mips-unknown-linux-gnu -c start.cpp -emit-llvm -o start.bc
clang -target mips-unknown-linux-gnu -c debug.cpp -emit-llvm -o debug.bc
clang -target mips-unknown-linux-gnu -c printf-stdarg-def.c -emit-llvm \
-o printf-stdarg-def.bc
clang -target mips-unknown-linux-gnu -c printf-stdarg.c -emit-llvm \
-o printf-stdarg.bc
clang -target mips-unknown-linux-gnu -c ch_hello.c -emit-llvm -o ch_hello.bc
${TOOLDIR}/llc -march=cpu0${endian} -mcpu=${CPU} -relocation-model=static \
-filetype=obj start.bc -o start.cpu0.o
${TOOLDIR}/llc -march=cpu0${endian} -mcpu=${CPU} -relocation-model=static \
-filetype=obj debug.bc -o debug.cpu0.o
${TOOLDIR}/llc -march=cpu0${endian} -mcpu=${CPU} -relocation-model=static \
-filetype=obj printf-stdarg-def.bc -o printf-stdarg-def.cpu0.o
${TOOLDIR}/llc -march=cpu0${endian} -mcpu=${CPU} -relocation-model=static \
-filetype=obj printf-stdarg.bc -o printf-stdarg.cpu0.o
${TOOLDIR}/llc -march=cpu0${endian} -mcpu=${CPU} -relocation-model=static \
-filetype=obj ch_hello.bc -o ch_hello.cpu0.o
${TOOLDIR}/llc -march=cpu0${endian} -mcpu=${CPU} -relocation-model=static \
-filetype=obj lib_cpu0.ll -o lib_cpu0.o
${TOOLDIR}/lld -flavor gnu -target cpu0${endian}-unknown-linux-gnu \
start.cpu0.o debug.cpu0.o printf-stdarg-def.cpu0.o printf-stdarg.cpu0.o \
ch_hello.cpu0.o lib_cpu0.o -o a.out

epilogue;


</pre></div>
</div>
<p class="rubric">exlbt/verilog/Cpu0.hex</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="go">...</span>
<span class="go">/*printf:*/</span>
<span class="go">/*      b4:*/ 09 dd ff e0                                  /* addiu   $sp, $sp, -32*/</span>
<span class="go">...</span>
<span class="go">/*main:*/</span>
<span class="go">/*     9e0:*/ 09 dd ff e8                                  /* addiu   $sp, $sp, -24*/</span>
<span class="go">...</span>
<span class="go">/*     9f0:*/ 0f 20 00 00                                  /* lui     $2, 0*/</span>
<span class="go">/*     9f4:*/ 0d 22 0b 9f                                  /* ori     $2, $2, 2975*/</span>
<span class="go">...</span>
<span class="go">/*     a0c:*/ 3b ff f6 a4                                  /* jsub    16774820*/</span>
<span class="go">...</span>
<span class="go">/*Contents of section .rodata:*/</span>
<span class="go">/*0b98 */28 6e 75 6c  6c 29 00 48  65 6c 6c 6f  20 77 6f 72 /*  (null).Hello wor*/</span>
<span class="go">/*0ba8 */6c 64 21 00  25 73 0a 00   /*  ld!.\%s..*/</span>
</pre></div>
</div>
<p>As you can see, applyRelocation() get four values for the Relocation Records
Solving. When meets R_CPU0_LO16, targetVAddress is the only one value needed for
this Relocation Solving in these four values. For this ch_hello.c example code,
the lld set the &#8220;Hello world!&#8221; string begin at 0x0b98+7=0x0b9f.
So, targetVAddress is 0x0b9f.
These two instructions &#8220;lui&#8221; and &#8220;ori&#8221; at address 0x9f0 and 0x9f4,
respectively, loading the address of &#8220;Hello world!&#8221; string to register $2.
The &#8220;lui&#8221; got the HI 16 bits while the
&#8220;ori&#8221; got the LO 16 bits of address of &#8220;Hello world!&#8221; string. This &#8220;lui&#8221;
Relocation Record, R_CPU0_HI16, is 0 since the HI 16 bits of 0xb9f is 0 while
the &#8220;ori&#8221; Relocation Record, R_CPU0_LO16, is 0xb9f.
The instruction &#8220;jsub&#8221; at 0xa0c is an instruction jump to printf().
This instruction is a PC relative address Relocation Record, R_CPU0_PC24,
while the R_CPU0_LO16 is an absolute address Relocation Record.
To solve this Relocation Record, it needs &#8220;location&#8221; in addition to
targetVAddress. In this case, the targetVAddress is 0xb4 where is the printf
subroutine start address and the location is 0xa0c since the
instruction &#8220;jsub&#8221; sit at this address.
The R_CPU0_PC24 is solved by (0xb4 - (0xa0c + 4) = 0xf6a4 for 16 bits with sign
extension) since after this &#8220;jsub&#8221; instruction executed the PC counter is
(0xa0c+4).
To +4 at current instruction because PC counter increased at instruction fetch
stage in Verilog design.</p>
<p>Remind, we explain the Relocation Records Solving according file cpu0.hex list
as above because the the Cpu0 machine boot at memory address 0x0 while the elf
text section or plt section as follows start at 0x140. The 0x0 is the header of
machine architecture information. The elf2hex code must keeps the address
relative distance between text and plt sections just like the Cpu0 elf2hex.h did.
The .rodata and other data sections are binding with absolute address, Cpu0
elf2hex must keeps them as the same address of elf.</p>
<p>For the following example code run, the book example code, exlbt.tar.gz,
untared in directory /Users/Jonathan/test/lbt/.
The Cpu0 backend code, lbdex.tar.gz, untared in
the same directory too. The lbdex.tar.gz can be get from the bottom of web,
<a class="reference external" href="http://jonathan2251.github.io/lbd/index.html">http://jonathan2251.github.io/lbd/index.html</a>.</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">1-160-136-173:input Jonathan$</span> <span class="nb">pwd</span>
<span class="go">/Users/Jonathan/test/lbt/exlbt/input</span>
<span class="gp">1-160-136-173:input Jonathan$</span> ls ../..
<span class="go">... exlbt ... lbdex ...</span>
<span class="go">/Users/Jonathan/test/lbt/exlbt/input</span>
<span class="gp">1-160-136-173:input Jonathan$</span> bash build-hello.sh cpu032I be
<span class="gp">1-160-136-173:input Jonathan$</span> /Users/Jonathan/llvm/test/cmake_debug_build/
<span class="go">Debug/bin/llvm-objdump -s a.out</span>
<span class="go">...                .</span>
<span class="go">Contents of section .plt:</span>
<span class="go"> 0140 3600000c 36000004 36000004 36fffffc  6...6...6...6...</span>
<span class="go">Contents of section .text:</span>
<span class="go"> 0150 09ddfff8 02ed0004 02cd0000 11cd0000  ................</span>
<span class="go">...</span>
<span class="go">Contents of section .rodata:</span>
<span class="go"> 0b98 286e756c 6c290048 656c6c6f 20776f72  (null).Hello wor</span>
<span class="go"> 0ba8 6c642100 25730a00                    ld!.%s..</span>
</pre></div>
</div>
<p>Next section will show you how to design your lld backend and register a pass
for Relocation Records Solve in details through Cpu0 backend code explantation.</p>
</div>
</div>
</div>
<div class="section" id="static-linker">
<h3><a class="toc-backref" href="#id45">Static linker</a><a class="headerlink" href="#static-linker" title="Permalink to this headline">¶</a></h3>
<p>Let&#8217;s run the static linker first and explain it next.</p>
<div class="section" id="run">
<h4><a class="toc-backref" href="#id46">Run</a><a class="headerlink" href="#run" title="Permalink to this headline">¶</a></h4>
<p>File printf-stdarg.c come from internet download which is GPL2 license. GPL2
is more restricted than LLVM license.
File printf-stdarg-1.c is the file for testing the printf() function which
implemented on PC OS platform. Let&#8217;s run printf-stdarg-2.cpp on Cpu0 and
compare it against the result of PC&#8217;s printf() as below.</p>
<p class="rubric">exlbt/input/printf-stdarg-1.c</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>/*
  Copyright 2001, 2002 Georges Menie (www.menie.org)
  stdarg version contributed by Christian Ettinger

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

/*
  putchar is the only external dependency for this file,
  if you have a working putchar, leave it commented out.
  If not, uncomment the define below and
  replace outbyte(c) by your own function call.

#define putchar(c) outbyte(c)
*/

// gcc printf-stdarg-1.c
// ./a.out

#include &lt;stdio.h&gt;

#define TEST_PRINTF

#ifdef TEST_PRINTF
int main(void)
{
  char *ptr = &quot;Hello world!&quot;;
  char *np = 0;
  int i = 5;
  unsigned int bs = sizeof(int)*8;
  int mi;
  char buf[80];

  mi = (1 &lt;&lt; (bs-1)) + 1;
  printf(&quot;%s\n&quot;, ptr);
  printf(&quot;printf test\n&quot;);
  printf(&quot;%s is null pointer\n&quot;, np);
  printf(&quot;%d = 5\n&quot;, i);
  printf(&quot;%d = - max int\n&quot;, mi);
  printf(&quot;char %c = &#39;a&#39;\n&quot;, &#39;a&#39;);
  printf(&quot;hex %x = ff\n&quot;, 0xff);
  printf(&quot;hex %02x = 00\n&quot;, 0);
  printf(&quot;signed %d = unsigned %u = hex %x\n&quot;, -3, -3, -3);
  printf(&quot;%d %s(s)%&quot;, 0, &quot;message&quot;);
  printf(&quot;\n&quot;);
  printf(&quot;%d %s(s) with %%\n&quot;, 0, &quot;message&quot;);
  sprintf(buf, &quot;justif: \&quot;%-10s\&quot;\n&quot;, &quot;left&quot;); printf(&quot;%s&quot;, buf);
  sprintf(buf, &quot;justif: \&quot;%10s\&quot;\n&quot;, &quot;right&quot;); printf(&quot;%s&quot;, buf);
  sprintf(buf, &quot; 3: %04d zero padded\n&quot;, 3); printf(&quot;%s&quot;, buf);
  sprintf(buf, &quot; 3: %-4d left justif.\n&quot;, 3); printf(&quot;%s&quot;, buf);
  sprintf(buf, &quot; 3: %4d right justif.\n&quot;, 3); printf(&quot;%s&quot;, buf);
  sprintf(buf, &quot;-3: %04d zero padded\n&quot;, -3); printf(&quot;%s&quot;, buf);
  sprintf(buf, &quot;-3: %-4d left justif.\n&quot;, -3); printf(&quot;%s&quot;, buf);
  sprintf(buf, &quot;-3: %4d right justif.\n&quot;, -3); printf(&quot;%s&quot;, buf);

  return 0;
}

/*
 * if you compile this file with
 *   gcc -Wall $(YOUR_C_OPTIONS) -DTEST_PRINTF -c printf.c
 * you will get a normal warning:
 *   printf.c:214: warning: spurious trailing `%&#39; in format
 * this line is testing an invalid % at the end of the format string.
 *
 * this should display (on 32bit int machine) :
 *
 * Hello world!
 * printf test
 * (null) is null pointer
 * 5 = 5
 * -2147483647 = - max int
 * char a = &#39;a&#39;
 * hex ff = ff
 * hex 00 = 00
 * signed -3 = unsigned 4294967293 = hex fffffffd
 * 0 message(s)
 * 0 message(s) with %
 * justif: &quot;left      &quot;
 * justif: &quot;     right&quot;
 *  3: 0003 zero padded
 *  3: 3    left justif.
 *  3:    3 right justif.
 * -3: -003 zero padded
 * -3: -3   left justif.
 * -3:   -3 right justif.
 */

#endif
</pre></div>
</div>
<p class="rubric">exlbt/input/printf-stdarg-2.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>
<span class="c1">#include &quot;debug.h&quot;</span>
<span class="c1">#include &quot;print.h&quot;</span>

<span class="c1">#define TEST_PRINTF</span>

<span class="n">extern</span> <span class="s2">&quot;C&quot;</span> <span class="nb">int</span> <span class="n">putchar</span><span class="p">(</span><span class="nb">int</span> <span class="n">c</span><span class="p">);</span> 

<span class="n">extern</span> <span class="s2">&quot;C&quot;</span> <span class="p">{</span>
<span class="c1">#include &quot;printf-stdarg.c&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">exlbt/input/printf-stdarg-def.c</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>
<span class="c1">#include &quot;print.h&quot;</span>

<span class="o">//</span> <span class="n">Definition</span> <span class="n">putchar</span><span class="p">(</span><span class="nb">int</span> <span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">printf</span><span class="o">-</span><span class="n">stdarg</span><span class="o">.</span><span class="n">c</span>
<span class="o">//</span> <span class="n">For</span> <span class="n">memory</span> <span class="n">IO</span>
<span class="nb">int</span> <span class="n">putchar</span><span class="p">(</span><span class="nb">int</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">char</span><span class="o">*</span><span class="p">)</span><span class="n">OUT_MEM</span><span class="p">;</span>
  <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">exlbt/input/printf-stdarg.c</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>/*
  Copyright 2001, 2002 Georges Menie (www.menie.org)
  stdarg version contributed by Christian Ettinger

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

/*
  putchar is the only external dependency for this file,
  if you have a working putchar, leave it commented out.
  If not, uncomment the define below and
  replace outbyte(c) by your own function call.

#define putchar(c) outbyte(c)
*/

#include &lt;stdarg.h&gt;

static void printchar(char **str, int c)
{
  extern int putchar(int c);
  
  if (str) {
    **str = c;
    ++(*str);
  }
  else (void)putchar(c);
}

#define PAD_RIGHT 1
#define PAD_ZERO 2

static int prints(char **out, const char *string, int width, int pad)
{
  register int pc = 0, padchar = &#39; &#39;;

  if (width &gt; 0) {
    register int len = 0;
    register const char *ptr;
    for (ptr = string; *ptr; ++ptr) ++len;
    if (len &gt;= width) width = 0;
    else width -= len;
    if (pad &amp; PAD_ZERO) padchar = &#39;0&#39;;
  }
  if (!(pad &amp; PAD_RIGHT)) {
    for ( ; width &gt; 0; --width) {
      printchar (out, padchar);
      ++pc;
    }
  }
  for ( ; *string ; ++string) {
    printchar (out, *string);
    ++pc;
  }
  for ( ; width &gt; 0; --width) {
    printchar (out, padchar);
    ++pc;
  }

  return pc;
}

/* the following should be enough for 32 bit int */
#define PRINT_BUF_LEN 12

static int printi(char **out, int i, int b, int sg, int width, int pad, int letbase)
{
  char print_buf[PRINT_BUF_LEN];
  register char *s;
  register int t, neg = 0, pc = 0;
  register unsigned int u = i;

  if (i == 0) {
    print_buf[0] = &#39;0&#39;;
    print_buf[1] = &#39;\0&#39;;
    return prints (out, print_buf, width, pad);
  }

  if (sg &amp;&amp; b == 10 &amp;&amp; i &lt; 0) {
    neg = 1;
    u = -i;
  }

  s = print_buf + PRINT_BUF_LEN-1;
  *s = &#39;\0&#39;;

  while (u) {
    t = u % b;
    if( t &gt;= 10 )
      t += letbase - &#39;0&#39; - 10;
    *--s = t + &#39;0&#39;;
    u /= b;
  }

  if (neg) {
    if( width &amp;&amp; (pad &amp; PAD_ZERO) ) {
      printchar (out, &#39;-&#39;);
      ++pc;
      --width;
    }
    else {
      *--s = &#39;-&#39;;
    }
  }

  return pc + prints (out, s, width, pad);
}

static int print(char **out, const char *format, va_list args )
{
  register int width, pad;
  register int pc = 0;
  char scr[2];

  for (; *format != 0; ++format) {
    if (*format == &#39;%&#39;) {
      ++format;
      width = pad = 0;
      if (*format == &#39;\0&#39;) break;
      if (*format == &#39;%&#39;) goto out;
      if (*format == &#39;-&#39;) {
        ++format;
        pad = PAD_RIGHT;
      }
      while (*format == &#39;0&#39;) {
        ++format;
        pad |= PAD_ZERO;
      }
      for ( ; *format &gt;= &#39;0&#39; &amp;&amp; *format &lt;= &#39;9&#39;; ++format) {
        width *= 10;
        width += *format - &#39;0&#39;;
      }
      if( *format == &#39;s&#39; ) {
        register char *s = (char *)va_arg( args, int );
        pc += prints (out, s?s:&quot;(null)&quot;, width, pad);
        continue;
      }
      if( *format == &#39;d&#39; ) {
        pc += printi (out, va_arg( args, int ), 10, 1, width, pad, &#39;a&#39;);
        continue;
      }
      if( *format == &#39;x&#39; ) {
        pc += printi (out, va_arg( args, int ), 16, 0, width, pad, &#39;a&#39;);
        continue;
      }
      if( *format == &#39;X&#39; ) {
        pc += printi (out, va_arg( args, int ), 16, 0, width, pad, &#39;A&#39;);
        continue;
      }
      if( *format == &#39;u&#39; ) {
        pc += printi (out, va_arg( args, int ), 10, 0, width, pad, &#39;a&#39;);
        continue;
      }
      if( *format == &#39;c&#39; ) {
        /* char are converted to int then pushed on the stack */
        scr[0] = (char)va_arg( args, int );
        scr[1] = &#39;\0&#39;;
        pc += prints (out, scr, width, pad);
        continue;
      }
    }
    else {
    out:
      printchar (out, *format);
      ++pc;
    }
  }
  if (out) **out = &#39;\0&#39;;
  va_end( args );
  return pc;
}

int printf(const char *format, ...)
{
        va_list args;
        
        va_start( args, format );
        return print( 0, format, args );
}

int sprintf(char *out, const char *format, ...)
{
        va_list args;
        
        va_start( args, format );
        return print( &amp;out, format, args );
}

#ifdef TEST_PRINTF
int main(void)
{
  char *ptr = &quot;Hello world!&quot;;
  char *np = 0;
  int i = 5;
  unsigned int bs = sizeof(int)*8;
  int mi;
  char buf[80];

  mi = (1 &lt;&lt; (bs-1)) + 1;
  printf(&quot;%s\n&quot;, ptr);
  printf(&quot;printf test\n&quot;);
  printf(&quot;%s is null pointer\n&quot;, np);
  printf(&quot;%d = 5\n&quot;, i);
  printf(&quot;%d = - max int\n&quot;, mi);
  printf(&quot;char %c = &#39;a&#39;\n&quot;, &#39;a&#39;);
  printf(&quot;hex %x = ff\n&quot;, 0xff);
  printf(&quot;hex %02x = 00\n&quot;, 0);
  printf(&quot;signed %d = unsigned %u = hex %x\n&quot;, -3, -3, -3);
  printf(&quot;%d %s(s)%&quot;, 0, &quot;message&quot;);
  printf(&quot;\n&quot;);
  printf(&quot;%d %s(s) with %%\n&quot;, 0, &quot;message&quot;);
  sprintf(buf, &quot;justif: \&quot;%-10s\&quot;\n&quot;, &quot;left&quot;); printf(&quot;%s&quot;, buf);
  sprintf(buf, &quot;justif: \&quot;%10s\&quot;\n&quot;, &quot;right&quot;); printf(&quot;%s&quot;, buf);
  sprintf(buf, &quot; 3: %04d zero padded\n&quot;, 3); printf(&quot;%s&quot;, buf);
  sprintf(buf, &quot; 3: %-4d left justif.\n&quot;, 3); printf(&quot;%s&quot;, buf);
  sprintf(buf, &quot; 3: %4d right justif.\n&quot;, 3); printf(&quot;%s&quot;, buf);
  sprintf(buf, &quot;-3: %04d zero padded\n&quot;, -3); printf(&quot;%s&quot;, buf);
  sprintf(buf, &quot;-3: %-4d left justif.\n&quot;, -3); printf(&quot;%s&quot;, buf);
  sprintf(buf, &quot;-3: %4d right justif.\n&quot;, -3); printf(&quot;%s&quot;, buf);

  return 0;
}

/*
 * if you compile this file with
 *   gcc -Wall $(YOUR_C_OPTIONS) -DTEST_PRINTF -c printf.c
 * you will get a normal warning:
 *   printf.c:214: warning: spurious trailing `%&#39; in format
 * this line is testing an invalid % at the end of the format string.
 *
 * this should display (on 32bit int machine) :
 *
 * Hello world!
 * printf test
 * (null) is null pointer
 * 5 = 5
 * -2147483647 = - max int
 * char a = &#39;a&#39;
 * hex ff = ff
 * hex 00 = 00
 * signed -3 = unsigned 4294967293 = hex fffffffd
 * 0 message(s)
 * 0 message(s) with %
 * justif: &quot;left      &quot;
 * justif: &quot;     right&quot;
 *  3: 0003 zero padded
 *  3: 3    left justif.
 *  3:    3 right justif.
 * -3: -003 zero padded
 * -3: -3   left justif.
 * -3:   -3 right justif.
 */

#endif
</pre></div>
</div>
<p class="rubric">exlbt/input/start.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>
#include &quot;dynamic_linker.h&quot;
#include &quot;start.h&quot;

extern int main();

// Real entry (first instruction) is from cpu0BootAtomContent of 
// Cpu0RelocationPass.cpp jump to asm(&quot;start:&quot;) of start.cpp.
void start() {
  asm(&quot;start:&quot;);
  
  asm(&quot;lui $sp, 0x6&quot;);
  asm(&quot;addiu $sp, $sp, 0xfffc&quot;);
  int *gpaddr;
  gpaddr = (int*)GPADDR;
  __asm__ __volatile__(&quot;ld  $gp, %0&quot;
                       : // no output register, specify output register to $gp
                       :&quot;m&quot;(*gpaddr)
                       );
  initRegs();
  main();
  asm(&quot;addiu $lr, $ZERO, -1&quot;);
  asm(&quot;ret $lr&quot;);
}

</pre></div>
</div>
<p class="rubric">exlbt/input/lib_cpu0.ll</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">;</span> <span class="n">The</span> <span class="nd">@_start</span><span class="p">()</span> <span class="n">exist</span> <span class="n">to</span> <span class="n">prevent</span> <span class="n">lld</span> <span class="n">linker</span> <span class="n">error</span><span class="o">.</span>
<span class="p">;</span> <span class="n">Real</span> <span class="n">entry</span> <span class="p">(</span><span class="n">first</span> <span class="n">instruction</span><span class="p">)</span> <span class="ow">is</span> <span class="kn">from</span> <span class="nn">cpu0BootAtomContent</span> <span class="n">of</span> 
<span class="p">;</span> <span class="n">Cpu0RelocationPass</span><span class="o">.</span><span class="n">cpp</span> <span class="n">jump</span> <span class="n">to</span> <span class="n">asm</span><span class="p">(</span><span class="s2">&quot;start:&quot;</span><span class="p">)</span> <span class="n">of</span> <span class="n">start</span><span class="o">.</span><span class="n">cpp</span><span class="o">.</span>
<span class="n">define</span> <span class="n">void</span> <span class="nd">@_start</span><span class="p">()</span> <span class="n">nounwind</span> <span class="p">{</span>
<span class="n">entry</span><span class="p">:</span>
  <span class="n">ret</span> <span class="n">void</span>
<span class="p">}</span>

<span class="n">define</span> <span class="n">void</span> <span class="nd">@__start</span><span class="p">()</span> <span class="n">nounwind</span> <span class="p">{</span>
<span class="n">entry</span><span class="p">:</span>
  <span class="n">ret</span> <span class="n">void</span>
<span class="p">}</span>

<span class="n">define</span> <span class="n">void</span> <span class="nd">@__stack_chk_fail</span><span class="p">()</span> <span class="n">nounwind</span> <span class="p">{</span>
<span class="n">entry</span><span class="p">:</span>
  <span class="n">ret</span> <span class="n">void</span>
<span class="p">}</span>

<span class="n">define</span> <span class="n">void</span> <span class="nd">@__stack_chk_guard</span><span class="p">()</span> <span class="n">nounwind</span> <span class="p">{</span>
<span class="n">entry</span><span class="p">:</span>
  <span class="n">ret</span> <span class="n">void</span>
<span class="p">}</span>

<span class="n">define</span> <span class="n">void</span> <span class="nd">@_ZdlPv</span><span class="p">()</span> <span class="n">nounwind</span> <span class="p">{</span>
<span class="n">entry</span><span class="p">:</span>
  <span class="n">ret</span> <span class="n">void</span>
<span class="p">}</span>

<span class="n">define</span> <span class="n">void</span> <span class="nd">@__dso_handle</span><span class="p">()</span> <span class="n">nounwind</span> <span class="p">{</span>
<span class="n">entry</span><span class="p">:</span>
  <span class="n">ret</span> <span class="n">void</span>
<span class="p">}</span>

<span class="n">define</span> <span class="n">void</span> <span class="nd">@_ZNSt8ios_base4InitC1Ev</span><span class="p">()</span> <span class="n">nounwind</span> <span class="p">{</span>
<span class="n">entry</span><span class="p">:</span>
  <span class="n">ret</span> <span class="n">void</span>
<span class="p">}</span>

<span class="n">define</span> <span class="n">void</span> <span class="nd">@__cxa_atexit</span><span class="p">()</span> <span class="n">nounwind</span> <span class="p">{</span>
<span class="n">entry</span><span class="p">:</span>
  <span class="n">ret</span> <span class="n">void</span>
<span class="p">}</span>

<span class="n">define</span> <span class="n">void</span> <span class="nd">@_ZTVN10__cxxabiv120__si_class_type_infoE</span><span class="p">()</span> <span class="n">nounwind</span> <span class="p">{</span>
<span class="n">entry</span><span class="p">:</span>
  <span class="n">ret</span> <span class="n">void</span>
<span class="p">}</span>

<span class="n">define</span> <span class="n">void</span> <span class="nd">@_ZTVN10__cxxabiv117__class_type_infoE</span><span class="p">()</span> <span class="n">nounwind</span> <span class="p">{</span>
<span class="n">entry</span><span class="p">:</span>
  <span class="n">ret</span> <span class="n">void</span>
<span class="p">}</span>

<span class="n">define</span> <span class="n">void</span> <span class="nd">@_Znwm</span><span class="p">()</span> <span class="n">nounwind</span> <span class="p">{</span>
<span class="n">entry</span><span class="p">:</span>
  <span class="n">ret</span> <span class="n">void</span>
<span class="p">}</span>

<span class="n">define</span> <span class="n">void</span> <span class="nd">@__cxa_pure_virtual</span><span class="p">()</span> <span class="n">nounwind</span> <span class="p">{</span>
<span class="n">entry</span><span class="p">:</span>
  <span class="n">ret</span> <span class="n">void</span>
<span class="p">}</span>

<span class="n">define</span> <span class="n">void</span> <span class="nd">@_ZNSt8ios_base4InitD1Ev</span><span class="p">()</span> <span class="n">nounwind</span> <span class="p">{</span>
<span class="n">entry</span><span class="p">:</span>
  <span class="n">ret</span> <span class="n">void</span>
<span class="p">}</span>

</pre></div>
</div>
<p class="rubric">exlbt/input/functions.sh</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>prologue() {
  LBDEXDIR=../../lbdex

  if [ $argNum == 0 ]; then
    echo &quot;useage: bash $sh_name cpu_type endian&quot;
    echo &quot;  cpu_type: cpu032I or cpu032II&quot;
    echo &quot;  endian: be (big endian, default) or le (little endian)&quot;
    echo &quot;for example:&quot;
    echo &quot;  bash build-slinker.sh cpu032I be&quot;
    exit 1;
  fi
  if [ $arg1 != cpu032I ] &amp;&amp; [ $arg1 != cpu032II ]; then
    echo &quot;1st argument is cpu032I or cpu032II&quot;
    exit 1
  fi

  INCDIR=../../lbdex/input
  OS=`uname -s`
  echo &quot;OS =&quot; ${OS}

  if [ &quot;$OS&quot; == &quot;Linux&quot; ]; then
    CLANGDIR=~/llvm/release/cmake_debug_build/bin
    TOOLDIR=~/llvm/test/cmake_debug_build/bin
  else
    CLANGDIR=~/llvm/release/cmake_debug_build/Debug/bin
    TOOLDIR=~/llvm/test/cmake_debug_build/Debug/bin
  fi

  CPU=$arg1
  echo &quot;CPU =&quot; &quot;${CPU}&quot;

  if [ &quot;$arg2&quot; != &quot;&quot; ] &amp;&amp; [ $arg2 != le ] &amp;&amp; [ $arg2 != be ]; then
    echo &quot;2nd argument is be (big endian, default) or le (little endian)&quot;
    exit 1
  fi
  if [ &quot;$arg2&quot; == &quot;&quot; ] || [ $arg2 == be ]; then
    endian=
  else
    endian=el
  fi
  echo &quot;endian =&quot; &quot;${endian}&quot;

  bash clean.sh
}

isLittleEndian() {
  echo &quot;endian = &quot; &quot;$endian&quot;
  if [ &quot;$endian&quot; == &quot;LittleEndian&quot; ] ; then
    le=&quot;true&quot;
  elif [ &quot;$endian&quot; == &quot;BigEndian&quot; ] ; then
    le=&quot;false&quot;
  else
    echo &quot;!endian unknown&quot;
    exit 1
  fi
}

elf2hex() {
  ${TOOLDIR}/elf2hex -le=${le} a.out &gt; ${LBDEXDIR}/verilog/cpu0.hex
  if [ ${le} == &quot;true&quot; ] ; then
    echo &quot;1   /* 0: big endian, 1: little endian */&quot; &gt; ${LBDEXDIR}/verilog/cpu0.config
  else
    echo &quot;0   /* 0: big endian, 1: little endian */&quot; &gt; ${LBDEXDIR}/verilog/cpu0.config
  fi
  cat ${LBDEXDIR}/verilog/cpu0.config
}

epilogue() {
  endian=`${TOOLDIR}/llvm-readobj -h a.out|grep &quot;DataEncoding&quot;|awk &#39;{print $2}&#39;`
  isLittleEndian;
  elf2hex;
}
</pre></div>
</div>
<p class="rubric">exlbt/input/build-printf-stdarg-2.sh</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>#!/usr/bin/env bash

source functions.sh

sh_name=build-printf-stdarg-2.sh
argNum=$#
arg1=$1
arg2=$2

prologue;

clang -target mips-unknown-linux-gnu -c start.cpp -emit-llvm -o start.bc
clang -target mips-unknown-linux-gnu -c debug.cpp -emit-llvm -o debug.bc
clang -target mips-unknown-linux-gnu -c printf-stdarg-def.c -emit-llvm \
-o printf-stdarg-def.bc
clang -target mips-unknown-linux-gnu -c printf-stdarg-2.cpp -emit-llvm -o \
printf-stdarg-2.bc
${TOOLDIR}/llc -march=cpu0${endian} -mcpu=${CPU} -relocation-model=static \
-filetype=obj start.bc -o start.cpu0.o
${TOOLDIR}/llc -march=cpu0${endian} -mcpu=${CPU} -relocation-model=static \
-filetype=obj debug.bc -o debug.cpu0.o
${TOOLDIR}/llc -march=cpu0${endian} -mcpu=${CPU} -relocation-model=static \
-filetype=obj printf-stdarg-def.bc -o printf-stdarg-def.cpu0.o
${TOOLDIR}/llc -march=cpu0${endian} -mcpu=${CPU} -relocation-model=static \
-filetype=obj printf-stdarg-2.bc -o printf-stdarg-2.cpu0.o
${TOOLDIR}/llc -march=cpu0${endian} -mcpu=${CPU} -relocation-model=static \
-filetype=obj lib_cpu0.ll -o lib_cpu0.o
${TOOLDIR}/lld -flavor gnu -target cpu0${endian}-unknown-linux-gnu \
start.cpu0.o debug.cpu0.o printf-stdarg-def.cpu0.o printf-stdarg-2.cpu0.o \
lib_cpu0.o -o a.out

epilogue;

</pre></div>
</div>
<p class="rubric">lbdex/verilog/Makefile</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>#TRACE=-D TRACE
all:
	iverilog ${TRACE} -o cpu0Is cpu0.v 
	iverilog ${TRACE} -D CPU0II -o cpu0IIs cpu0.v 
	iverilog ${TRACE} -D DLINKER -o cpu0Id cpu0.v 
	iverilog ${TRACE} -D DLINKER -D CPU0II -o cpu0IId cpu0.v 
	iverilog ${TRACE} -D SIMULATE_DELAY_SLOT -o cpu0Isp cpu0.v 
	iverilog ${TRACE} -D SIMULATE_DELAY_SLOT -D CPU0II -o cpu0IIsp cpu0.v 
	iverilog ${TRACE} -D SIMULATE_DELAY_SLOT -D DLINKER -o cpu0Idp cpu0.v 
	iverilog ${TRACE} -D SIMULATE_DELAY_SLOT -D DLINKER -D CPU0II -o cpu0IIdp cpu0.v

.PHONY: clean
clean:
	rm -rf dlconfig cpu0.hex cpu0Is cpu0IIs cpu0Id cpu0IId cpu0Isp cpu0IIsp 
	rm -f cpu0Idp cpu0IIdp *~ cpu0.config

</pre></div>
</div>
<p>The build-printf-stdarg-2.sh is for my PC setting. Please change this script to
the directory of your llvm/lld setting. After that run static linker example
code as follows,</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">1-160-136-173:input Jonathan$</span> <span class="nb">pwd</span>
<span class="go">/Users/Jonathan/test/lbt/exlbt/input</span>
<span class="gp">1-160-136-173:input Jonathan$</span> bash build-printf-stdarg-2.sh cpu032I be
<span class="go">In file included from printf-stdarg-2.cpp:11:</span>
<span class="go">./printf-stdarg.c:206:15: warning: conversion from string literal to &#39;char *&#39;</span>
<span class="go">is deprecated [-Wdeprecated-writable-strings]</span>
<span class="go">  char *ptr = &quot;Hello world!&quot;;</span>
<span class="go">              ^</span>
<span class="go">1 warning generated.</span>

<span class="gp">1-160-136-173:input Jonathan$</span> <span class="nb">cd</span> ../../lbdex/verilog/
<span class="gp">1-160-136-173:verilog Jonathan$</span> <span class="nb">pwd</span>
<span class="go">/Users/Jonathan/test/lbt/lbdex/verilog</span>
<span class="gp">1-160-136-173:verilog Jonathan$</span> make
<span class="gp">1-160-136-173:verilog Jonathan$</span> ls
<span class="go">... cpu0Isp ... cpu0IIsp ...</span>
<span class="gp">1-160-136-173:verilog Jonathan$</span> ./cpu0Isp
<span class="go">Hello world!</span>
<span class="go">printf test</span>
<span class="go">(null) is null pointer</span>
<span class="go">5 = 5</span>
<span class="go">-2147483647 = - max int</span>
<span class="go">char a = &#39;a&#39;</span>
<span class="go">hex ff = ff</span>
<span class="go">hex 00 = 00</span>
<span class="go">signed -3 = unsigned 4294967293 = hex fffffffd</span>
<span class="go">0 message(s)</span>
<span class="go">0 message(s) with \%</span>
<span class="go">justif: &quot;left      &quot;</span>
<span class="go">justif: &quot;     right&quot;</span>
<span class="go"> 3: 0003 zero padded</span>
<span class="go"> 3: 3    left justif.</span>
<span class="go"> 3:    3 right justif.</span>
<span class="go">-3: -003 zero padded</span>
</pre></div>
</div>
<p>Let&#8217;s check the result with PC program printf-stdarg-1.c output as follows,</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">1-160-136-173:input Jonathan$</span> clang printf-stdarg-1.c
<span class="go">printf-stdarg-1.c:58:19: warning: incomplete format specifier [-Wformat]</span>
<span class="go">  printf(&quot;%d %s(s)%&quot;, 0, &quot;message&quot;);</span>
<span class="go">                  ^</span>
<span class="go">1 warning generated.</span>
<span class="gp">1-160-136-173:input Jonathan$</span> ./a.out
<span class="go">Hello world!</span>
<span class="go">printf test</span>
<span class="go">(null) is null pointer</span>
<span class="go">5 = 5</span>
<span class="go">-2147483647 = - max int</span>
<span class="go">char a = &#39;a&#39;</span>
<span class="go">hex ff = ff</span>
<span class="go">hex 00 = 00</span>
<span class="go">signed -3 = unsigned 4294967293 = hex fffffffd</span>
<span class="go">0 message(s)</span>
<span class="go">0 message(s) with \%</span>
<span class="go">justif: &quot;left      &quot;</span>
<span class="go">justif: &quot;     right&quot;</span>
<span class="go"> 3: 0003 zero padded</span>
<span class="go"> 3: 3    left justif.</span>
<span class="go"> 3:    3 right justif.</span>
<span class="go">-3: -003 zero padded</span>
<span class="go">-3: -3   left justif.</span>
<span class="go">-3:   -3 right justif.</span>
</pre></div>
</div>
<p>They are same. You can verify the slt instructions is work fine too by change
variable cpu from cpu032I to cpu032II as follows,</p>
<p class="rubric">exlbt/input/build-printf-stdarg-2.sh</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">1-160-136-173:verilog Jonathan$</span> <span class="nb">pwd</span>
<span class="go">/Users/Jonathan/test/lbt/lbdex/verilog</span>
<span class="gp">1-160-136-173:verilog Jonathan$</span> <span class="nb">cd</span> ../../exlbt/input
<span class="gp">1-160-136-173:input Jonathan$</span> <span class="nb">pwd</span>
<span class="go">/Users/Jonathan/test/lbt/exlbt/input</span>
<span class="gp">1-160-136-173:input Jonathan$</span> bash build-printf-stdarg-2.sh cpu032II be
<span class="go">...</span>
<span class="gp">1-160-136-173:input Jonathan$</span> <span class="nb">cd</span> ../lbdex/verilog/
<span class="gp">1-160-136-173:verilog Jonathan$</span> ./cpu0IIsp
</pre></div>
</div>
<p>The verilog machine cpu0IIs include all instructions of cpu032I and add
slt, beq, ..., instructions.
Run build-printf-stdarg-2.sh with cpu=cpu032II will generate slt, beq and bne
instructions instead of cmp, jeq, ... instructions.</p>
<p>With the printf() of GPL source code, we can program more test code with it
to verify the previous llvm Cpu0 backend generated program. The following code
is for this purpose.</p>
<p class="rubric">exlbt/input/debug.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>#include &quot;debug.h&quot;

extern &quot;C&quot; int printf(const char *format, ...);

// With read variable form asm, such as sw in this example, the function, 
// ISR_Handler() must entry from beginning. The ISR() enter from &quot;ISR:&quot; will
// has incorrect value for reload instruction in offset. 
// For example, the correct one is: 
//   &quot;addiu $sp, $sp, -12&quot;
//   &quot;mov $fp, $sp&quot;
// ISR:
//   &quot;ld $2, 32($fp)&quot;
// Go to ISR directly, then the $fp is 12+ than original, then it will get
//   &quot;ld $2, 20($fp)&quot; actually.
void ISR_Handler() {
  SAVE_REGISTERS;
  asm(&quot;lui $7, 0xffff&quot;);
  asm(&quot;ori $7, $7, 0xfdff&quot;);
  asm(&quot;and $sw, $sw, $7&quot;); // clear `IE

  volatile int sw;
  __asm__ __volatile__(&quot;addiu %0, $sw, 0&quot;
                       :&quot;=r&quot;(sw)
                       );
  int interrupt = (sw &amp; INT);
  int softint = (sw &amp; SOFTWARE_INT);
  int overflow = (sw &amp; OVERFLOW);
  int int1 = (sw &amp; INT1);
  int int2 = (sw &amp; INT2);
  if (interrupt) {
    if (softint) {
      if (overflow) {
        printf(&quot;Overflow exception\n&quot;);
        CLEAR_OVERFLOW;
      }
      else {
        printf(&quot;Software interrupt\n&quot;);
      }
      CLEAR_SOFTWARE_INT;
    }
    else if (int1) {
      printf(&quot;Harware interrupt 0\n&quot;);
      asm(&quot;lui $7, 0xffff&quot;);
      asm(&quot;ori $7, $7, 0x7fff&quot;);
      asm(&quot;and $sw, $sw, $7&quot;);
    }
    else if (int2) {
      printf(&quot;Harware interrupt 1\n&quot;);
      asm(&quot;lui $7, 0xfffe&quot;);
      asm(&quot;ori $7, $7, 0xffff&quot;);
      asm(&quot;and $sw, $sw, $7&quot;);
    }
    asm(&quot;lui $7, 0xffff&quot;);
    asm(&quot;ori $7, $7, 0xdfff&quot;);
    asm(&quot;and $sw, $sw, $7&quot;); // clear `I
  }
  asm(&quot;ori $sw, $sw, 0x200&quot;); // int enable
  RESTORE_REGISTERS;
  return;
}

void ISR() {
  asm(&quot;ISR:&quot;);
  asm(&quot;lui $at, 7&quot;);
  asm(&quot;ori $at, $at, 0xff00&quot;);
  asm(&quot;st $14, 48($at)&quot;);
  ISR_Handler();
  asm(&quot;lui $at, 7&quot;);
  asm(&quot;ori $at, $at, 0xff00&quot;);
  asm(&quot;ld $14, 48($at)&quot;);
  asm(&quot;c0mov $pc, $epc&quot;);
}

void int_sim() {
  asm(&quot;ori $sw, $sw, 0x200&quot;); // int enable
  asm(&quot;ori $sw, $sw, 0x2000&quot;); // set interrupt
  asm(&quot;ori $sw, $sw, 0x4000&quot;); // Software interrupt
  asm(&quot;ori $sw, $sw, 0x200&quot;); // int enable
  asm(&quot;ori $sw, $sw, 0x2000&quot;); // set interrupt
  asm(&quot;ori $sw, $sw, 0x8000&quot;); // hardware interrupt 0
  asm(&quot;ori $sw, $sw, 0x200&quot;); // int enable
  asm(&quot;ori $sw, $sw, 0x2000&quot;); // set interrupt
  asm(&quot;lui $at, 1&quot;);
  asm(&quot;or $sw, $sw, $at&quot;); // hardware interrupt 1
  return;
}
</pre></div>
</div>
<p class="rubric">exlbt/input/ch_lld_staticlink.h</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>
<span class="c1">#include &quot;debug.h&quot;</span>
<span class="c1">#include &quot;print.h&quot;</span>

<span class="o">//</span><span class="c1">#define PRINT_TEST</span>

<span class="n">extern</span> <span class="s2">&quot;C&quot;</span> <span class="nb">int</span> <span class="n">printf</span><span class="p">(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="nb">format</span><span class="p">,</span> <span class="o">...</span><span class="p">);</span>
<span class="n">extern</span> <span class="s2">&quot;C&quot;</span> <span class="nb">int</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">char</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span> <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="nb">format</span><span class="p">,</span> <span class="o">...</span><span class="p">);</span>

<span class="n">extern</span> <span class="n">unsigned</span> <span class="n">char</span> <span class="n">sBuffer</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="n">extern</span> <span class="nb">int</span> <span class="n">test_overflow</span><span class="p">();</span>
<span class="n">extern</span> <span class="nb">int</span> <span class="n">test_add_overflow</span><span class="p">();</span>
<span class="n">extern</span> <span class="nb">int</span> <span class="n">test_sub_overflow</span><span class="p">();</span>
<span class="n">extern</span> <span class="nb">int</span> <span class="n">test_ctrl2</span><span class="p">();</span>
<span class="n">extern</span> <span class="nb">int</span> <span class="n">test_phinode</span><span class="p">(</span><span class="nb">int</span> <span class="n">a</span><span class="p">,</span> <span class="nb">int</span> <span class="n">b</span><span class="p">,</span> <span class="nb">int</span> <span class="n">c</span><span class="p">);</span>
<span class="n">extern</span> <span class="nb">int</span> <span class="n">test_blockaddress</span><span class="p">(</span><span class="nb">int</span> <span class="n">x</span><span class="p">);</span>
<span class="n">extern</span> <span class="nb">int</span> <span class="n">test_longbranch</span><span class="p">();</span>
<span class="n">extern</span> <span class="nb">int</span> <span class="n">test_func_arg_struct</span><span class="p">();</span>
<span class="n">extern</span> <span class="nb">int</span> <span class="n">test_tailcall</span><span class="p">(</span><span class="nb">int</span> <span class="n">a</span><span class="p">);</span>
<span class="n">extern</span> <span class="nb">bool</span> <span class="n">exceptionOccur</span><span class="p">;</span>
<span class="n">extern</span> <span class="nb">int</span> <span class="n">test_detect_exception</span><span class="p">(</span><span class="nb">bool</span> <span class="n">exception</span><span class="p">);</span>

<span class="n">extern</span> <span class="nb">int</span> <span class="n">test_staticlink</span><span class="p">();</span>
</pre></div>
</div>
<p class="rubric">exlbt/input/ch_lld_staticlink.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>
void verify_test_ctrl2()
{
  int a = -1;
  int b = -1;
  int c = -1;
  int d = -1;

  sBuffer[0] = (unsigned char)0x35;
  sBuffer[1] = (unsigned char)0x35;
  a = test_ctrl2();
  sBuffer[0] = (unsigned char)0x30;
  sBuffer[1] = (unsigned char)0x29;
  b = test_ctrl2();
  sBuffer[0] = (unsigned char)0x35;
  sBuffer[1] = (unsigned char)0x35;
  c = test_ctrl2();
  sBuffer[0] = (unsigned char)0x34;
  d = test_ctrl2();
  printf(&quot;test_ctrl2(): a = %d, b = %d, c = %d, d = %d&quot;, a, b, c, d);
  if (a == 1 &amp;&amp; b == 0 &amp;&amp; c == 1 &amp;&amp; d == 0)
    printf(&quot;, PASS\n&quot;);
  else
    printf(&quot;, FAIL\n&quot;);

  return;
}

int test_staticlink()
{
  int a = 0;

  a = test_add_overflow();
  a = test_sub_overflow();
  a = test_global();  // gI = 100
  printf(&quot;global variable gI = %d&quot;, a);
  if (a == 100)
    printf(&quot;, PASS\n&quot;);
  else
    printf(&quot;, FAIL\n&quot;);
  verify_test_ctrl2();
  a = test_phinode(3, 1, 0);
  printf(&quot;test_phinode(3, 1) = %d&quot;, a); // a = 3
  if (a == 3)
    printf(&quot;, PASS\n&quot;);
  else
    printf(&quot;, FAIL\n&quot;);
  a = test_blockaddress(1);
  printf(&quot;test_blockaddress(1) = %d&quot;, a); // a = 1
  if (a == 1)
    printf(&quot;, PASS\n&quot;);
  else
    printf(&quot;, FAIL\n&quot;);
  a = test_blockaddress(2);
  printf(&quot;test_blockaddress(2) = %d&quot;, a); // a = 2
  if (a == 2)
    printf(&quot;, PASS\n&quot;);
  else
    printf(&quot;, FAIL\n&quot;);
  a = test_longbranch();
  printf(&quot;test_longbranch() = %d&quot;, a); // a = 0
  if (a == 0)
    printf(&quot;, PASS\n&quot;);
  else
    printf(&quot;, FAIL\n&quot;);
  a = test_func_arg_struct();
  printf(&quot;test_func_arg_struct() = %d&quot;, a); // a = 0
  if (a == 0)
    printf(&quot;, PASS\n&quot;);
  else
    printf(&quot;, FAIL\n&quot;);
  a = test_constructor();
  printf(&quot;test_constructor() = %d&quot;, a); // a = 0
  if (a == 0)
    printf(&quot;, PASS\n&quot;);
  else
    printf(&quot;, FAIL\n&quot;);
  a = test_template();
  printf(&quot;test_template() = %d&quot;, a); // a = 15
  if (a == 15)
    printf(&quot;, PASS\n&quot;);
  else
    printf(&quot;, FAIL\n&quot;);
  a = test_tailcall(5);
  printf(&quot;test_tailcall(5) = %d&quot;, a); // a = 15
  if (a == 120)
    printf(&quot;, PASS\n&quot;);
  else
    printf(&quot;, FAIL\n&quot;);
  test_detect_exception(true);
  printf(&quot;exceptionOccur= %d&quot;, exceptionOccur);
  if (exceptionOccur)
    printf(&quot;, PASS\n&quot;);
  else
    printf(&quot;, FAIL\n&quot;);
  test_detect_exception(false);
  printf(&quot;exceptionOccur= %d&quot;, exceptionOccur);
  if (!exceptionOccur)
    printf(&quot;, PASS\n&quot;);
  else
    printf(&quot;, FAIL\n&quot;);
  a = inlineasm_global(); // 4
  printf(&quot;inlineasm_global() = %d&quot;, a); // a = 4
  if (a == 4)
    printf(&quot;, PASS\n&quot;);
  else
    printf(&quot;, FAIL\n&quot;);
  a = test_cpp_polymorphism();
  printf(&quot;test_cpp_polymorphism() = %d&quot;, a); // a = 0
  if (a == 0)
    printf(&quot;, PASS\n&quot;);
  else
    printf(&quot;, FAIL\n&quot;);

  int_sim();

  return 0;
}
</pre></div>
</div>
<p class="rubric">exlbt/input/ch_slinker.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>
<span class="c1">#include &quot;ch_nolld.h&quot;</span>
<span class="c1">#include &quot;ch_lld_staticlink.h&quot;</span>

<span class="nb">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nb">bool</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">true</span><span class="p">;</span>
  <span class="k">pass</span> <span class="o">=</span> <span class="n">test_nolld</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">pass</span><span class="p">)</span>
    <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;test_nolld(): PASS</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
  <span class="k">else</span>
    <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;test_nolld(): FAIL</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
  <span class="k">pass</span> <span class="o">=</span> <span class="n">true</span><span class="p">;</span>
  <span class="k">pass</span> <span class="o">=</span> <span class="n">test_staticlink</span><span class="p">();</span>

  <span class="k">return</span> <span class="k">pass</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">#include &quot;ch_nolld.cpp&quot;</span>
<span class="c1">#include &quot;ch_lld_staticlink.cpp&quot;</span>
</pre></div>
</div>
<p class="rubric">exlbt/input/build-slinker.sh</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>#!/usr/bin/env bash

source functions.sh

sh_name=build-slinker.sh
argNum=$#
arg1=$1
arg2=$2

prologue;

clang -target mips-unknown-linux-gnu -c start.cpp -emit-llvm -o start.bc
clang -target mips-unknown-linux-gnu -c debug.cpp -emit-llvm -o debug.bc
clang -target mips-unknown-linux-gnu -c printf-stdarg-def.c -emit-llvm \
-o printf-stdarg-def.bc
clang -target mips-unknown-linux-gnu -c printf-stdarg.c -emit-llvm \
-o printf-stdarg.bc
clang -target mips-unknown-linux-gnu -c ${LBDEXDIR}/input/ch4_1_addsuboverflow.cpp \
-emit-llvm -o ch4_1_addsuboverflow.bc
clang -target mips-unknown-linux-gnu -c ${LBDEXDIR}/input/ch8_1_br_jt.cpp \
-emit-llvm -o ch8_1_br_jt.bc
clang -O3 -target mips-unknown-linux-gnu -c ${LBDEXDIR}/input/ch8_2_phinode.cpp \
-emit-llvm -o ch8_2_phinode.bc
clang -target mips-unknown-linux-gnu -c ${LBDEXDIR}/input/ch8_1_blockaddr.cpp \
-emit-llvm -o ch8_1_blockaddr.bc
clang -target mips-unknown-linux-gnu -c ${LBDEXDIR}/input/ch8_2_longbranch.cpp \
-emit-llvm -o ch8_2_longbranch.bc
clang -O1 -target mips-unknown-linux-gnu -c ${LBDEXDIR}/input/ch9_2_tailcall.cpp \
-emit-llvm -o ch9_2_tailcall.bc
clang -target mips-unknown-linux-gnu -c ${LBDEXDIR}/input/ch9_3_detect_exception.cpp \
-emit-llvm -o ch9_3_detect_exception.bc
clang -I${LBDEXDIR}/input/ -target mips-unknown-linux-gnu -c ch_slinker.cpp \
-emit-llvm -o ch_slinker.bc
${TOOLDIR}/llc -march=cpu0${endian} -mcpu=${CPU} -relocation-model=static \
-filetype=obj start.bc -o start.o
${TOOLDIR}/llc -march=cpu0${endian} -mcpu=${CPU} -relocation-model=static \
-filetype=obj debug.bc -o debug.o
${TOOLDIR}/llc -march=cpu0${endian} -mcpu=${CPU} -relocation-model=static \
-filetype=obj printf-stdarg-def.bc -o printf-stdarg-def.o
${TOOLDIR}/llc -march=cpu0${endian} -mcpu=${CPU} -relocation-model=static \
-filetype=obj printf-stdarg.bc -o printf-stdarg.o
${TOOLDIR}/llc -march=cpu0${endian} -mcpu=${CPU} -relocation-model=static \
-filetype=obj -cpu0-enable-overflow=true ch4_1_addsuboverflow.bc -o \
ch4_1_addsuboverflow.o
${TOOLDIR}/llc -march=cpu0${endian} -mcpu=${CPU} -relocation-model=static \
-filetype=obj ch8_1_br_jt.bc -o ch8_1_br_jt.o
${TOOLDIR}/llc -march=cpu0${endian} -mcpu=${CPU} -relocation-model=static \
-filetype=obj ch8_2_phinode.bc -o ch8_2_phinode.o
${TOOLDIR}/llc -march=cpu0${endian} -mcpu=${CPU} -relocation-model=static \
-filetype=obj ch8_1_blockaddr.bc -o ch8_1_blockaddr.o
${TOOLDIR}/llc -march=cpu0${endian} -mcpu=${CPU} -relocation-model=pic \
-filetype=obj -force-cpu0-long-branch ch8_2_longbranch.bc -o \
ch8_2_longbranch.o
${TOOLDIR}/llc -march=cpu0${endian} -mcpu=${CPU} -relocation-model=static \
-filetype=obj ch9_2_tailcall.bc -o ch9_2_tailcall.o
${TOOLDIR}/llc -march=cpu0${endian} -mcpu=${CPU} -relocation-model=static \
-filetype=obj ch9_3_detect_exception.bc -o ch9_3_detect_exception.o
${TOOLDIR}/llc -march=cpu0${endian} -mcpu=${CPU} -relocation-model=static \
-filetype=obj ch_slinker.bc -o ch_slinker.o
${TOOLDIR}/llc -march=cpu0${endian} -mcpu=${CPU} -relocation-model=static \
-filetype=obj lib_cpu0.ll -o lib_o
${TOOLDIR}/lld -flavor gnu -target cpu0${endian}-unknown-linux-gnu start.o \
debug.o printf-stdarg-def.o printf-stdarg.o ch4_1_addsuboverflow.o \
ch8_1_br_jt.o ch8_2_phinode.o ch8_1_blockaddr.o ch8_2_longbranch.o \
ch9_2_tailcall.o ch9_3_detect_exception.o ch_slinker.o lib_o -o a.out

epilogue;

</pre></div>
</div>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">1-160-136-173:input Jonathan$</span> <span class="nb">pwd</span>
<span class="go">/Users/Jonathan/test/lbt/exlbt/input</span>
<span class="gp">114-37-148-111:input Jonathan$</span> bash build-slinker.sh cpu032I le
<span class="go">...</span>
<span class="go">In file included from ch_slinker.cpp:23:</span>
<span class="go">./ch_lld_staticlink.cpp:8:15: warning: conversion from string literal to</span>
<span class="go">&#39;char *&#39; is deprecated</span>
<span class="go">      [-Wdeprecated-writable-strings]</span>
<span class="go">  char *ptr = &quot;Hello world!&quot;;</span>
<span class="go">              ^</span>
<span class="go">1 warning generated.</span>
<span class="gp">114-37-148-111:input Jonathan$</span> <span class="nb">cd</span> ../../lbdex/verilog/
<span class="gp">114-37-148-111:verilog Jonathan$</span> ./cpu0IIsp
<span class="go">WARNING: ./cpu0.v:369: $readmemh(cpu0.hex): Not enough words in the file for</span>
<span class="go">the requested range [0:524287].</span>
<span class="go">taskInterrupt(001)</span>
<span class="go">...</span>
<span class="go">test_nolld(): PASS</span>
<span class="go">taskInterrupt(011)</span>
<span class="go">Overflow exception</span>
<span class="go">taskInterrupt(011)</span>
<span class="go">Overflow exception</span>
<span class="go">test_overflow = 0, PASS</span>
<span class="go">global variable gI = 100, PASS</span>
<span class="go">test_ctrl2(): a = 1, b = 0, c = 1, d = 0, PASS</span>
<span class="go">test_phinode(3, 1) = 3, PASS</span>
<span class="go">test_blockaddress(1) = 1, PASS</span>
<span class="go">test_blockaddress(2) = 2, PASS</span>
<span class="go">date1 = 2012 10 12 1 2 3, PASS</span>
<span class="go">date2 = 2012 10 12 1 2 3, PASS</span>
<span class="go">time2 = 1 10 12, PASS</span>
<span class="go">time3 = 1 10 12, PASS</span>
<span class="go">date1 = 2013 1 26 12 21 10, PASS</span>
<span class="go">date2 = 2013 1 26 12 21 10, PASS</span>
<span class="go">test_template() = 15, PASS</span>
<span class="go">test_alloc() = 31, PASS</span>
<span class="go">exceptionOccur= 1, PASS</span>
<span class="go">exceptionOccur= 0, PASS</span>
<span class="go">inlineasm_global() = 4, PASS</span>
<span class="go">20</span>
<span class="go">10</span>
<span class="go">5</span>
<span class="go">test_cpp_polymorphism() = 0, PASS</span>
<span class="go">taskInterrupt(011)</span>
<span class="go">Software interrupt</span>
<span class="go">taskInterrupt(011)</span>
<span class="go">Harware interrupt 0</span>
<span class="go">taskInterrupt(011)</span>
<span class="go">Harware interrupt 1</span>
<span class="go">...</span>
</pre></div>
</div>
<p>As above, by taking the open source code advantage, Cpu0 got the more stable
printf() program.
Once Cpu0 backend can translate the printf() function of the open source C
printf() program into machine instructions, the llvm Cpu0 backend can be
verified with printf().
With the quality code of open source printf() program, the Cpu0 toolchain is
extended from compiler backend to C std library support. (Notice that some GPL
open source code are not quality code, but some are.)</p>
<p>The &#8220;Overflow exception is printed twice meaning the ISR() of debug.cpp is
called twice from ch4_1_2.cpp.
The printed &#8220;taskInterrupt(001)&#8221; and &#8220;taskInterrupt(011)&#8221; just are trace
message from cpu0.v code.</p>
</div>
<div class="section" id="cpu0-lld-structure">
<h4><a class="toc-backref" href="#id47">Cpu0 lld structure</a><a class="headerlink" href="#cpu0-lld-structure" title="Permalink to this headline">¶</a></h4>
<div class="figure align-center" id="id23">
<span id="lld-f1"></span><a class="reference internal image-reference" href="_images/12.png"><img alt="_images/12.png" src="_images/12.png" style="width: 752.0px; height: 823.0px;" /></a>
<p class="caption"><span class="caption-number">Fig. 6 </span><span class="caption-text">Cpu0 lld class relationship</span></p>
</div>
<div class="figure align-center" id="id24">
<span id="lld-f2"></span><a class="reference internal image-reference" href="_images/2.png"><img alt="_images/2.png" src="_images/2.png" style="width: 459.2px; height: 699.2px;" /></a>
<p class="caption"><span class="caption-number">Fig. 7 </span><span class="caption-text">Cpu0 lld ELFLinkingContext and DefaultLayout member functions</span></p>
</div>
<p>The Cpu0LinkingContext include the context information for those input obj
files and output execution file you want to link.
When do linking, the code added in GnuLdDriver.cpp will create
Cpu0LinkingContext.</p>
<p>While Cpu0LinkingContext is created by lld ELF driver as above, the
code in Cpu0LinkingContext constructor will create Cpu0TargetHandler and passing
the Cpu0LinkingContext object pointer to Cpu0TargeHandler.</p>
<p>Finally, the Cpu0TargeHandler constructor will create other related objects
and set up the relation reference object pointers as <a class="reference internal" href="#lld-f1"><span class="std std-numref">Fig. 6</span></a>
depicted.</p>
<p>According chapter ELF, the linker stands for resolve the relocation records.
The following code give the chance to let lld system call our relocation
function at proper time.</p>
<p class="rubric">exlbt/lld/lib/ReaderWriter/ELF/Cpu0/Cpu0RelocationPass.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>
<span class="n">std</span><span class="p">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Pass</span><span class="o">&gt;</span>
<span class="n">lld</span><span class="p">::</span><span class="n">elf</span><span class="p">::</span><span class="n">createCpu0RelocationPass</span><span class="p">(</span><span class="n">const</span> <span class="n">Cpu0LinkingContext</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">switch</span> <span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">getOutputELFType</span><span class="p">())</span> <span class="p">{</span>
  <span class="n">case</span> <span class="n">llvm</span><span class="p">::</span><span class="n">ELF</span><span class="p">::</span><span class="n">ET_EXEC</span><span class="p">:</span>
  <span class="o">//</span> <span class="n">when</span> <span class="n">the</span> <span class="n">output</span> <span class="n">file</span> <span class="ow">is</span> <span class="n">execution</span> <span class="n">file</span><span class="p">:</span> <span class="n">e</span><span class="o">.</span><span class="n">g</span><span class="o">.</span> <span class="n">a</span><span class="o">.</span><span class="n">out</span>
<span class="c1">#ifdef DLINKER</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">isDynamic</span><span class="p">())</span>
      <span class="k">return</span> <span class="n">llvm</span><span class="p">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">DynamicRelocationPass</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
    <span class="k">else</span>
      <span class="k">return</span> <span class="n">std</span><span class="p">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Pass</span><span class="o">&gt;</span><span class="p">(</span><span class="n">new</span> <span class="n">StaticRelocationPass</span><span class="p">(</span><span class="n">ctx</span><span class="p">));</span>
<span class="c1">#else</span>
    <span class="k">return</span> <span class="n">llvm</span><span class="p">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">StaticRelocationPass</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
<span class="c1">#endif // DLINKER</span>
<span class="c1">#ifdef DLINKER</span>
  <span class="n">case</span> <span class="n">llvm</span><span class="p">::</span><span class="n">ELF</span><span class="p">::</span><span class="n">ET_DYN</span><span class="p">:</span>
  <span class="o">//</span> <span class="n">when</span> <span class="n">the</span> <span class="n">output</span> <span class="n">file</span> <span class="ow">is</span> <span class="n">shared</span> <span class="nb">object</span><span class="p">:</span> <span class="n">e</span><span class="o">.</span><span class="n">g</span><span class="o">.</span> <span class="n">foobar</span><span class="o">.</span><span class="n">so</span>
    <span class="k">return</span> <span class="n">llvm</span><span class="p">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">DynamicRelocationPass</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
<span class="c1">#endif // DLINKER</span>
  <span class="n">case</span> <span class="n">llvm</span><span class="p">::</span><span class="n">ELF</span><span class="p">::</span><span class="n">ET_REL</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">nullptr</span><span class="p">;</span>
  <span class="n">default</span><span class="p">:</span>
    <span class="n">llvm_unreachable</span><span class="p">(</span><span class="s2">&quot;Unhandled output file type&quot;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The &#8220;#ifdef DLINKER&#8221; part is for dynamic linker which will be used in next
section.
For static linker, a StaticRelocationPass object is created and return.</p>
<p>Now the following code of Cpu0TargetRelocationHandler::applyRelocation()
will be called through
Cpu0TargetHandler by lld ELF driver when it meets each relocation record.</p>
<p class="rubric">exlbt/lld/lib/ReaderWriter/ELF/Cpu0/Cpu0RelocationHandler.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">ErrorOr</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">Cpu0TargetRelocationHandler</span><span class="o">::</span><span class="n">applyRelocation</span><span class="p">(</span>
    <span class="n">ELFWriter</span> <span class="o">&amp;</span><span class="n">writer</span><span class="p">,</span> <span class="n">llvm</span><span class="o">::</span><span class="n">FileOutputBuffer</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="n">lld</span><span class="o">::</span><span class="n">AtomLayout</span> <span class="o">&amp;</span><span class="n">atom</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">Reference</span> <span class="o">&amp;</span><span class="n">ref</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>

  <span class="k">switch</span> <span class="p">(</span><span class="n">ref</span><span class="p">.</span><span class="n">kind</span><span class="p">())</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nl">R_CPU0_NONE</span><span class="p">:</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="nl">R_CPU0_HI16</span><span class="p">:</span>
    <span class="n">relocHI16</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">relocVAddress</span><span class="p">,</span> <span class="n">targetVAddress</span><span class="p">,</span> <span class="n">ref</span><span class="p">.</span><span class="n">addend</span><span class="p">());</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="nl">R_CPU0_LO16</span><span class="p">:</span>
    <span class="n">relocLO16</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">relocVAddress</span><span class="p">,</span> <span class="n">targetVAddress</span><span class="p">,</span> <span class="n">ref</span><span class="p">.</span><span class="n">addend</span><span class="p">());</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="p">...</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">error_code</span><span class="o">::</span><span class="n">success</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">exlbt/lld/Cpu0/Cpu0TargetHandler.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Cpu0TargetHandler</span> <span class="nl">LLVM_FINAL</span>
    <span class="p">:</span> <span class="k">public</span> <span class="n">DefaultTargetHandler</span><span class="o">&lt;</span><span class="n">Cpu0ELFType</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="p">..</span>
  <span class="k">virtual</span> <span class="k">const</span> <span class="n">Cpu0TargetRelocationHandler</span> <span class="o">&amp;</span><span class="n">getRelocationHandler</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">_relocationHandler</span><span class="p">;</span>
  <span class="p">}</span>
</pre></div>
</div>
<p>Summary as <a class="reference internal" href="#lld-f4"><span class="std std-numref">Fig. 8</span></a>.</p>
<div class="figure align-center" id="id25">
<span id="lld-f4"></span><a class="reference internal image-reference" href="_images/4.png"><img alt="_images/4.png" src="_images/4.png" style="width: 333.6px; height: 566.4px;" /></a>
<p class="caption"><span class="caption-number">Fig. 8 </span><span class="caption-text">Cpu0 lld related objects created sequence</span></p>
</div>
<p>Remind, static std::unique_ptr&lt;ELFLinkingContext&gt;
ELFLinkingContext::create(llvm::Triple) is called without an object of
class ELFLinkingContext instance (because the static keyword).
The Cpu0LinkingContext constructor will create it&#8217;s ELFLinkingContext part.
The std::unique_ptr came from c++11 standard.
The unique_ptr objects automatically delete the object they manage (using a
deleter) as soon as themselves are destroyed. Just like the Singlelten
pattern in Design Pattern book or Smart Pointers in Effective C++ book.
[#effectiveC++]_</p>
<div class="figure align-center" id="id26">
<span id="lld-f5"></span><a class="reference internal image-reference" href="_images/5.png"><img alt="_images/5.png" src="_images/5.png" style="width: 804.0px; height: 601.0px;" /></a>
<p class="caption"><span class="caption-number">Fig. 9 </span><span class="caption-text">Cpu0LinkingContext get Cpu0TargetHandler through &amp;getTargetHandler()</span></p>
</div>
<p>As <a class="reference internal" href="#lld-f1"><span class="std std-numref">Fig. 6</span></a> depicted, the Cpu0TargetHandler include the members or
pointers which can access to other object. The way to access Cpu0TargetHandler
object from Cpu0LinkingContext or Cpu0RelocationHandler rely on
LinkingContext::getTargetHandler() function. As <a class="reference internal" href="#lld-f5"><span class="std std-numref">Fig. 9</span></a> depicted,
the unique_ptr point to Cpu0TargetHandler will be saved in LinkingContext
contructor function.</p>
<p>List the c++11 unique_ptr::get() and move() which used in <a class="reference internal" href="#lld-f5"><span class="std std-numref">Fig. 9</span></a>
as follows.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>std::unique_ptr::get() <a class="footnote-reference" href="#get" id="id4">[4]</a></p>
<p>pointer get() const noexcept;</p>
<p class="last">Get pointer
Returns the stored pointer.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>std::move() <a class="footnote-reference" href="#move" id="id5">[5]</a></p>
<dl class="last docutils">
<dt>for example:</dt>
<dd><p class="first">std::string bar = &#8220;bar-string&#8221;;
std::move(bar);</p>
<p class="last">bar is null after std::move(bar);</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="section" id="dynamic-linker">
<h3><a class="toc-backref" href="#id48">Dynamic linker</a><a class="headerlink" href="#dynamic-linker" title="Permalink to this headline">¶</a></h3>
<p>In addition to the lld code with #ifdef DLINKER. The following code in Verilog
exists to support dynamic linker.</p>
<p class="rubric">lbdex/verilog/dynlinker.v</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>`define DLINKER_INFO_ADDR  &#39;h70000
`define GPADDR    &#39;h7FFF0

`ifdef DLINKER
  task setDynLinkerInfo; begin
// below code set memory as follows,
//                                                            (4 bytes) 
//                                               ---------------------------------------
// DLINKER_INFO_ADDR ----------&gt;                 | numDynEntry                         |
//                                               ---------------------------------------
// DLINKER_INFO_ADDR+4 --------&gt;                 | index of dynsym (0st row)           |
//   above is the 1st word of section .dynsym of libfoobar.cpu0.so. 
// DLINKER_INFO_ADDR+8 --------&gt;                 | index of dynsym (1st row)           |
//                                               | ...                                 |
// DLINKER...+(numDynEntry-1)*4 ---------------&gt; | index of dynsym (the last row)      |
//                                               ---------------------------------------
// DLINKER...+numDynEntry*4 -------------------&gt; | 1st function (la()) offset in lib   |
// DLINKER...+numDynEntry*4+4 -----------------&gt; | 1st function (la()) name (48 bytes) |
//                                               | ...                                 |
// DLINKER...+numDynEntry+(numDynEntry-1)*4 ---&gt; | last function (bar()) offset in lib |
// DLINKER...+numDynEntry+(numDynEntry-1)*4+4 -&gt; | last function (bar()) name          |
//                                               ---------------------------------------
// DLINKER...+4+numDynEntry*4+numDynEntry*52 --&gt; | .dynstr of lib                      |
//                                               |   ...                               |
//                                               ---------------------------------------
  // caculate number of dynamic entries
    numDynEntry = 0;
    j = 0;
    for (i=0; i &lt; 384 &amp;&amp; j == 0; i=i+52) begin
       if (so_func_offset[i] == `MEMEMPTY &amp;&amp; so_func_offset[i+1] == `MEMEMPTY &amp;&amp; 
           so_func_offset[i+2] == `MEMEMPTY &amp;&amp; so_func_offset[i+3] == `MEMEMPTY) begin
         numDynEntry = i/52;
         j = 1;
       `ifdef DEBUG_DLINKER
         $display(&quot;numDynEntry = %8x&quot;, numDynEntry);
       `endif
       end
    end
  // save number of dynamic entries to memory address `DLINKER_INFO_ADDR
    m[`DLINKER_INFO_ADDR] = numDynEntry[31:24];
    m[`DLINKER_INFO_ADDR+1] = numDynEntry[23:16];
    m[`DLINKER_INFO_ADDR+2] = numDynEntry[15:8];
    m[`DLINKER_INFO_ADDR+3] = numDynEntry[7:0];
  // copy section .dynsym of ELF to memory address `DLINKER_INFO_ADDR+4
    i = `DLINKER_INFO_ADDR+4;
    for (j=0; j &lt; (4*numDynEntry); j=j+4) begin
      m[i] = dsym[j];
      m[i+1] = dsym[j+1];
      m[i+2] = dsym[j+2];
      m[i+3] = dsym[j+3];
      i = i + 4;
    end
  // copy the offset values of section .text of shared library .so of ELF to 
  // memory address `DLINKER_INFO_ADDR+4+numDynEntry*4
    i = `DLINKER_INFO_ADDR+4+numDynEntry*4;
    l = 0;
    for (j=0; j &lt; numDynEntry; j=j+1) begin
      for (k=0; k &lt; 52; k=k+1) begin
        m[i] = so_func_offset[l];
        i = i + 1;
        l = l + 1;
      end
    end
  `ifdef DEBUG_DLINKER
    i = `DLINKER_INFO_ADDR+4+numDynEntry*4;
    for (j=0; j &lt; (8*numDynEntry); j=j+8) begin
       $display(&quot;%8x: %8x&quot;, i, {m[i], m[i+1], m[i+2], m[i+3]});
      i = i + 8;
    end
  `endif
  // copy section .dynstr of ELF to memory address 
  // `DLINKER_INFO_ADDR+4+numDynEntry*4+numDynEntry*52
    i=`DLINKER_INFO_ADDR+4+numDynEntry*4+numDynEntry*52;
    for (j=0; dstr[j] != `MEMEMPTY; j=j+1) begin
      m[i] = dstr[j];
      i = i + 1;
    end
  `ifdef DEBUG_DLINKER
    $display(&quot;In setDynLinkerInfo()&quot;);
    for (i=`DLINKER_INFO_ADDR; i &lt; `MEMSIZE; i=i+4) begin
       if (m[i] != `MEMEMPTY || m[i+1] != `MEMEMPTY || 
         m[i+2] != `MEMEMPTY || m[i+3] != `MEMEMPTY)
         $display(&quot;%8x: %8x&quot;, i, {m[i], m[i+1], m[i+2], m[i+3]});
    end
    $display(&quot;global address %8x&quot;, {m[`GPADDR], m[`GPADDR+1], 
             m[`GPADDR+2], m[`GPADDR+3]});
    $display(&quot;gp = %8x&quot;, gp);
  `endif
// below code set memory as follows,
//                                    -----------------------------------
// gp ------------------------------&gt; | all 0                           | (16 bytes)
// gp+16 ---------------------------&gt; | 0                               |
// gp+16+1*4 -----------------------&gt; | 1st plt entry address           | (4 bytes)
//                                    | ...                             |
// gp+16+(numDynEntry-1)*4 ---------&gt; | the last plt entry address      |
//                                    -----------------------------------
// gpPlt ---------------------------&gt; | all 0                           | (16 bytes)
// gpPlt+16+0*8&#39;h10 ----------------&gt; | 32&#39;h10: pointer to plt0         |
// gpPlt+16+1*8&#39;h10 ----------------&gt; | 1st plt entry                   |
// gpPlt+16+2*8&#39;h10 ----------------&gt; | 2nd plt entry                   |
//                                    | ...                             |
// gpPlt+16+(numDynEntry-1)*8&#39;h10 --&gt; | the last plt entry              |
//                                    -----------------------------------
// note: gp point to the _GLOBAL_OFFSET_TABLE_, 
//       numDynEntry = actual number of functions + 1.
//   gp+1*4..gp+numDynEntry*4 set to 8&#39;h10 plt0 which will jump to dynamic 
//   linker.
//   After dynamic linker load function to memory, it will set gp+index*4 to 
//   function memory address. For example, if the function index is 2, then the 
//   gp+2*4 is set to the memory address of this loaded function. 
//   Then the the caller call 
//   &quot;ld $t9, 2*4($gp)&quot; and &quot;jr $t9&quot; will jump to this loaded function directly.

    gpPlt = gp+16+numDynEntry*4;
    // set (gpPlt+1..gpPlt=32) to 0
    for (j=32; j &gt;= 1; j=j-1)
      m[gpPlt+j] = 8&#39;h00;
    // put plt in (gpPlt..gpPlt+numDynEntry*8&#39;h10+1)
    for (i=1; i &lt; numDynEntry; i=i+1) begin
      // (gp+&#39;8h10..gp+numDynEntry*&#39;8h10+15) set to plt entry
      // addiu	$t9, $zero, dynsym_idx
      m[gpPlt+i*8&#39;h20] = 8&#39;h09;
      m[gpPlt+i*8&#39;h20+1] = 8&#39;h60;
      m[gpPlt+i*8&#39;h20+2] = i[15:8];
      m[gpPlt+i*8&#39;h20+3] = i[7:0];
      // st	$t9, 0($gp)
      m[gpPlt+i*8&#39;h20+4] = 8&#39;h02;
      m[gpPlt+i*8&#39;h20+5] = 8&#39;h6b;
      m[gpPlt+i*8&#39;h20+6] = 0;
      m[gpPlt+i*8&#39;h20+7] = 0;
      // ld	$t9, (&#39;16h0010)($gp)
      m[gpPlt+i*8&#39;h20+8] = 8&#39;h01;
      m[gpPlt+i*8&#39;h20+9] = 8&#39;h6b;
      m[gpPlt+i*8&#39;h20+10] = 0;
      m[gpPlt+i*8&#39;h20+11] = 8&#39;h10;
      // jr	$t9
      m[gpPlt+i*8&#39;h20+12] = 8&#39;h3c;
      m[gpPlt+i*8&#39;h20+13] = 8&#39;h60;
      m[gpPlt+i*8&#39;h20+14] = 0;
      m[gpPlt+i*8&#39;h20+15] = 0;
      for (j=0; j &lt; 16; j=j+1) m[gpPlt+i*8&#39;h20+16+j] = 0; // nop
    end

  // .got.plt offset(0x00.0x03) has been set to 0 in elf already.
  // Set .got.plt offset(8&#39;h10..numDynEntry*&#39;8h10) point to plt entry as above.
  `ifdef DEBUG_DLINKER
         $display(&quot;numDynEntry = %8x&quot;, numDynEntry);
  `endif
//      j32=32&#39;h1fc0; // m[32&#39;h1fc]=&quot;something&quot; will hang. Very tricky
    m[gp+16] = 8&#39;h0;
    m[gp+16+1] = 8&#39;h0;
    i=pltAddr[0]+16;
    m[gp+16+2] = i[15:8];   // .plt section addr + 16
    m[gp+16+3] = i[7:0];

    j32=gpPlt+32;
    for (i=1; i &lt; numDynEntry; i=i+1) begin
      m[gp+16+i*4] = j32[31:24];
      m[gp+16+i*4+1] = j32[23:16];
      m[gp+16+i*4+2] = j32[15:8];
      m[gp+16+i*4+3] = j32[7:0];
      j32=j32+32;
    end
  `ifdef DEBUG_DLINKER
    // show (gp..gp+numDynEntry*4-1)
    for (i=0; i &lt; numDynEntry; i=i+1) begin
      $display(&quot;%8x: %8x&quot;, gp+16+i*4, {m[gp+16+i*4], m[gp+16+i*4+1], 
               m[gp+16+i*4+2], m[gp+16+i*4+3]});
    end
    // show (gpPlt..gpPlt+(numDynEntry+1)*8&#39;h10-1)
    for (i=0; i &lt; numDynEntry; i=i+1) begin
      for (j=0; j &lt; 16; j=j+4)
        $display(&quot;%8x: %8x&quot;, gpPlt+i*8&#39;h20+j, 
                 {m[gpPlt+i*8&#39;h20+j], 
                  m[gpPlt+i*8&#39;h20+j+1], 
                  m[gpPlt+i*8&#39;h20+j+2], 
                  m[gpPlt+i*8&#39;h20+j+3]});
    end
  `endif
  end endtask
`endif

`ifdef DLINKER
  task loadToFlash; begin
  // erase memory
    for (i=0; i &lt; `MEMSIZE; i=i+1) begin
       flash[i] = `MEMEMPTY;
    end
    $readmemh(&quot;dlconfig/libso.hex&quot;, flash);
  `ifdef DEBUG_DLINKER
    for (i=0; i &lt; `MEMSIZE &amp;&amp; (flash[i] != `MEMEMPTY || 
         flash[i+1] != `MEMEMPTY || flash[i+2] != `MEMEMPTY || 
         flash[i+3] != `MEMEMPTY); i=i+4) begin
       $display(&quot;%8x: %8x&quot;, i, {flash[i], flash[i+1], flash[i+2], flash[i+3]});
    end
  `endif
  end endtask
`endif

`ifdef DLINKER
  task createDynInfo; begin
    $readmemh(&quot;dlconfig/global_offset&quot;, globalAddr);
    m[`GPADDR]   = globalAddr[0];
    m[`GPADDR+1] = globalAddr[1];
    m[`GPADDR+2] = globalAddr[2];
    m[`GPADDR+3] = globalAddr[3];
    gp[31:24] = globalAddr[0];
    gp[23:16] = globalAddr[1];
    gp[15:8] = globalAddr[2];
    gp[7:0] = globalAddr[3];
    $readmemh(&quot;dlconfig/plt_offset&quot;, pltAddr);
  `ifdef DEBUG_DLINKER
    $display(&quot;global address %8x&quot;, {m[`GPADDR], m[`GPADDR+1], 
             m[`GPADDR+2], m[`GPADDR+3]});
    $display(&quot;gp = %8x&quot;, gp);
    $display(&quot;pltAddr = %8x&quot;, pltAddr[0]);
  `endif
`endif
`ifdef DLINKER
    for (i=0; i &lt; 192; i=i+1) begin
       dsym[i] = `MEMEMPTY;
    end
    for (i=0; i &lt; 96; i=i+1) begin
       dstr[i] = `MEMEMPTY;
    end
    for (i=0; i &lt;384; i=i+1) begin
       so_func_offset[i] = `MEMEMPTY;
    end
    $readmemh(&quot;dlconfig/dynsym&quot;, dsym);
    $readmemh(&quot;dlconfig/dynstr&quot;, dstr);
    $readmemh(&quot;dlconfig/so_func_offset&quot;, so_func_offset);
    setDynLinkerInfo();
  end endtask
`endif

</pre></div>
</div>
<p class="rubric">lbdex/verilog/flashio.v</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>`define FLASHADDR &#39;hA0000

`ifdef DLINKER
    end else if (abus &gt;= `FLASHADDR &amp;&amp; abus &lt;= `FLASHADDR+`MEMSIZE-4) begin
      fabus = abus-`FLASHADDR;
      if (en == 1 &amp;&amp; rw == 0) begin // r_w==0:write
        data = dbus_in;
        case (m_size)
        `BYTE:  {flash[fabus]} = dbus_in[7:0];
        `INT16: {flash[fabus], flash[fabus+1] } = dbus_in[15:0];
        `INT24: {flash[fabus], flash[fabus+1], flash[fabus+2]} = dbus_in[24:0];
        `INT32: {flash[fabus], flash[fabus+1], flash[fabus+2], flash[fabus+3]} 
                = dbus_in;
        endcase
      end else if (en == 1 &amp;&amp; rw == 1) begin// r_w==1:read
        case (m_size)
        `BYTE:  data = {8&#39;h00  , 8&#39;h00,   8&#39;h00,   flash[fabus]};
        `INT16: data = {8&#39;h00  , 8&#39;h00,   flash[fabus], flash[fabus+1]};
        `INT24: data = {8&#39;h00  , flash[fabus], flash[fabus+1], flash[fabus+2]};
        `INT32: data = {flash[fabus], flash[fabus+1], flash[fabus+2], 
                       flash[fabus+3]};
        endcase
      end else
        data = 32&#39;hZZZZZZZZ;
`endif

</pre></div>
</div>
<p class="rubric">lbdex/verilog/Makefile</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>#TRACE=-D TRACE
all:
	iverilog ${TRACE} -o cpu0Is cpu0.v 
	iverilog ${TRACE} -D CPU0II -o cpu0IIs cpu0.v 
	iverilog ${TRACE} -D DLINKER -o cpu0Id cpu0.v 
	iverilog ${TRACE} -D DLINKER -D CPU0II -o cpu0IId cpu0.v 
	iverilog ${TRACE} -D SIMULATE_DELAY_SLOT -o cpu0Isp cpu0.v 
	iverilog ${TRACE} -D SIMULATE_DELAY_SLOT -D CPU0II -o cpu0IIsp cpu0.v 
	iverilog ${TRACE} -D SIMULATE_DELAY_SLOT -D DLINKER -o cpu0Idp cpu0.v 
	iverilog ${TRACE} -D SIMULATE_DELAY_SLOT -D DLINKER -D CPU0II -o cpu0IIdp cpu0.v

.PHONY: clean
clean:
	rm -rf dlconfig cpu0.hex cpu0Is cpu0IIs cpu0Id cpu0IId cpu0Isp cpu0IIsp 
	rm -f cpu0Idp cpu0IIdp *~ cpu0.config

</pre></div>
</div>
<p>The following code ch_dynamiclinker.cpp and foobar.cpp is the example for
dynamic linker demostration. File dynamic_linker.cpp is what our implementaion
to execute the dynamic linker function on Cpu0 Verilog machine.</p>
<p class="rubric">exlbt/input/debug.h</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>#ifndef _DEBUG_H_
#define _DEBUG_H_

#define STOP \
  asm(&quot;lui $t9, 0xffff&quot;); \
  asm(&quot;addiu $t9, $zero, 0xffff&quot;); \
  asm(&quot;jr $t9&quot;);

#define ENABLE_TRACE \
  asm(&quot;ori $sw, $sw, 0x0020&quot;);

#define DISABLE_TRACE \
  asm(&quot;lui $at, 0xffff&quot;);       \
  asm(&quot;ori $at, $at, 0xffdf&quot;);  \
  asm(&quot;and $sw, $sw, $at&quot;); // clear `D

#define SET_OVERFLOW \
  asm(&quot;ori $sw, $sw, 0x008&quot;);

#define CLEAR_OVERFLOW \
  asm(&quot;lui $7, 0xffff&quot;);        \
  asm(&quot;ori $7, $7, 0xfff7&quot;);    \
  asm(&quot;and $sw, $sw, $7&quot;); // clear `V

#define SET_SOFTWARE_INT \
  asm(&quot;ori $sw, $sw, 0x4000&quot;);

#define CLEAR_SOFTWARE_INT \
  asm(&quot;lui $7, 0xffff&quot;);        \
  asm(&quot;ori $7, $7, 0xbfff&quot;);    \
  asm(&quot;and $sw, $sw, $7&quot;);

#define SAVE_REGISTERS          \
  asm(&quot;lui $at, 7&quot;);            \
  asm(&quot;ori $at, $at, 0xff00&quot;);  \
  asm(&quot;st $2,   0($at)&quot;);       \
  asm(&quot;st $3,   4($at)&quot;);       \
  asm(&quot;st $4,   8($at)&quot;);       \
  asm(&quot;st $5,  12($at)&quot;);       \
  asm(&quot;st $t9, 16($at)&quot;);       \
  asm(&quot;st $7,  20($at)&quot;);       \
  asm(&quot;st $8,  24($at)&quot;);       \
  asm(&quot;st $9,  28($at)&quot;);       \
  asm(&quot;st $10, 32($at)&quot;);       \
  asm(&quot;st $gp, 36($at)&quot;);       \
  asm(&quot;st $12, 40($at)&quot;);       \
  asm(&quot;st $13, 44($at)&quot;);

#define RESTORE_REGISTERS       \
  asm(&quot;lui $at,  7&quot;);           \
  asm(&quot;ori $at,  $at, 0xff00&quot;); \
  asm(&quot;ld  $2,   0($at)&quot;);      \
  asm(&quot;ld  $3,   4($at)&quot;);      \
  asm(&quot;ld  $4,   8($at)&quot;);      \
  asm(&quot;ld  $5,  12($at)&quot;);      \
  asm(&quot;ld  $t9, 16($at)&quot;);      \
  asm(&quot;ld  $7,  20($at)&quot;);      \
  asm(&quot;ld  $8,  24($at)&quot;);      \
  asm(&quot;ld  $9,  28($at)&quot;);      \
  asm(&quot;ld  $10, 32($at)&quot;);      \
  asm(&quot;ld  $gp, 36($at)&quot;);      \
  asm(&quot;ld  $12, 40($at)&quot;);      \
  asm(&quot;ld  $13, 44($at)&quot;);

#define OVERFLOW     0x8
#define INT          0x2000
#define SOFTWARE_INT 0x4000
#define INT1         0x8000
#define INT2         0x10000

extern void int_sim();

#endif

</pre></div>
</div>
<p class="rubric">exlbt/input/dynamic_linker.h</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1">#ifndef _DYNAMIC_LINKER_H_</span>
<span class="c1">#define _DYNAMIC_LINKER_H_</span>

<span class="c1">#define DYNLINKER_INFO_ADDR  0x70000</span>
<span class="c1">#define DYNENT_SIZE          4</span>
<span class="c1">#define DYNPROGSTART         0x40000</span>
<span class="c1">#define FLASHADDR            0xA0000</span>
<span class="c1">#define GPADDR               0x7FFF0</span>

<span class="c1">#include &quot;debug.h&quot;</span>

<span class="n">struct</span> <span class="n">ProgAddr</span> <span class="p">{</span>
  <span class="nb">int</span> <span class="n">memAddr</span><span class="p">;</span>
  <span class="nb">int</span> <span class="n">size</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">extern</span> <span class="n">void</span> <span class="n">dynamic_linker_init</span><span class="p">();</span>
<span class="n">extern</span> <span class="n">void</span> <span class="n">dynamic_linker</span><span class="p">();</span>

<span class="c1">#endif</span>
</pre></div>
</div>
<p class="rubric">exlbt/input/dynamic_linker.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>
#include &quot;dynamic_linker.h&quot;

//#define DEBUG_DLINKER
#define PLT0ADDR 0x10
#define REGADDR  0x7ff00

extern &quot;C&quot; int printf(const char *format, ...);

int got_plt_fill[0x80] = {
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
};

int progCounter = 0; // program counter, init to 0 in main()

ProgAddr prog[10];

void dynamic_linker()
{
  SAVE_REGISTERS;
//  static ProgAddr prog[10]; // has side effect (ProgAddr cannot be written in 
// Virtual Box on iMac).
  int i = 0;
  int nextFreeAddr;
  int *src, *dest, *end;
  int numDynEntry = 0;
  int dynsym_idx = 0;
  int dynsym = 0;
  char *dynstr = 0;
  int libOffset = 0;
  int nextFunLibOffset = 0;
  volatile int memAddr = 0;
  numDynEntry = *((int*)(DYNLINKER_INFO_ADDR));
  int gp = *(int*)GPADDR;
#ifdef DEBUG_DLINKER
  printf(&quot;gp = %d\n&quot;, gp);
#endif
  dynsym_idx = *(int*)gp;
#ifdef DEBUG_DLINKER
  printf(&quot;numDynEntry = %d, dynsym_idx = %d\n&quot;, numDynEntry, dynsym_idx);
#endif
  dynsym = *(int*)((DYNLINKER_INFO_ADDR+4)+(dynsym_idx*DYNENT_SIZE));
  dynstr = (char*)(DYNLINKER_INFO_ADDR+4+numDynEntry*4+numDynEntry*52+dynsym);
  libOffset = *((int*)(DYNLINKER_INFO_ADDR+4+numDynEntry*4+(dynsym_idx-1)*52));
  for (i = dynsym_idx; i &lt; numDynEntry; i++) {
    nextFunLibOffset = *((int*)(DYNLINKER_INFO_ADDR+4+numDynEntry*4+i*52));
    if (libOffset != nextFunLibOffset)
      break;
  }
#ifdef DEBUG_DLINKER
  printf(&quot;address of dstr = %x, dynsym = %d, dstr = %s\n&quot;, 
         (int)dynstr, dynsym, dynstr);
  printf(&quot;libOffset = %d, nextFunLibOffset = %d, progCounter = %d\n&quot;, 
         libOffset, nextFunLibOffset, progCounter);
#endif
  if (progCounter == 0)
     nextFreeAddr = DYNPROGSTART;
  else
     nextFreeAddr = prog[progCounter-1].memAddr+prog[progCounter-1].size;
  prog[progCounter].memAddr = nextFreeAddr;
  prog[progCounter].size = (nextFunLibOffset - libOffset);

#ifdef DEBUG_DLINKER
  printf(&quot;prog[progCounter].memAddr = %d, prog[progCounter].size = %d\n&quot;, 
         prog[progCounter].memAddr, (unsigned int)(prog[progCounter].size));
#endif
  // Load program from (FLASHADDR+libOffset..FLASHADDR+nextFunLibOffset-1) to
  // (nextFreeAddr..nextFreeAddr+prog[progCounter].size-1)
  src = (int*)(FLASHADDR+libOffset);
  end = (int*)(src+prog[progCounter].size/4);
#ifdef DEBUG_DLINKER
  printf(&quot;end = %x, src = %x, nextFreeAddr = %x\n&quot;, 
         (unsigned int)end, (unsigned int)src, (unsigned int)nextFreeAddr);
  printf(&quot;*src = %x\n&quot;, (unsigned int)(*src));
#endif
  printf(&quot;loading %s...\n&quot;, dynstr);
  for (dest = (int*)(prog[progCounter].memAddr); src &lt; end; src++, dest++) {
    *dest = *src;
#ifdef DEBUG_DLINKER
    printf(&quot;*dest = %08x\n&quot;, (unsigned int)(*dest));
#endif
  }
  progCounter++;

#ifdef DEBUG_DLINKER
  printf(&quot;progCounter-1 = %x, prog[progCounter-1].memAddr = %x, \
         *prog[progCounter-1].memAddr = %x\n&quot;, 
         (unsigned int)(progCounter-1), (unsigned int)(prog[progCounter-1].memAddr), 
         *(unsigned int*)(prog[progCounter-1].memAddr));
#endif
  // Change .got.plt for &quot;ld	$t9, idx($gp)&quot;
  *((int*)(gp+0x10+dynsym_idx*0x04)) = prog[progCounter-1].memAddr;
  *(int*)(0x7FFE0) = prog[progCounter-1].memAddr;
#ifdef DEBUG_DLINKER
  printf(&quot;*((int*)(gp+0x10+dynsym_idx*0x10)) = %x, *(int*)(0x7FFE0) = %x\n&quot;, 
         *((int*)(gp+0x10+dynsym_idx*0x10)), (unsigned int)(*(int*)(0x7FFE0)));
  printf(&quot;*((int*)(gp+0x04)) = %x, *((int*)(gp+0x08)) = %x, *((int*)(gp+0x0c)) = %x\n&quot;, 
         *((int*)(gp+0x04)), *((int*)(gp+0x08)), *((int*)(gp+0x0c)));
#endif
  printf(&quot;run %s...\n&quot;, dynstr);
  RESTORE_REGISTERS;

  // restore $lr. The next instruction of foo() of main.cpp for the main.cpp
  // call foo() first time example.
  // The $lr, $fp and $sp saved in cpu0Plt0AtomContent of Cpu0LinkingContext.cpp.
  asm(&quot;ld $lr, 4($gp)&quot;); // restore $lr
#ifdef DEBUG_DLINKER
  ENABLE_TRACE;
#endif
  asm(&quot;ld $fp, 8($gp)&quot;); // restore $fp
  asm(&quot;ld $sp, 12($gp)&quot;); // restore $sp
#ifdef DEBUG_DLINKER
  DISABLE_TRACE;
#endif
  // jmp to the dynamic linked function. It&#39;s foo() for the 
  // caller, ch_dynamic_linker.cpp, call foo() 
  // first time example.
  asm(&quot;lui $t9, 0x7&quot;);
  asm(&quot;ori $t9, $t9, 0xFFE0&quot;);
  asm(&quot;ld $t9, 0($t9)&quot;);
  asm(&quot;jr $t9&quot;);
  asm(&quot;nop&quot;);

  return;
}

</pre></div>
</div>
<p class="rubric">exlbt/input/ch_dynamiclinker.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1">#include &quot;dynamic_linker.h&quot;</span>
<span class="c1">#include &quot;print.h&quot;</span>

<span class="n">extern</span> <span class="s2">&quot;C&quot;</span> <span class="nb">int</span> <span class="n">printf</span><span class="p">(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="nb">format</span><span class="p">,</span> <span class="o">...</span><span class="p">);</span>

<span class="n">extern</span> <span class="nb">int</span> <span class="n">la</span><span class="p">(</span><span class="nb">int</span> <span class="n">x1</span><span class="p">,</span> <span class="nb">int</span> <span class="n">x2</span><span class="p">);</span>
<span class="n">extern</span> <span class="nb">int</span> <span class="n">foo</span><span class="p">(</span><span class="nb">int</span> <span class="n">x1</span><span class="p">,</span> <span class="nb">int</span> <span class="n">x2</span><span class="p">);</span>
<span class="n">extern</span> <span class="nb">int</span> <span class="n">bar</span><span class="p">();</span>

<span class="nb">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="o">//</span>  <span class="n">ENABLE_TRACE</span><span class="p">;</span>
  <span class="nb">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="c1">#if 1</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;foo(1, 2) = </span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
<span class="c1">#endif</span>
<span class="c1">#if 1</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">bar</span><span class="p">();</span>
  <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;bar() = </span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
<span class="c1">#endif</span>
<span class="c1">#if 0</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;foo(1, 2) = </span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
<span class="c1">#endif</span>
  
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">exlbt/input/foobar.cpp</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>
<span class="c1">#include &quot;dynamic_linker.h&quot;</span>

<span class="nb">int</span> <span class="n">la</span><span class="p">(</span><span class="nb">int</span> <span class="n">x1</span><span class="p">,</span> <span class="nb">int</span> <span class="n">x2</span><span class="p">)</span>
<span class="p">{</span>
  <span class="nb">int</span> <span class="nb">sum</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">x2</span><span class="p">;</span>
  
  <span class="k">return</span> <span class="nb">sum</span><span class="p">;</span> 
<span class="p">}</span>

<span class="nb">int</span> <span class="n">foo</span><span class="p">(</span><span class="nb">int</span> <span class="n">x1</span><span class="p">,</span> <span class="nb">int</span> <span class="n">x2</span><span class="p">)</span>
<span class="p">{</span>
  <span class="nb">int</span> <span class="nb">sum</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">x2</span><span class="p">;</span>
  
  <span class="k">return</span> <span class="nb">sum</span><span class="p">;</span> 
<span class="p">}</span>

<span class="c1">#if 0</span>
<span class="nb">int</span> <span class="n">factorial</span><span class="p">(</span><span class="nb">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="n">factorial</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">#endif</span>

<span class="nb">int</span> <span class="n">bar</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nb">int</span> <span class="n">a</span><span class="p">;</span>
<span class="o">//</span>  <span class="n">ENABLE_TRACE</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">foo</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
  <span class="n">a</span> <span class="o">+=</span> <span class="n">la</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="o">//</span> <span class="mi">4</span><span class="o">+</span><span class="mi">7</span><span class="o">=</span><span class="mi">11</span>
<span class="o">//</span>  <span class="n">a</span> <span class="o">+=</span> <span class="n">factorial</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="o">//</span> <span class="mi">11</span><span class="o">+</span><span class="mi">24</span><span class="o">=</span><span class="mi">35</span>

  <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>

</pre></div>
</div>
<p class="rubric">exlbt/input/build-dlinker.sh</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>#!/usr/bin/env bash

source functions.sh

sh_name=build-dlinker.sh
argNum=$#
arg1=$1
arg2=

prologue;

rm -rf dlconfig
mkdir dlconfig

${CLANGDIR}/clang -target mips-unknown-linux-gnu -c start.cpp -emit-llvm -o start.bc
${CLANGDIR}/clang -target mips-unknown-linux-gnu -c debug.cpp -emit-llvm -o debug.bc
${CLANGDIR}/clang -target mips-unknown-linux-gnu -c dynamic_linker.cpp -emit-llvm \
-o dynamic_linker.cpu0.bc
${CLANGDIR}/clang -target mips-unknown-linux-gnu -c printf-stdarg-def.c -emit-llvm \
-o printf-stdarg-def.bc
${CLANGDIR}/clang -target mips-unknown-linux-gnu -c printf-stdarg.c -emit-llvm \
-o printf-stdarg.bc
${CLANGDIR}/clang -target mips-unknown-linux-gnu -c ch_dynamiclinker.cpp -emit-llvm \
-o ch_dynamiclinker.cpu0.bc
${CLANGDIR}/clang -target mips-unknown-linux-gnu -c foobar.cpp -emit-llvm -o foobar.cpu0.bc
${TOOLDIR}/llc -march=cpu0 -mcpu=${CPU} -relocation-model=static -filetype=obj \
-cpu0-reserve-gp=true dynamic_linker.cpu0.bc -o dynamic_linker.cpu0.o
${TOOLDIR}/llc -march=cpu0 -mcpu=${CPU} -relocation-model=static -filetype=obj \
printf-stdarg-def.bc -o printf-stdarg-def.cpu0.o
${TOOLDIR}/llc -march=cpu0 -mcpu=${CPU} -relocation-model=static -filetype=obj \
-cpu0-reserve-gp=true printf-stdarg.bc -o printf-stdarg.cpu0.o
${TOOLDIR}/llc -march=cpu0 -mcpu=${CPU} -relocation-model=pic -filetype=obj \
-cpu0-reserve-gp=true -cpu0-no-cpload=true foobar.cpu0.bc -o foobar.cpu0.o
${TOOLDIR}/llc -march=cpu0 -mcpu=${CPU} -relocation-model=static -filetype=obj \
lib_cpu0.ll -o lib_cpu0.o
${TOOLDIR}/lld -flavor gnu -target cpu0-unknown-linux-gnu -shared -o \
libfoobar.cpu0.so foobar.cpu0.o
${TOOLDIR}/llc -march=cpu0 -mcpu=${CPU} -relocation-model=static -filetype=obj \
-cpu0-reserve-gp=true start.bc -o start.cpu0.o
${TOOLDIR}/llc -march=cpu0 -mcpu=${CPU} -relocation-model=static \
-filetype=obj debug.bc -o debug.cpu0.o
${TOOLDIR}/llc -march=cpu0 -mcpu=${CPU} -relocation-model=static -filetype=obj \
-cpu0-reserve-gp=true ch_dynamiclinker.cpu0.bc -o ch_dynamiclinker.cpu0.o
${TOOLDIR}/lld -flavor gnu -target cpu0-unknown-linux-gnu -o a.out \
start.cpu0.o \
printf-stdarg-def.cpu0.o printf-stdarg.cpu0.o dynamic_linker.cpu0.o \
ch_dynamiclinker.cpu0.o libfoobar.cpu0.so lib_cpu0.o debug.cpu0.o
${TOOLDIR}/elf2hex -le=false -cpu0dumpso libfoobar.cpu0.so \
&gt; dlconfig/libso.hex
${TOOLDIR}/elf2hex -le=false -cpu0linkso a.out &gt; cpu0.hex
cp -rf dlconfig cpu0.hex ../../lbdex/verilog/.
echo &quot;0   /* 0: big endian, 1: little endian */&quot; &gt; ../../lbdex/verilog/cpu0.config
cat ../../lbdex/verilog/cpu0.config

</pre></div>
</div>
<div class="section" id="id6">
<h4><a class="toc-backref" href="#id49">Run</a><a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h4>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="go">1-160-136-173 input Jonathan$ pwd</span>
<span class="go">/Users/Jonathan/test/lbt/exlbt/input</span>
<span class="gp">1-160-136-173:input Jonathan$</span> bash build-dlinker.sh cpu032II
<span class="gp">1-160-136-173:input Jonathan$</span> <span class="nb">cd</span> ../../lbdex/verilog/
<span class="gp">1-160-136-173:verilog Jonathan$</span> <span class="nb">pwd</span>
<span class="go">/Users/Jonathan/test/lbt/lbdex/verilog</span>
<span class="gp">1-160-136-173:verilog Jonathan$</span> make
<span class="gp">1-160-136-173:verilog Jonathan$</span> ls
<span class="go">...  cpu0IIdsp  ...</span>
<span class="gp">1-160-136-173:verilog Jonathan$</span> ./cpu0IIdp
<span class="go">WARNING: ./cpu0.v:371: $readmemh(cpu0.hex): Not enough words in the file for</span>
<span class="go">the requested range [0:524287].</span>
<span class="go">WARNING: ./dynlinker.v:185: $readmemh(libso.hex): Not enough words in the</span>
<span class="go">file for the requested range [0:524287].</span>
<span class="go">WARNING: ./dynlinker.v:223: $readmemh(dynsym): Not enough words in the file</span>
<span class="go">for the requested range [0:191].</span>
<span class="go">WARNING: ./dynlinker.v:224: $readmemh(dynstr): Not enough words in the file</span>
<span class="go">for the requested range [0:95].</span>
<span class="go">WARNING: ./dynlinker.v:225: $readmemh(so_func_offset): Not enough words in</span>
<span class="go">the file for the requested range [0:383].</span>
<span class="go">numDynEntry = 00000005</span>
<span class="go">taskInterrupt(001)</span>
<span class="go">loading _Z3fooii...</span>
<span class="go">run _Z3fooii...</span>
<span class="go">foo(1, 2) = 3</span>
<span class="go">loading _Z3barv...</span>
<span class="go">run _Z3barv...</span>
<span class="go">loading _Z2laii...</span>
<span class="go">run _Z2laii...</span>
<span class="go">bar() = 11</span>
<span class="go">...</span>
</pre></div>
</div>
<p>The &#8220;#ifdef DEBUG_DLINKER&#8221; part of code in dynamic_linker.cpp is for debugging
purpose (since we coding it and take time to debug). After skip these debug
code, the dynamic_linker.cpp is short and not difficult to read.</p>
<p>The run result is under expectation. The main() call foo() function first.
Function foo() is loaded by dynamic linker (dynamic_linker.cpp) from flash
address FLASHADDR (defined in dynamic_linker.h) to memory.
The flashio.v implement the simulation read from flash address.
After loaded foo() body from flash, dynamic_linker.cpp jump to this loaded
address by &#8220;jr $t9&#8221; instruction.</p>
<p>Same as static linker, you can generate slt instruction instead of cmp by
change from cpu=cpu0I to cpu0=cpu0II in build-dlinker.sh and run it again to
get the same result.
Finally, since the dynamic linker is a demo implemenation, it supports big
endian only.</p>
</div>
<div class="section" id="how-to-work">
<h4><a class="toc-backref" href="#id50">How to work</a><a class="headerlink" href="#how-to-work" title="Permalink to this headline">¶</a></h4>
<p>After run build-dlinker.sh, the following files are created.</p>
<p class="rubric">lbdex/verilog/cpu0.hex</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="go">/*       0:*/ 36 00 01 9c                                  /* jmp     0x019c */</span>
<span class="go">/*       4:*/ 36 00 00 04                                  /* jmp     4 */</span>
<span class="go">/*       8:*/ 36 00 01 9c                                  /* jmp     0x019c */</span>
<span class="go">/*       c:*/ 36 ff ff fc                                  /* jmp     -4 */</span>
<span class="go">...</span>
<span class="go">/*Disassembly of section .plt:*/</span>
<span class="go">/*.PLT0:*/</span>
<span class="go">/*     1a0:*/ 36 00 00 5c /*  jmp     92*/</span>
<span class="go">/*     1a4:*/ 36 00 00 04 /*  jmp     4*/</span>
<span class="go">/*     1a8:*/ 36 00 0f cc /*  jmp     4044*/</span>
<span class="go">/*     1ac:*/ 36 ff ff fc /*  jmp     16777212*/</span>

<span class="go">/*.PLT0:*/</span>
<span class="go">/*     1b0:*/ 02 eb 00 04 /*  st      $lr, 4($gp)*/</span>
<span class="go">/*     1b4:*/ 02 cb 00 08 /*  st      $fp, 8($gp)*/</span>
<span class="go">/*     1b8:*/ 02 db 00 0c /*  st      $sp, 12($gp)*/</span>
<span class="go">/*     1bc:*/ 36 00 09 c8 /*  jmp     2504*/</span>
<span class="go">/*     1c0:*/ 00 00 00 00 /*  nop*/</span>
<span class="go">/*     1c4:*/ 00 00 00 00 /*  nop*/</span>
<span class="go">/*     1c8:*/ 00 00 00 00 /*  nop*/</span>
<span class="go">/*     1cc:*/ 00 00 00 00 /*  nop*/</span>

<span class="go">/*__plt__Z3fooii:*/</span>
<span class="go">/*     1d0:*/ 01 6b 00 18                                  /* ld      $t9, 24($gp)</span>
<span class="go">/*     1d4:*/ 3c 60 00 00 /*  jr      $t9*/</span>
<span class="go">/*     1d8:*/ 00 00 00 00 /*  nop*/</span>
<span class="go">/*     1dc:*/ 00 00 00 00 /*  nop*/</span>

<span class="go">/*__plt__Z3barv:*/</span>
<span class="go">/*     1e0:*/ 01 6b 00 1c                                  /* ld      $t9, 28($gp)</span>
<span class="go">/*     1e4:*/ 3c 60 00 00 /*  jr      $t9*/</span>
<span class="go">/*     1e8:*/ 00 00 00 00 /*  nop*/</span>
<span class="go">/*     1ec:*/ 00 00 00 00 /*  nop*/</span>
<span class="go">...</span>

<span class="go">/*main:*/</span>
<span class="go">...</span>
<span class="go">/*     ... */ 3b ff f2 b4                                  /* jsub    16773812*/ // call foo()</span>
<span class="go">...</span>
<span class="go">/*     ... */ 3b ff f3 28                                  /* jsub    16773928*/ // call printf()</span>
<span class="go">/*     ... */ 3b ff f2 a8                                  /* jsub    16773800*/ // call bar()</span>
<span class="go">...</span>
<span class="go">/*     ... */ 3b ff f3 0c                                  /* jsub    16773900*/ // call printf()</span>
<span class="go">...</span>
<span class="go">/*     ... */ 3c e0 00 00                                  /* jr      $lr*/</span>
<span class="go">...</span>
<span class="go">/*Contents of section .data:*/</span>
<span class="go">/*     ... */00 00 00 01  00 00 00 01  00 00 00 01  00 00 00 01 /*  ................*/</span>
<span class="go">...</span>
</pre></div>
</div>
<p class="rubric">lbdex/verilog/dynstr</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="go">00 5f 5a 32 6c 61 69 69 00 5f 5a 33 66 6f 6f 69 69 00 5f 5a 33 62 61 72 76 00</span>
<span class="go">5f 67 70 5f 64 69 73 70 00</span>
</pre></div>
</div>
<p class="rubric">exlbt/verilog/dynsym</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="go">00 00 00 00 00 00 00 01 00 00 00 09 00 00 00 12 00 00 00 1a</span>
</pre></div>
</div>
<p class="rubric">lbdex/verilog/global_offset</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="go">00 00 20 58</span>
</pre></div>
</div>
<p class="rubric">exlbt/input/num_dyn_entry</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="go">4</span>
</pre></div>
</div>
<p class="rubric">exlbt/input/libfoobar.cpu0.so</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">1-160-136-173:input Jonathan$</span> ~/llvm/test/cmake_debug_build/Debug/bin/
<span class="go">llvm-objdump -s libfoobar.cpu0.so</span>

<span class="go">libfoobar.cpu0.so:    file format ELF32-CPU0</span>

<span class="go">Contents of section :</span>
<span class="go">...</span>
<span class="go">Contents of section .dynsym:</span>
<span class="go"> 00bc 00000000 00000000 00000000 00000000  ................</span>
<span class="go"> 00cc 00000001 00000130 00000038 12000004  .......0...8....</span>
<span class="go"> 00dc 00000009 00000168 00000034 12000004  .......h...4....</span>
<span class="go"> 00ec 00000012 0000019c 00000074 12000004  ...........t....</span>
<span class="go"> 00fc 0000001a 00000000 00000000 10000000  ................</span>
<span class="go">Contents of section .dynstr:</span>
<span class="go"> 010c 005f5a32 6c616969 005f5a33 666f6f69  ._Z2laii._Z3fooi</span>
<span class="go"> 011c 69005f5a 33626172 76005f67 705f6469  i._Z3barv._gp_di</span>
<span class="go"> 012c 737000                               sp.</span>
</pre></div>
</div>
<p class="rubric">exlbt/input/a.out</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">1-160-136-173:input Jonathan$</span> ~/llvm/test/cmake_debug_build/Debug/bin/
<span class="go">llvm-objdump -s a.out</span>

<span class="go">a.out:        file format ELF32-CPU0</span>

<span class="go">Contents of section :</span>
<span class="go">...</span>
<span class="go">Contents of section .dynsym:</span>
<span class="go"> 013c 00000000 00000000 00000000 00000000  ................</span>
<span class="go"> 014c 00000001 00000000 00000000 12000000  ................</span>
<span class="go"> 015c 0000000a 00000000 00000000 12000000  ................</span>
<span class="go">Contents of section .dynstr:</span>
<span class="go"> 016c 005f5a33 666f6f69 69005f5a 33626172  ._Z3fooii._Z3bar</span>
<span class="go"> 017c 76006c69 62666f6f 6261722e 63707530  v.libfoobar.cpu0</span>
<span class="go"> 018c 2e736f00                             .so.</span>
<span class="go">...</span>
<span class="go">Contents of section .got.plt:</span>
<span class="go"> 2068 00000000 00000000 00000000 00000000  ................</span>
<span class="go"> 2078 00000000 00000000 00000000 00000000  ................</span>
<span class="go"> 2088 000001d0 00000000 00000000 00000000  ................</span>
<span class="go"> 2098 000001e0 00000000 00000000 00000000  ................</span>
<span class="go">Contents of section .data:</span>
<span class="go"> 20a8 00000001 00000001 00000001 00000001  ................</span>
</pre></div>
</div>
<p>File dynstr is section .dynstr of libfoobar.cpu0.so. File dynsym is the first
4 bytes of every entry of .dynsym from libfoobar.cpu0.so.
File global_offset contains the start address of section .got.plt of a.out.</p>
<p>The code of dynlinker.v will set the memory as follows after program is loaded.
(gp value below is 2068 which come from file global_offset).</p>
<p class="rubric">memory contents</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="go">//                                    -----------------------------------</span>
<span class="go">// gp ------------------------------&gt; | all 0                           | (16 bytes)</span>
<span class="go">// gp+16 ---------------------------&gt; | 0                               |</span>
<span class="go">// gp+16+1*4 -----------------------&gt; | 1st plt entry address           | (4 bytes)</span>
<span class="go">//                                    | ...                             |</span>
<span class="go">// gp+16+(numDynEntry-1)*4 ---------&gt; | the last plt entry address      |</span>
<span class="go">//                                    -----------------------------------</span>
<span class="go">// gpPlt ---------------------------&gt; | all 0                           | (16 bytes)</span>
<span class="go">// gpPlt+16+0*8&#39;h10 ----------------&gt; | 32&#39;h10: pointer to plt0         |</span>
<span class="go">// gpPlt+16+1*8&#39;h10 ----------------&gt; | 1st plt entry                   |</span>
<span class="go">// gpPlt+16+2*8&#39;h10 ----------------&gt; | 2nd plt entry                   |</span>
<span class="go">//                                    | ...                             |</span>
<span class="go">// gpPlt+16+(numDynEntry-1)*8&#39;h10 --&gt; | the last plt entry              |</span>
<span class="go">//                                    -----------------------------------</span>
</pre></div>
</div>
<p>For example code of ch_dynamiclinker.cpp and foobar.cpp, gp is 2058, numDynEntry is
the contents of file num_dyn_entry which is 4. Every plt entry above (memory
address gp+16+1*8&#8217;h10..gp+16+(numDynEntry-1)*8&#8217;h10) is initialized to &#8220;addiu $t9,
$zero, 4($gp); st $t9, 0($gp); ld $t9, 16($gp); jr $t9&#8221; as follows,</p>
<p class="rubric">memory contents</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="go">//                                    -----------------------------------</span>
<span class="go">// gp ------------------------------&gt; | all 0                           | (16 bytes)</span>
<span class="go">// gp+16 ---------------------------&gt; | 0                               |</span>
<span class="go">// gp+16+1*4 -----------------------&gt; | 1st plt entry address           | (4 bytes)</span>
<span class="go">//                                    | ...                             |</span>
<span class="go">// gp+16+(numDynEntry-1)*4 ---------&gt; | the last plt entry address      |</span>
<span class="go">//                                    -----------------------------------</span>
<span class="go">// gpPlt ---------------------------&gt; | all 0                           | (16 bytes)</span>
<span class="go">// gpPlt+16+0*8&#39;h10 ----------------&gt; | 32&#39;h10: pointer to plt0         |</span>
<span class="go">// gpPlt+16+1*8&#39;h10 ----------------&gt; | addiu $t9, $zero, 4             |</span>
<span class="go">//                                    | st  $t9, 0($gp)                 |</span>
<span class="go">//                                    | ld  $t9, 16($gp)                |</span>
<span class="go">//                                    | jr $t9                          |</span>
<span class="go">// gpPlt+16+2*8&#39;h10 ----------------&gt; | addiu $t9, $zero, 4             |</span>
<span class="go">//                                    | st  $t9, 0($gp)                 |</span>
<span class="go">//                                    | ld  $t9, 16($gp)                |</span>
<span class="go">//                                    | jr $t9                          |</span>
<span class="go">// gpPlt+16+3*8&#39;h10 ------------&gt;     | addiu $t9, $zero, 4             |</span>
<span class="go">//                                    | st  $t9, 0($gp)                 |</span>
<span class="go">//                                    | ld  $t9, 16($gp)                |</span>
<span class="go">//                                    | jr $t9                          |</span>
<span class="go">//                                    -----------------------------------</span>
</pre></div>
</div>
<p><a class="reference internal" href="#lld-f6"><span class="std std-numref">Fig. 10</span></a> is the memory contents after the example program is loaded.</p>
<div class="figure align-center" id="id27">
<span id="lld-f6"></span><a class="reference internal image-reference" href="_images/6.png"><img alt="_images/6.png" src="_images/6.png" style="width: 385.6px; height: 590.4px;" /></a>
<p class="caption"><span class="caption-number">Fig. 10 </span><span class="caption-text">Memory contents after the program is loaded</span></p>
</div>
<div class="figure align-center" id="id28">
<span id="lld-f7"></span><a class="reference internal image-reference" href="_images/7.png"><img alt="_images/7.png" src="_images/7.png" style="width: 316.8px; height: 478.4px;" /></a>
<p class="caption"><span class="caption-number">Fig. 11 </span><span class="caption-text">Control flow transfer from calling foo() instruction of main() to dynamic linker</span></p>
</div>
<p><a class="reference internal" href="#lld-f7"><span class="std std-numref">Fig. 11</span></a> is the Control flow which transfered from call foo() of
main() to dynamic linker.
After the first time of ch_dynamiclinker.cpp call foo(), it
jump to __plt_Z3fooii plt entry.
In __plt_Z3fooii, &#8220;ld $t9, 1c($gp)&#8221; and &#8220;jr $t9&#8221; will jump to &#8220;Plt foo:&#8221;.
Since foo is the 2nd plt entry in &#8220;Plt foo:&#8221;, it save 2 to 0($gp) memory
address then jump to PLT0.
The purpose of PLT0 is to save $lr, $fp, $sp and jump to dynamic linker.
Now, the control flow transfers to dynamic linker.
Dynamic linker will get the loaded function name and function offset of shared
library by the value of 0($gp) which is 2 now (set in &#8220;Plt foo:&#8221;). The value
2 tells dynamic linker loading foo() (2nd string in .dynstr) from offset of
shared library, 0x38 (2nd value of Function offset area in Figure).
Now, dynamic linker can load foo() function from flash to memory, set the
address gp+16+2*4(=gp+24) to 0x40000 where the address 0x40000 is the memory
address of foo() function loaded to, and then prepare jump to the foo() memory
address.
Remind we say the prepare jump to foo(). Because before jump to foo(), dynamic
linker needs to restore the $lr, $fp, $sp to the
value of just before caller calling foo() (they are saved in offset 4, 8, 12 of
$gp in PLT0, so them can be restored from that address).</p>
<div class="figure align-center" id="id29">
<span id="lld-f8"></span><a class="reference internal image-reference" href="_images/8.png"><img alt="_images/8.png" src="_images/8.png" style="width: 378.4px; height: 451.2px;" /></a>
<p class="caption"><span class="caption-number">Fig. 12 </span><span class="caption-text">Transfer from dynamic linker to foo() and back to main()</span></p>
</div>
<p>As <a class="reference internal" href="#lld-f8"><span class="std std-numref">Fig. 12</span></a> depicted, control flow from dynamic linker to foo() and
back to caller main() when it meets the instruction &#8220;jr $lr&#8221; in foo().</p>
<div class="figure align-center" id="id30">
<span id="lld-f9"></span><a class="reference internal image-reference" href="_images/9.png"><img alt="_images/9.png" src="_images/9.png" style="width: 318.4px; height: 485.6px;" /></a>
<p class="caption"><span class="caption-number">Fig. 13 </span><span class="caption-text">Control flow transfer from calling bar() instruction of main() to dynamic linker</span></p>
</div>
<p>Now the program run at the next instruction of call foo() in main() as
<a class="reference internal" href="#lld-f9"><span class="std std-numref">Fig. 13</span></a> depicted. When it runs
to address 0xd84 &#8220;jsub __plt__Z3barv&#8221;, the control flow will transfer from
main through __plt_Z3barv, &#8220;Plt bar:&#8221; and PLT0 to dynamic linker as
<a class="reference internal" href="#lld-f9"><span class="std std-numref">Fig. 13</span></a> depicted. Then loading and running bar() from flash to
memory as <a class="reference internal" href="#lld-f10"><span class="std std-numref">Fig. 14</span></a> depicted.
It just like the calling __plt__Z3fooii.
The difference is bar() will call foo() first and call la() next.
The call foo() in bar() will jump to foo() directly as <a class="reference internal" href="#lld-f10"><span class="std std-numref">Fig. 14</span></a>
because the content of gp+24 is the address of 0x40000 which is
set by dynamic linker when the first time of foo() function is called.</p>
<div class="figure align-center" id="id31">
<span id="lld-f10"></span><a class="reference internal image-reference" href="_images/10.png"><img alt="_images/10.png" src="_images/10.png" style="width: 379.2px; height: 456.0px;" /></a>
<p class="caption"><span class="caption-number">Fig. 14 </span><span class="caption-text">Dynamic linker load bar() from flash to memory</span></p>
</div>
<p>Finally when bar() call la() function, it will jump to &#8220;Plt la:&#8221; since the
content of $gp+24 point to &#8220;Plt la:&#8221;.
The &#8220;Plt la:&#8221; code will call dynamic linker
to load la() function, run la() and back to bar() as <a class="reference internal" href="#lld-f11"><span class="std std-numref">Fig. 15</span></a>.</p>
<div class="figure align-center" id="id32">
<span id="lld-f11"></span><a class="reference internal image-reference" href="_images/111.png"><img alt="_images/111.png" src="_images/111.png" style="width: 228.8px; height: 453.6px;" /></a>
<p class="caption"><span class="caption-number">Fig. 15 </span><span class="caption-text">Call la through &#8220;Plt la:&#8221; in bar()</span></p>
</div>
<p>The dynamic linker implementation usually is not specified in ABI. It needs the
co-work between linker and dynamic linker/loader. It uses the pointers (the area
from gp+16+1*4 to gp+16+(numDynEntry-1)*4). When the code is loaded, this
corresponding pointer in this area points to the loaded memory. Otherwise, it
points to dynamic linker. The Plt or __plt_Z3fooii, __pltZ3barv are coding in
our cpu0PltAtomContent[] of Cpu0RelocationPass.cpp. Page 5-12 of Mips ABI has
sample stub code <a class="footnote-reference" href="#pic-call-stub" id="id7">[6]</a>.</p>
</div>
</div>
</div>
<div class="section" id="summary">
<h2><a class="toc-backref" href="#id51">Summary</a><a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h2>
<div class="section" id="create-a-new-backend-base-on-llvm">
<h3><a class="toc-backref" href="#id52">Create a new backend base on LLVM</a><a class="headerlink" href="#create-a-new-backend-base-on-llvm" title="Permalink to this headline">¶</a></h3>
<p>Thanks the llvm open source project.
To write a linker and ELF to Hex tools for a new CPU architecture is easy and
reliable.
Combined with the llvm Cpu0 backend code and Verilog language code programmed
in previouse chapters, we design a software
toolchain to compile C/C++ code, link and run it on Verilog Cpu0 simulator
without any real hardware investment.
If you buy the FPGA development hardware, we believe these
code can run on FPGA CPU even though we didn&#8217;t do it.
Extend system program toolchain to support a new CPU instruction set can be
finished just like we have shown you at this point.
School knowledges of system program, compiler, linker, loader, computer
architecture and CPU design has been translated into a real work and see how it
is running. Now, these school books knowledge is not limited on paper.
We design it, program it, and run it on real world.</p>
<p>The total code size of llvm Cpu0 backend compiler, Cpu0 lld linker, elf2hex and
Cpu0 Verilog Language is around 10 thousands lines of source code include
comments.
The total code size of clang, llvm and lld has 1000 thousands lines exclude the
test and documents parts. It is only 1 % of the llvm size.
More over, the llvm Cpu0 backend and lld Cpu0 backend are 70% of same with llvm
Mips and lld X86_64.
Based on this truth, we believe llvm is a well defined structure in compiler
architecture.</p>
</div>
<div class="section" id="contribute-back-to-open-source-through-working-and-learning">
<h3><a class="toc-backref" href="#id53">Contribute back to Open Source through working and learning</a><a class="headerlink" href="#contribute-back-to-open-source-through-working-and-learning" title="Permalink to this headline">¶</a></h3>
<p>Finally, 10 thousands lines of source code in Cpu0 backend is very small in UI
program. But it&#8217;s quite complex in system program which based on llvm.
We spent 600 pages of pdf to explain these code. Open source code give
programmers best opportunity to understand the code and enhance/extend the
code function. But it can be better, we believe the documentation is the next
most important thing to improve the open source code development.
The Open Source Organization recognized this point and set
Open Source Document Project years ago <a class="footnote-reference" href="#bsdlicense" id="id8">[7]</a> <a class="footnote-reference" href="#docproj" id="id9">[8]</a>
<a class="footnote-reference" href="#freebsdlicense" id="id10">[9]</a> <a class="footnote-reference" href="#gnulicense" id="id11">[10]</a> <a class="footnote-reference" href="#fdl" id="id12">[11]</a>.
Open Source grows up and becomes a giant software infrastructure with the forces
of company <a class="footnote-reference" href="#apple-opensource" id="id13">[12]</a>  <a class="footnote-reference" href="#ibm-opensource" id="id14">[13]</a>, school research team and
countless talent engineers passion.
It terminated the situation of everyone trying to re-invent wheels during 10
years ago.
Extend your software from the re-usable source code is the right way.
Of course you should consider an open source license if you are working
with business.
Actually anyone can contribute back to open source through the learning process.
This book is written through the process of learning llvm backend and contribute
back to llvm open source project.
We think this book cannot exists in traditional paper book form since only
few number of readers interested in study llvm backend even though
there are many paper published books in concept of compiler. So, this book
is published via electric media form and try to match the Open Document License
Expection <a class="footnote-reference" href="#gnu-phi" id="id15">[14]</a>.
There are distance between the concept and the realistic program implemenation.
Keep note through learning a large complicate software such as this llvm backend
is not enough.
We all learned the knowledge through books during school and after school.
So, if you cannot find a good way to produce documents, you can consider to
write documents like this book. This book document uses sphinx tool
just like the llvm development team. Sphinx uses restructured text format here
<a class="footnote-reference" href="#rst-ref" id="id16">[15]</a> <a class="footnote-reference" href="#rst-directives" id="id17">[16]</a> <a class="footnote-reference" href="#rst" id="id18">[17]</a>.
Appendix A of lbd book tell you how to install sphinx tool.
Documentation work will help yourself to re-examine your software and make your
program better in structure, reliability and more important &#8220;Extend your code
to somewhere you didn&#8217;t expect&#8221;.</p>
<table class="docutils footnote" frame="void" id="lldweb" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><a class="reference external" href="http://lld.llvm.org/">http://lld.llvm.org/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="lld-install" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td><a class="reference external" href="http://lld.llvm.org/getting_started.html#on-unix-like-systems">http://lld.llvm.org/getting_started.html#on-unix-like-systems</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="llvm-download" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td><a class="reference external" href="http://llvm.org/releases/download.html#3.5">http://llvm.org/releases/download.html#3.5</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="get" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td><a class="reference external" href="http://www.cplusplus.com/reference/memory/unique_ptr/get/">http://www.cplusplus.com/reference/memory/unique_ptr/get/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="move" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[5]</a></td><td><a class="reference external" href="http://www.cplusplus.com/reference/utility/move/">http://www.cplusplus.com/reference/utility/move/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="pic-call-stub" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[6]</a></td><td>Page 5-12 of <a class="reference external" href="http://www.linux-mips.org/pub/linux/mips/doc/ABI/mipsabi.pdf">http://www.linux-mips.org/pub/linux/mips/doc/ABI/mipsabi.pdf</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="bsdlicense" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[7]</a></td><td><a class="reference external" href="http://en.wikipedia.org/wiki/BSD_Documentation_License">http://en.wikipedia.org/wiki/BSD_Documentation_License</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="docproj" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[8]</a></td><td><a class="reference external" href="http://www.freebsd.org/docproj/">http://www.freebsd.org/docproj/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="freebsdlicense" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[9]</a></td><td><a class="reference external" href="http://www.freebsd.org/copyright/freebsd-doc-license.html">http://www.freebsd.org/copyright/freebsd-doc-license.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="gnulicense" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id11">[10]</a></td><td><a class="reference external" href="http://en.wikipedia.org/wiki/GNU_Free_Documentation_License">http://en.wikipedia.org/wiki/GNU_Free_Documentation_License</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="fdl" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id12">[11]</a></td><td><a class="reference external" href="http://www.gnu.org/copyleft/fdl.html">http://www.gnu.org/copyleft/fdl.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="apple-opensource" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id13">[12]</a></td><td><a class="reference external" href="http://www.apple.com/opensource/">http://www.apple.com/opensource/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="ibm-opensource" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id14">[13]</a></td><td><a class="reference external" href="https://www.ibm.com/developerworks/opensource/">https://www.ibm.com/developerworks/opensource/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="gnu-phi" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id15">[14]</a></td><td><a class="reference external" href="http://www.gnu.org/philosophy/free-doc.en.html">http://www.gnu.org/philosophy/free-doc.en.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="rst-ref" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id16">[15]</a></td><td><a class="reference external" href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="rst-directives" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id17">[16]</a></td><td><a class="reference external" href="http://docutils.sourceforge.net/docs/ref/rst/directives.html">http://docutils.sourceforge.net/docs/ref/rst/directives.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="rst" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id18">[17]</a></td><td><a class="reference external" href="http://docutils.sourceforge.net/rst.html">http://docutils.sourceforge.net/rst.html</a></td></tr>
</tbody>
</table>
</div>
</div>
</div>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="about.html">About</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="opt.html">Optimization</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &copy; Copyright 2016, Chen Chung-Shu.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.4.
    </div>
  </body>
</html>